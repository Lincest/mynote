# 01. C++初步知识

## 1 | 命名空间`namespace`

1. C++**标准库中的类和函数**是在名字空间`std`中声明的

2. 名字空间可以消除那些因重名而导致的命名冲突

3. 能在名字空间以外声明或定义的实体，同样也能在名字空间之内声明或定义

### 定义方式

```c++
namespace ns1 {
    ...;
}
```

#### 无名的名字空间

c++允许使用没有名字的名字空间

```c++
namespace {
    ...;
}
```

- 由于名字空间没有名字, 因此无法在其他文件中引用
- 无名名字空间内的成员作用域为**本文件**从声明无名名字空间的位置开始到本文件结束

## 2 | 输入和输出

| 运算符 |     名称     |
| :----: | :----------: |
|   >>   | 流提取运算符 |
|   <<   | 流插入运算符 |

在C++中:

- 输出操作可理解为将数据**插入到输出流对象**中

- 输入操作可理解为**从输入流对象中提取数据**

## 3 | 用const定义常量

`#define`定义的符号常量是在**预编译时进行字符替换**, 又称宏替换

const定义常量:

```cpp
const int maxl = 1000
```

- 用const定义标识符常量时, 一定要对其进行初始化, 在声明时进行初始化是对常量赋值的唯一方式

### const和define的区别

- const常量有数据类型而宏常量没有
- 有些集成调试工具可以对const常量进行调试而不能对宏常量进行调试

## 4 | 函数原型声明

在C++中，如果函数调用的位置在函数定义之前，则要求在函数调用之前必须对所调用的函数作函数原型声明。

函数原型声明的一般形式为:

```
函数类型 函数名 (参数表);
```

## 5 | 函数模板

定义方式:

```cpp
// 方式一
template<typename T1, typename T2 ...>
// 方式二
template<class T1, class T2 ...>

// 例子1
template<class T>
T max(T a, T b) {
    return a > b ? a : b;
}
// 例子2 (多个类型参数)
template<class T1, class T2>
T1 max(T1 a, T2 b) {
    return a > b ? a : (T1)b; // 进行类型转换, 因为返回值类型为T1
}
```

## 6 | 有默认参数的函数

C++可以给形参一个默认值，这样形参就不必一定要从实参取值。

- 如果有多个形参，可以指定任意个默认值。
- 实参与形参的结合是从左至右进行的，因此指定默认值的参数必须放在形参列表中的最右端。
- 必须在函数调用之前将默认值的信息通知编译系统。
- 当重载函数与默认参数函数共同使用时，要注意出现二义性问题。              

## 7 | 引用

> 起别名

### 关于返回值为引用

> 返回值为引用, 即返回别名

例子:

```cpp
int  a=4;
int  &f(int  x)
{    
    a=a+x;
    return a; }
int main()
{    
    int   t=5;
    cout<<f(t)<<endl;
    f(t)=20; // 可以这么赋值
    cout<<f(t)<<endl;
    return 0; 
}
```

## 8 | 内联函数

定义形式:

```cpp
inline 函数值类型 函数名 (参数表) {
	...;
}

// e.g.
inline void show () {
	cout << "hello" << endl;
}
```

>  调用内联函数时，编译器首先检查调用是否正确（类型安全检查或者自动进行类型转换）。如果正确，则**将内联函数的代码直接替换函数调用**，并且**用实参换形参**，于是省去了函数调用的开销。因此，内联机制增加了空间开销而节约了时间开销。

attention:

- 使用内联函数可以节省运行时间，但却增加了目标程序的长度。
- 函数体内出现循环或递归等复杂的结构控制语句时，不适合定义为内联函数。
- 一个好的编译器将会根据函数的函数体，自动取消不值得的内联。          

## 9 | 作用域运算符`::`

```cpp
#include <iostream>
using namespace std;
float a=13.5;
int main() {
  int a=5;
  cout<<a<<endl;
  cout<<::a<<endl; // 访问a = 13.5, ::a表示全局作用域中的变量a
  return 0;
}
```

## 10 | 字符串`string`



















