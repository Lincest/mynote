# STL

### 目录

- - [1. 容器](https://blog.csdn.net/weixin_45761327/article/details/107561697#1__11)
  - - [1.1 序列式容器](https://blog.csdn.net/weixin_45761327/article/details/107561697#11__18)
    - - [1. 数组(array)](https://blog.csdn.net/weixin_45761327/article/details/107561697#1_array_19)
      - - [数组-使用前](https://blog.csdn.net/weixin_45761327/article/details/107561697#_23)
        - [数组-创建与初始化](https://blog.csdn.net/weixin_45761327/article/details/107561697#_30)
        - [数组-array容器成员函数汇总](https://blog.csdn.net/weixin_45761327/article/details/107561697#array_47)
        - [数组-访问数组元素](https://blog.csdn.net/weixin_45761327/article/details/107561697#_94)
      - [2. 向量(vector)](https://blog.csdn.net/weixin_45761327/article/details/107561697#2_vector_125)
      - - [向量-使用前](https://blog.csdn.net/weixin_45761327/article/details/107561697#_129)
        - [向量-创建与初始化](https://blog.csdn.net/weixin_45761327/article/details/107561697#_136)
        - [向量-vector 容器的成员函数](https://blog.csdn.net/weixin_45761327/article/details/107561697#vector__169)
        - [向量-访问向量元素](https://blog.csdn.net/weixin_45761327/article/details/107561697#_209)
        - [向量-insert语法格式](https://blog.csdn.net/weixin_45761327/article/details/107561697#insert_249)
        - [向量-删除元素](https://blog.csdn.net/weixin_45761327/article/details/107561697#_292)
      - [3. 双端队列](https://blog.csdn.net/weixin_45761327/article/details/107561697#3__304)
      - - [队列-使用前](https://blog.csdn.net/weixin_45761327/article/details/107561697#_312)
        - [队列-创建与初始化](https://blog.csdn.net/weixin_45761327/article/details/107561697#_319)
        - [队列-deque容器的成员函数](https://blog.csdn.net/weixin_45761327/article/details/107561697#deque_353)
        - [队列-访问队列中的元素](https://blog.csdn.net/weixin_45761327/article/details/107561697#_388)
        - [队列-insert() 成员函数语法格式](https://blog.csdn.net/weixin_45761327/article/details/107561697#insert__423)
      - [4. 双链表](https://blog.csdn.net/weixin_45761327/article/details/107561697#4__448)
      - - [双链表-使用前](https://blog.csdn.net/weixin_45761327/article/details/107561697#_454)
        - [双链表-创建与初始化](https://blog.csdn.net/weixin_45761327/article/details/107561697#_463)
        - [双链表-list容器的成员函数](https://blog.csdn.net/weixin_45761327/article/details/107561697#list_493)
        - [双链表-访问链表中的元素](https://blog.csdn.net/weixin_45761327/article/details/107561697#_534)
        - [双链表-list添加（插入）元素](https://blog.csdn.net/weixin_45761327/article/details/107561697#list_552)
        - [双链表-insert()语法格式](https://blog.csdn.net/weixin_45761327/article/details/107561697#insert_562)
        - [双链表-list splice()成员方法](https://blog.csdn.net/weixin_45761327/article/details/107561697#list_splice_584)
        - [双链表-list删除元素](https://blog.csdn.net/weixin_45761327/article/details/107561697#list_615)
      - [5. 正向链表](https://blog.csdn.net/weixin_45761327/article/details/107561697#5__659)
      - - [单链表-使用前](https://blog.csdn.net/weixin_45761327/article/details/107561697#_664)
        - [单链表-创建与初始化](https://blog.csdn.net/weixin_45761327/article/details/107561697#_671)
        - [单链表- forward_list 容器可用的成员函数](https://blog.csdn.net/weixin_45761327/article/details/107561697#_forward_list__705)
      - [6. array、vector 和 deque 容器的函数成员](https://blog.csdn.net/weixin_45761327/article/details/107561697#6_arrayvector__deque__747)
      - [7. list 和 forward_list 的函数成员](https://blog.csdn.net/weixin_45761327/article/details/107561697#7__list__forward_list__781)
    - [1.2 关联式容器](https://blog.csdn.net/weixin_45761327/article/details/107561697#12__831)
    - - [1. pair类模板](https://blog.csdn.net/weixin_45761327/article/details/107561697#1_pair_850)
      - - [pair类的构造方法](https://blog.csdn.net/weixin_45761327/article/details/107561697#pair_855)
      - [2. map](https://blog.csdn.net/weixin_45761327/article/details/107561697#2_map_877)
      - - [map-使用前](https://blog.csdn.net/weixin_45761327/article/details/107561697#map_880)
        - [map-创建与初始化](https://blog.csdn.net/weixin_45761327/article/details/107561697#map_898)
        - [map-map容器常用成员方法](https://blog.csdn.net/weixin_45761327/article/details/107561697#mapmap_939)
        - [map-map获取键对应值](https://blog.csdn.net/weixin_45761327/article/details/107561697#mapmap_968)
        - [map-map insert()插入数据](https://blog.csdn.net/weixin_45761327/article/details/107561697#mapmap_insert_1011)
      - [3. multimap容器](https://blog.csdn.net/weixin_45761327/article/details/107561697#3_multimap_1119)
      - - [multimap-使用前](https://blog.csdn.net/weixin_45761327/article/details/107561697#multimap_1124)
        - [multimap-创建与初始化](https://blog.csdn.net/weixin_45761327/article/details/107561697#multimap_1131)
        - [multimap-multimap 容器常用成员方法](https://blog.csdn.net/weixin_45761327/article/details/107561697#multimapmultimap__1177)
      - [4. set](https://blog.csdn.net/weixin_45761327/article/details/107561697#4_set_1203)
      - - [set-使用前](https://blog.csdn.net/weixin_45761327/article/details/107561697#set_1206)
        - [set-创建与初始化](https://blog.csdn.net/weixin_45761327/article/details/107561697#set_1223)
        - [set-set 容器常用成员方法](https://blog.csdn.net/weixin_45761327/article/details/107561697#setset__1261)
        - [set-set迭代器](https://blog.csdn.net/weixin_45761327/article/details/107561697#setset_1290)
        - [set-insert()函数详解](https://blog.csdn.net/weixin_45761327/article/details/107561697#setinsert_1295)
        - [set-set删除数据](https://blog.csdn.net/weixin_45761327/article/details/107561697#setset_1390)
      - [5.multiset](https://blog.csdn.net/weixin_45761327/article/details/107561697#5multiset_1444)
      - - [multiset-使用前](https://blog.csdn.net/weixin_45761327/article/details/107561697#multiset_1446)
        - [multiset-创建与初始化](https://blog.csdn.net/weixin_45761327/article/details/107561697#multiset_1463)
        - [multiset-multiset 容器常用成员方法](https://blog.csdn.net/weixin_45761327/article/details/107561697#multisetmultiset__1500)
    - [1.3 无序关联式容器](https://blog.csdn.net/weixin_45761327/article/details/107561697#13__1530)
    - - [1. unordered_map](https://blog.csdn.net/weixin_45761327/article/details/107561697#1_unordered_map_1550)
      - - [unordered_map-使用前](https://blog.csdn.net/weixin_45761327/article/details/107561697#unordered_map_1551)
        - [unordered_map - 创建与初始化](https://blog.csdn.net/weixin_45761327/article/details/107561697#unordered_map___1571)
        - [unordered_map - unordered_map类模板成员方法](https://blog.csdn.net/weixin_45761327/article/details/107561697#unordered_map__unordered_map_1595)
      - [unordered_map - unordered_map获取元素](https://blog.csdn.net/weixin_45761327/article/details/107561697#unordered_map__unordered_map_1627)
      - - [unordered_map -insert()](https://blog.csdn.net/weixin_45761327/article/details/107561697#unordered_map_insert_1695)
        - [unordered_map-unordered_map删除元素](https://blog.csdn.net/weixin_45761327/article/details/107561697#unordered_mapunordered_map_1798)
      - [2. unordered_multimap](https://blog.csdn.net/weixin_45761327/article/details/107561697#2_unordered_multimap_1847)
      - - [unordered_multimap-使用前](https://blog.csdn.net/weixin_45761327/article/details/107561697#unordered_multimap_1849)
        - [unordered_multimap-创建与初始化](https://blog.csdn.net/weixin_45761327/article/details/107561697#unordered_multimap_1870)
        - [unordered_multimap类模板成员方法](https://blog.csdn.net/weixin_45761327/article/details/107561697#unordered_multimap_1895)
      - [3. unordered_set](https://blog.csdn.net/weixin_45761327/article/details/107561697#3_unordered_set_1925)
      - - [unordered_set-使用前](https://blog.csdn.net/weixin_45761327/article/details/107561697#unordered_set_1926)
        - [unordered_set-创建与初始化](https://blog.csdn.net/weixin_45761327/article/details/107561697#unordered_set_1945)
        - [unordered_set - unordered_set 类模板成员方法](https://blog.csdn.net/weixin_45761327/article/details/107561697#unordered_set__unordered_set__1972)
      - [4. unordered_multiset](https://blog.csdn.net/weixin_45761327/article/details/107561697#4_unordered_multiset_2002)
      - - [unordered_multiset-使用前](https://blog.csdn.net/weixin_45761327/article/details/107561697#unordered_multiset_2004)
        - [unordered_multiset-创建与初始化](https://blog.csdn.net/weixin_45761327/article/details/107561697#unordered_multiset_2024)
    - [1.4 其他](https://blog.csdn.net/weixin_45761327/article/details/107561697#14__2080)
    - - [1.String](https://blog.csdn.net/weixin_45761327/article/details/107561697#1String_2081)
      - - [String - 创建与初始化](https://blog.csdn.net/weixin_45761327/article/details/107561697#String___2083)
        - [String - string 类的所有成员函数](https://blog.csdn.net/weixin_45761327/article/details/107561697#String__string__2102)
      - [2.栈](https://blog.csdn.net/weixin_45761327/article/details/107561697#2_2135)
      - - [栈-使用前](https://blog.csdn.net/weixin_45761327/article/details/107561697#_2136)
        - [栈-创建与初始化](https://blog.csdn.net/weixin_45761327/article/details/107561697#_2144)
        - [栈-常用函数](https://blog.csdn.net/weixin_45761327/article/details/107561697#_2171)
      - [3.queue](https://blog.csdn.net/weixin_45761327/article/details/107561697#3queue_2184)
      - - [queue- 使用前](https://blog.csdn.net/weixin_45761327/article/details/107561697#queue__2185)
        - [queue-创建于初始化](https://blog.csdn.net/weixin_45761327/article/details/107561697#queue_2193)
        - [queue-queue容器适配器支持的成员函数](https://blog.csdn.net/weixin_45761327/article/details/107561697#queuequeue_2224)
      - [4.priority_queue（优先队列）](https://blog.csdn.net/weixin_45761327/article/details/107561697#4priority_queue_2239)
      - - [priority_queue-使用前](https://blog.csdn.net/weixin_45761327/article/details/107561697#priority_queue_2244)
        - [priority_queue-创建与初始化](https://blog.csdn.net/weixin_45761327/article/details/107561697#priority_queue_2252)
        - [priority_queue-常用函数](https://blog.csdn.net/weixin_45761327/article/details/107561697#priority_queue_2283)
  - [2. 迭代器定义](https://blog.csdn.net/weixin_45761327/article/details/107561697#2__2331)



## 1. 容器

| 容器种类 |                             功能                             |
| :------: | :----------------------------------------------------------: |
| 序列容器 | 主要包括 **vector** 向量容器、**list** 列表容器以及 **deque** 双端队列容器。 之所以被称为序列容器，是因为**元素在容器中的位置同元素的值无关，即容器不是排序的**。 将元素插入容器时，指定在什么位置，元素就会位于什么位置。 |
| 排序容器 | 包括 **set** 集合容器、**multiset**多重集合容器、**map**映射容器以及 **multimap** 多重映射容器。 **排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置**。所以关联容器在**查找时具有非常好的性能**。 |
| 哈希容器 | C++ 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。 和排序容器不同，哈希容器中的元素是未排序的，**元素的位置由哈希函数确定**。 |

### 1.1 序列式容器

#### 1. 数组(array)

array<T,N>（数组容器）：表示可以存储 N 个 T 类型的元素,元素个数固定。就是一个添加了一些成员函数和全局函数的数组，效率不降的情况下比普通数组更加安全。

##### 数组-使用前

在使用数组容器之前，代码中需引入`<array>`头文件，并默认使用 std 命令空间，如下所示：

```cpp
#include <array>
using namespace std;
```

##### 数组-创建与初始化

array 容器有多种初始化方式，具体如下：

- 创建具有 4 个 int 类型元素的 array 容器：

```cpp
std::array<double, 10> values;//若已指定std命名空间，则可省略std::
```

- 创建时将所有的元素初始化为 0 或者和默认元素类型等效的值：

```cpp
std::array<double, 10> values {};
```

- 像创建常规数组那样对元素进行初始化

```cpp
std::array<double, 10> values {0.5,1.0,1.5,2.0};//如同常规数组一样，初始化时未涉及的其余元素都会被初始化为0
```


##### 数组-array容器成员函数汇总

重要的函数已加粗

|        成员函数         |                             功能                             |
| :---------------------: | :----------------------------------------------------------: |
|       **begin()**       |          返回指向容器中第一个元素的随机访问迭代器。          |
|        **end()**        | 返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。 |
|        rbegin()         |            返回指向最后一个元素的随机访问迭代器。            |
|         rend()          |       返回指向第一个元素之前一个位置的随机访问迭代器。       |
|        cbegin()         | 和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。 |
|         cend()          | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
|        crbegin()        | 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
|         crend()         | 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
|       **size()**        | 返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。 |
|       max_size()        | 返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。 |
|       **empty()**       | 判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。 |
|          at(n)          | 返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。 |
|       **front()**       | 返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。 |
|       **back()**        | 返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。 |
|         data()          | 返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能。 |
|      **fill(val)**      |            将 val 这个值赋值给容器中的每个元素。             |
| **array1.swap(array2)** | 交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。 |

部分函数使用示例

```cpp
#include <iostream>
//需要引入 array 头文件
#include <array>
using namespace std;
int main()
{
    std::array<int, 4> values{};
    //初始化 values 容器为 {0,1,2,3}
    for (int i = 0; i < values.size(); i++) {
        values.at(i) = i;
    }
    //使用 get() 重载函数输出指定位置元素
    cout << get<3>(values) << endl;
    //如果容器不为空，则输出容器中所有的元素
    if (!values.empty()) {
        for (auto val = values.begin(); val < values.end(); val++) {
            cout << *val << " ";
        }
    }
}
```

##### 数组-访问数组元素

- 调用size()函数返回个数使用for循环遍历每个元素

```cpp
	array<int, 5> values{1,2,3,4,5};
    //从下标 0 一直遍历到 size()-1 处
    for (int i = 0; i < values.size(); i++) 
        cout << values[i] << " ";
```

- 使用迭代器进行访问-利用begin()/end() 函数

```cpp
	array<int, 5> values{1,2,3,4,5};
    for (auto first = values.begin(); first < values.end(); ++first) 	
        cout << *first << " ";
```

如上示例，我们可使用at()函数，但同时也可使用[]+索引的方式

- at()函数会检查越界，而索引的方式则不会进行检查

```cpp
values.at (4) = values.at(3) + 2.O*values.at(1);
values[4] = values[3] + 2.O*values[1];
```

同理我们可使用get()函数和索引的方式获取元素值

#### 2. 向量(vector)

vector（向量容器）：用来存放 T 类型的元素，是一个长度可变的序列容器,长度不足时会自动申请内存空间以增长。在尾部增删效率为O(1)，但在其他位置增删效率为O(n)

##### 向量-使用前

vector 容器以类模板 vector（ T 表示存储元素的类型）的形式定义在 `<vector>` 头文件中，并位于 `std` 命名空间中。因此，在创建该容器之前，代码中需包含如下内容：

```cpp
#include <vector>
using namespace std;
```

##### 向量-创建与初始化

创建 vector 容器的方式有很多，大致可分为以下几种。

- 创建一个空的存储double类型的vector容器

```cpp
std::vector<double> values;
```

- 创建时初始化值

```cpp
std::vector<int> primes {2, 3, 5, 7, 11, 13, 17, 19};
```

- 创建时指定元素个数

```cpp
std::vector<double> values(20);//这20个元素默认初始值都是0
```

- 创建时指定元素个数并指定默认初始值

```cpp
std::vector<double> values(20, 1.0);//这 20 个元素的初始值都是 1.0
```

- 通过存储元素类型相同的其它 vector 容器，可以创建新的 vector 容器

```cpp
std::vector<char>value1(5, 'c');
std::vector<char>value2(value1);
//若不想保存所有元素
int array[]={1,2,3};
std::vector<int>values(array, array+2);//values 将保存{1,2}
std::vector<int>value1{1,2,3,4,5};
std::vector<int>value2(std::begin(value1),std::begin(value1)+3);//value2保存{1,2,3}
```



##### 向量-vector 容器的成员函数

| 成员函数           | 功能                                                         |
| ------------------ | ------------------------------------------------------------ |
| **begin()**        | 返回指向容器中第一个元素的迭代器。                           |
| **end(**)          | 返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。 |
| rbegin()           | 返回指向最后一个元素的迭代器。                               |
| rend()             | 返回指向第一个元素所在位置前一个位置的迭代器。               |
| cbegin()           | 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
| cend()             | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
| crbegin()          | 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
| crend()            | 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
| **size()**         | 返回实际元素个数。                                           |
| max_size()         | 返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。 |
| resize()           | 改变实际元素的个数。                                         |
| capacity()         | 返回当前容量。                                               |
| **empty()**        | 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 |
| reserve()          | 增加容器的容量。                                             |
| shrink _to_fit()   | 将内存减少到等于当前元素实际所使用的大小。                   |
| **operator[ ]**    | 重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 |
| at()               | 使用经过边界检查的索引访问元素。                             |
| **front()**        | 返回第一个元素的引用。                                       |
| **back()**         | 返回最后一个元素的引用。                                     |
| data()             | 返回指向容器中第一个元素的指针。                             |
| assign()           | 用新元素替换原有内容。                                       |
| **push_back()**    | 在序列的尾部添加一个元素。                                   |
| **pop_back()**     | 移出序列尾部的元素。                                         |
| **insert()**       | 在指定的位置插入一个或多个元素。                             |
| **erase()**        | 移出一个元素或一段元素。                                     |
| **clear()**        | 移出所有的元素，容器大小变为 0。                             |
| **swap()**         | 交换两个容器的所有元素。                                     |
| emplace()          | 在指定的位置直接生成一个元素。                               |
| **emplace_back()** | 在序列尾部生成一个元素。                                     |

> 对于空的 vector 容器来说，begin() 和 end() 成员函数返回的迭代器是相等的，即它们指向的是同一个位置。
> 所以，对于空的 vector 容器来说，可以通过调用 push_back() 或者借助 resize() 成员函数实现初始化容器的目的。
> 除此之外，vector 容器在申请更多内存的同时，容器中的所有元素可能会被复制或移动到新的内存地址，这会导致之前创建的迭代器失效。

> 注意：emplace_back() 和 push_back() 的虽然都是向容器尾部添加一个元素 ， 但两者底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。
> 因此emplace_back()的效率会更高，
> insert()和emplace()同理。

##### 向量-访问向量元素

- 调用size()函数返回个数使用for循环遍历每个元素

```cpp
	vector<int> values{1,2,3,4,5};
    //从下标 0 一直遍历到 size()-1 处
    for (int i = 0; i < values.size(); i++) 
        cout << values[i] << " ";
```

- 使用迭代器进行访问-利用begin()/end() 函数

```cpp
	vector<int> values{1,2,3,4,5};
    for (auto first = values.begin(); first < values.end(); ++first) 	
        cout << *first << " ";
```

- 如上示例，我们可使用at()函数，但同时也可使用[]+索引的方式
  - at()函数会检查越界，而索引的方式则不会进行检查

```cpp
values.at (4) = values.at(3) + 2.O*values.at(1);
values[4] = values[3] + 2.O*values[1];
```

- 同理我们可使用get()函数和索引的方式获取元素值
- 我们可以调用front() 和 back()函数，它们分别返回 vector 容器中第一个和最后一个元素的引用，通过利用这 2 个函数返回的引用，可以访问（甚至修改）容器中的首尾元素。
- 我们也可以调用 data() 成员函数，该函数的功能是返回指向容器中首个元素的指针。通过该指针也可以访问甚至修改容器中的元素

```cpp
	vector<int> values{1,2,3,4,5};
    //输出容器中第 3 个元素的值
    cout << *(values.data() + 2) << endl;
    //修改容器中第 2 个元素的值
    *(values.data() + 1) = 10;
    cout << *(values.data() + 1) << endl;
```

##### 向量-insert语法格式

|            语法格式             |                             功能                             |
| :-----------------------------: | :----------------------------------------------------------: |
|    iterator insert(pos,elem)    | 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。 |
|   iterator insert(pos,n,elem)   | 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。 |
| iterator insert(pos,first,last) | 在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。 |
|  iterator insert(pos,initlist)  | 在迭代器 pos指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。 |

- iterator insert(pos,elem) 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。

```cpp
 	std::vector<int> demo{1,2};
    //第一种格式用法
    demo.insert(demo.begin() + 1, 3);//{1,3,2}
```

- iterator insert(pos,n,elem)
  在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。

```cpp
	 //第二种格式用法
    demo.insert(demo.end(), 2, 5);//{1,3,2,5,5}
```

- iterator insert(pos,first,last)
  在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。

```cpp
	 //第三种格式用法
    std::array<int,3>test{ 7,8,9 };
    demo.insert(demo.end(), test.begin(), test.end());//{1,3,2,5,5,7,8,9}
```

- iterator insert(pos,initlist)
  在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。

```cpp
	//第四种格式用法
    demo.insert(demo.end(), { 10,11 });//{1,3,2,5,5,7,8,9,10,11}
```

##### 向量-删除元素

删除 vector 容器元素的几种方式

| 函数                  | 功能                                                         |
| --------------------- | ------------------------------------------------------------ |
| pop_back()            | 删除 vector 容器中最后一个元素，该容器的大小（size）会减 1，但容量（capacity）不会发生改变。 |
| erase(pos)            | 删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置元素的迭代器。该容器的大小（size）会减 1，但容量（capacity）不会发生改变。 |
| swap(beg)、pop_back() | 先调用 swap() 函数交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back() 删除该目标元素。 |
| erase(beg,end)        | 删除 vector 容器中位于迭代器 [beg,end)指定区域内的所有元素，并返回指向被删除区域下一个位置元素的迭代器。该容器的大小（size）会减小，但容量（capacity）不会发生改变。 |
| remove()              | 删除容器中所有和指定元素值相等的元素，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。 |
| clear()               | 删除 vector 容器中所有的元素，使其变成空的 vector 容器。该函数会改变 vector 的大小（变为 0），但不是改变其容量。 |

#### 3. 双端队列

`deque<T>`（双端队列容器）：和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；

> 注意，其实除此之外，stack 和 queue 本质上也属于序列容器，只不过它们都是在 deque 容器的基础上改头换面而成，通常更习惯称它们为容器适配器，有关它们的介绍，会放到后续章节中。

##### 队列-使用前

deque 容器以模板类 deque（T 为存储元素的类型）的形式在 头文件中，并位于 std 命名空间中。因此，在使用该容器之前，代码中需要包含下面两行代码：

```cpp
#include <deque>
using namespace std;
```

##### 队列-创建与初始化

创建 deque 容器，根据不同的实际场景，可选择使用如下几种方式。

- 创建一个没有任何元素的空 deque 容器：

```cpp
std::deque<int> d;
```

- 创建一个具有 n 个元素的 deque 容器，其中每个元素都采用对应类型的默认值：

```cpp
std::deque<int> d(10);
```

- 创建一个具有 n 个元素的 deque 容器，并为每个元素都指定初始值，例如：

```cpp
std::deque<int> d(10, 5)
```

- 在已有 deque 容器的情况下，可以通过拷贝该容器创建一个新的 deque 容器，例如：

```cpp
std::deque<int> d1(5);
std::deque<int> d2(d1);
```

- 通过拷贝其他类型容器中指定区域内的元素（也可以是普通数组），可以创建一个新容器，例如：

```cpp
//拷贝普通数组，创建deque容器
int a[] = { 1,2,3,4,5 };
std::deque<int>d(a, a + 5);
//适用于所有类型的容器
std::array<int, 5>arr{ 11,12,13,14,15 };
std::deque<int>d(arr.begin()+2, arr.end());//拷贝arr容器中的{13,14,15}
```



##### 队列-deque容器的成员函数

重要函数已加粗标出

| 函数成员         | 函数功能                                                     |
| ---------------- | ------------------------------------------------------------ |
| **begin()**      | 返回指向容器中第一个元素的迭代器。                           |
| **end()**        | 返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。 |
| rbegin()         | 返回指向最后一个元素的迭代器。                               |
| rend()           | 返回指向第一个元素所在位置前一个位置的迭代器。               |
| cbegin()         | 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
| cend()           | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
| crbegin()        | 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
| crend()          | 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
| **size()**       | 返回实际元素个数。                                           |
| max_size()       | 返回容器所能容纳元素个数的最大值。这通常是一个很大的值，一般是 232-1，我们很少会用到这个函数。 |
| resize()         | 改变实际元素的个数。                                         |
| **empty()**      | 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 |
| shrink _to_fit() | 将内存减少到等于当前元素实际所使用的大小。                   |
| **at()**         | 使用经过边界检查的索引访问元素。                             |
| **front()**      | 返回第一个元素的引用。                                       |
| **back()**       | 返回最后一个元素的引用。                                     |
| assign()         | 用新元素替换原有内容。                                       |
| **push_back()**  | 在序列的尾部添加一个元素。                                   |
| **push_front()** | 在序列的头部添加一个元素。                                   |
| **pop_back()**   | 移除容器尾部的元素。                                         |
| **pop_front()**  | 移除容器头部的元素。                                         |
| **insert()**     | 在指定的位置插入一个或多个元素。                             |
| **erase()**      | 移除一个元素或一段元素。                                     |
| **clear()**      | 移出所有的元素，容器大小变为 0。                             |
| swap()           | 交换两个容器的所有元素。                                     |
| **emplace()**    | 在指定的位置直接生成一个元素。                               |
| emplace_front()  | 在容器头部生成一个元素。和 push_front() 的区别是，该函数直接在容器头部构造元素，省去了复制移动元素的过程。 |
| emplace_back()   | 在容器尾部生成一个元素。和 push_back() 的区别是，该函数直接在容器尾部构造元素，省去了复制移动元素的过程。 |

> 关于empalace()函数和insert()的效率问题前面已经讨论 这里不再涉及

##### 队列-访问队列中的元素

- 队列可以像普通数组一样采用索引的方式访问元素

```cpp
	deque<int>d{ 1,2,3,4 };
    cout << d[1] << endl;
    //修改指定下标位置处的元素
    d[1] = 5;
    cout << d[1] << endl;
```

- 队列可以调用at()函数来访问元素
  - at() 成员函数会自行判定访问位置是否越界，如果越界则抛出std::out_of_range异常。

```cpp
	deque<int>d{ 1,2,3,4 };
    cout << d.at(1) << endl;//2
    d.at(1) = 5;
    cout << d.at(1) << endl;//5
    //下面这条语句会抛出 out_of_range 异常
    //cout << d.at(10) << endl;
```

- 队列可以调用front()和back()函数来访问队列的首尾元素

```cpp
	deque<int> d{ 1,2,3,4,5 };
    cout << "deque 首元素为：" << d.front() << endl;//1
    cout << "deque 尾元素为：" << d.back() << endl;//5
    //修改首元素
    d.front() = 10;
    cout << "deque 新的首元素为：" << d.front() << endl;//10
    //修改尾元素
    d.back() = 20;
    cout << "deque 新的尾元素为：" << d.back() << endl;//20
```

- 注意，deque没有提供data()函数

##### 队列-insert() 成员函数语法格式

| 语法格式                        | 功能                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| iterator insert(pos,elem)       | 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。 |
| iterator insert(pos,n,elem)     | 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。 |
| iterator insert(pos,first,last) | 在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。 |
| iterator insert(pos,initlist)   | 在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。 |

```cpp
	std::deque<int> d{ 1,2 };
    //第一种格式用法
    d.insert(d.begin() + 1, 3);//{1,3,2}
    //第二种格式用法
    d.insert(d.end(), 2, 5);//{1,3,2,5,5}
    //第三种格式用法
    std::array<int, 3>test{ 7,8,9 };
    d.insert(d.end(), test.begin(), test.end());//{1,3,2,5,5,7,8,9}
    //第四种格式用法
    d.insert(d.end(), { 10,11 });//{1,3,2,5,5,7,8,9,10,11}
```

> 注意:下图为vector的insert()函数语法格式,注意到两者是一致的!
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200724195519659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc2MTMyNw==,size_16,color_FFFFFF,t_70)

#### 4. 双链表

`list<T>`（链表容器）：是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素。

实际场景中，如何需要对序列进行大量添加或删除元素的操作，而直接访问元素的需求却很少，这种情况建议使用 list 容器存储序列。

##### 双链表-使用前

list 容器以模板类 list（T 为存储元素的类型）的形式在头文件中，并位于 std 命名空间中。因此，在使用该容器之前，代码中需要包含下面两行代码：

```cpp
#include <list>
using namespace std;
```

> 注意，std 命名空间也可以在使用 list 容器时额外注明，两种方式都可以。

##### 双链表-创建与初始化

- 创建一个没有任何元素的空list容器

```cpp
std::list<int> values;
```

- 创建一个包含n个元素的list容器

```cpp
std::list<int> values(10);//注意:容积用小括号
```

- 创建一个包含n个元素的list容器并制定初始值

```cpp
std::list<int> values(10 , 5);
```

- 通过拷贝已有的list容器创建新的容器

```cpp
std::list<int> values1(10 , 5);
std::list<int> values2(values1);
```

- 通过拷贝已有的list容器中的部分元素创建新的容器

```cpp
//拷贝普通数组，创建list容器
int a[] = { 1,2,3,4,5 };
std::list<int> values(a, a+5);
//拷贝其它类型的容器，创建 list 容器
std::array<int, 5>arr{ 11,12,13,14,15 };
std::list<int>values(arr.begin()+2, arr.end());//拷贝arr容器中的{13,14,15}
```



##### 双链表-list容器的成员函数

重要的函数已加粗标出

|      成员函数       |                             功能                             |
| :-----------------: | :----------------------------------------------------------: |
|     **begin()**     |            返回指向容器中第一个元素的双向迭代器。            |
|      **end()**      |           返回指向容器中最后一个元素的双向迭代器。           |
|      rbegin()       |            返回指向最后一个元素的反向双向迭代器。            |
|       rend()        |    返回指向第一个元素所在位置前一个位置的反向双向迭代器。    |
|      cbegin()       | 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
|       cend()        | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
|      crbegin()      | 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
|       crend()       | 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
|       empty()       | 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 |
|     **size()**      |               返回当前容器实际包含的元素个数。               |
|     max_size()      | 返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。 |
|     **front()**     |                    返回第一个元素的引用。                    |
|     **back()**      |                   返回最后一个元素的引用。                   |
|      assign()       |                 用新元素替换容器中原有内容。                 |
| **emplace_front()** | 在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。 |
|  **push_front()**   |                   在容器头部插入一个元素。                   |
|   **pop_front()**   |                   删除容器头部的一个元素。                   |
| **emplace_back()**  | 在容器尾部直接生成一个元素。该函数和 push_back() 的功能相同，但效率更高。 |
|   **push_back()**   |                   在容器尾部插入一个元素。                   |
|   **pop_back()**    |                   删除容器尾部的一个元素。                   |
|    **emplace()**    | 在容器中的指定位置插入元素。该函数和 insert() 功能相同，但效率更高。 |
|    **insert()**     |                 在容器中的指定位置插入元素。                 |
|     **erase()**     |               删除容器中一个或某区域内的元素。               |
|       swap()        | 交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。 |
|      resize()       |                       调整容器的大小。                       |
|     **clear()**     |                   删除容器存储的所有元素。                   |
|      splice()       |     将一个 list 容器中的元素插入到另一个容器的指定位置。     |
|   **remove(val)**   |               删除容器中所有等于 val 的元素。                |
|     remove_if()     |                  删除容器中满足条件的元素。                  |
|      unique()       |            删除容器中相邻的重复元素，只保留一个。            |
|       merge()       | 合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的。 |
|     **sort()**      |          通过更改容器中元素的位置，将它们进行排序。          |
|    **reverse()**    |                    反转容器中元素的顺序。                    |

> emplace()系列函数和insert()系列函数的效率问题,前者更高,原因在前面已经给出,这里不再讨论.

##### 双链表-访问链表中的元素

- 访问 list 容器中存储元素的方式很有限，即要么使用 front() 和 back() 成员函数，要么使用 list 容器迭代器。
- list 容器不支持随机访问，未提供下标操作符 [] 和 at() 成员函数，也没有提供 data() 成员函数。
- 除此之外，如果想访问 list 容存储的其他元素，就只能使用 list 容器的迭代器。

```cpp
	const std::list<int> mylist{1,2,3,4,5};
    auto it = mylist.begin();
    cout << *it << " ";
    ++it;
    while (it!=mylist.end())
    {
        cout << *it << " ";
        ++it;  
    }
```

##### 双链表-list添加（插入）元素

list 模板类中，与“添加或插入新元素”相关的成员方法有如下几个：

- push_front()：向 list 容器首个元素前添加新元素；
- push_back()：向 list 容器最后一个元素后添加新元素；
- emplace_front()：在容器首个元素前直接生成新的元素；
- emplace_back()：在容器最后一个元素后直接生成新的元素；
- emplace()：在容器的指定位置直接生成新的元素；
- insert()：在指定位置插入新元素；
- splice()：将其他 list 容器存储的多个元素添加到当前 list 容器的指定位置处。

##### 双链表-insert()语法格式

| 语法格式                        | 功能                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| iterator insert(pos,elem)       | 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。 |
| iterator insert(pos,n,elem)     | 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。 |
| iterator insert(pos,first,last) | 在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。 |
| iterator insert(pos,initlist)   | 在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。 |

```cpp
	std::list<int> values{ 1,2 };
    //第一种格式用法
    values.insert(values.begin() , 3);//{3,1,2}
    //第二种格式用法
    values.insert(values.end(), 2, 5);//{3,1,2,5,5}
    //第三种格式用法
    std::array<int, 3>test{ 7,8,9 };
    values.insert(values.end(), test.begin(), test.end());//{3,1,2,5,5,7,8,9}
    //第四种格式用法
    values.insert(values.end(), { 10,11 });//{3,1,2,5,5,7,8,9,10,11}
```

> 注意！迄今为止，向量，队列，链表的insert()函数语法格式都是一致的

##### 双链表-list splice()成员方法

- 和 insert() 成员方法相比，splice() 成员方法的作用对象是其它 list 容器，其功能是将其它 list 容器中的元素添加到当前 list 容器中指定位置处。
- splice() 成员方法的语法格式有 3 种

|                           语法格式                           |                             功能                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|          void splice (iterator position, list& x);           | position 为迭代器，用于指明插入位置；x 为另一个 list 容器。 此格式的 splice() 方法的功能是，将 x 容器中存储的所有元素全部移动当前 list 容器中 position 指明的位置处。 |
|    void splice (iterator position, list& x, iterator i);     | position 为迭代器，用于指明插入位置；x 为另一个 list 容器；i 也是一个迭代器，用于指向 x 容器中某个元素。 此格式的 splice() 方法的功能是将 x 容器中 i 指向的元素移动到当前容器中 position 指明的位置处。 |
| void splice (iterator position, list& x, iterator first, iterator last); | position 为迭代器，用于指明插入位置；x 为另一个 list 容器；first 和 last 都是迭代器，[fist,last) 用于指定 x 容器中的某个区域。 此格式的 splice() 方法的功能是将 x 容器 [first, last) 范围内所有的元素移动到当前容器 position 指明的位置处。 |

```cpp
	//创建并初始化 2 个 list 容器
    list<int> mylist1{ 1,2,3,4 }, mylist2{10,20,30};
    list<int>::iterator it = ++mylist1.begin(); //指向 mylist1 容器中的元素 2
   
    //调用第一种语法格式
    mylist1.splice(it, mylist2); // mylist1: 1 10 20 30 2 3 4
                                 // mylist2:
                                 // it 迭代器仍然指向元素 2，只不过容器变为了 mylist1
    //调用第二种语法格式，将 it 指向的元素 2 移动到 mylist2.begin() 位置处
    mylist2.splice(mylist2.begin(), mylist1, it);   // mylist1: 1 10 20 30 3 4
                                                    // mylist2: 2
                                                    // it 仍然指向元素 2
   
    //调用第三种语法格式，将 [mylist1.begin(),mylist1.end())范围内的元素移动到 mylist.begin() 位置处                  
    mylist2.splice(mylist2.begin(), mylist1, mylist1.begin(),mylist1.end());//mylist1:
                                                                             //mylist2:1 10 20 30 3 4 2
```

##### 双链表-list删除元素

实现 list 容器删除元素的成员函数

|  成员函数   |                             功能                             |
| :---------: | :----------------------------------------------------------: |
| pop_front() |              删除位于 list 容器头部的一个元素。              |
| pop_back()  |              删除位于 list 容器尾部的一个元素。              |
|   erase()   | 该成员函数既可以删除 list 容器中指定位置处的元素，也可以删除容器中某个区域内的多个元素。 |
|   clear()   |                删除 list 容器存储的所有元素。                |
| remove(val) |               删除容器中所有等于 val 的元素。                |
|  unique()   |            删除容器中相邻的重复元素，只保留一份。            |
| remove_if() |                  删除容器中满足条件的元素。                  |

> erase()函数可传入一个或两个迭代器的位置,分别为删除一个和一段的元素
> 若想根据元素的值来执行删除操作,则可使用remove操作,直接传入值即可
> unique() 函数也可选择是否传入一个二元谓词函数,可自定义去重规则
> remove_if()和unique()一致,可选择是否传入二元谓词函数

```cpp
#include <iostream>
#include <list>
using namespace std;
//二元谓词函数
bool demo(double first, double second)
{
    return (int(first) == int(second));
}
int main()
{
    list<double> mylist{ 1,1.2,1.2,3,4,4.5,4.6 };
    //删除相邻重复的元素，仅保留一份
    mylist.unique();//{1, 1.2, 3, 4, 4.5, 4.6}
    for (auto it = mylist.begin(); it != mylist.end(); ++it)
        cout << *it << ' ';
    cout << endl;
    //demo 为二元谓词函数，是我们自定义的去重规则
    mylist.unique(demo);//传入demo自定义去重规则
    for (auto it = mylist.begin(); it != mylist.end(); ++it)
        std::cout << *it << ' ';
    return 0;
}
```

#### 5. 正向链表

`forward_list<T>`（正向链表容器）：和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。

##### 单链表-使用前

由于 forward_list 容器以模板类 forward_list（T 为存储元素的类型）的形式被包含在<forward_list>头文件中，并定义在 std 命名空间中。因此，在使用该容器之前，代码中需包含下面两行代码：

```cpp
#include <forward_list>
using namespace std;
```

##### 单链表-创建与初始化

创建 forward_list 容器的方式，大致分为以下 5 种。

- 创建一个没有任何元素的空list容器

```cpp
std::forward_list<int> values;
```

- 创建一个包含n个元素的list容器

```cpp
std::forward_list<int> values(10);//注意:容积用小括号
```

- 创建一个包含n个元素的list容器并制定初始值

```cpp
std::forward_list<int> values(10 , 5);
```

- 通过拷贝已有的list容器创建新的容器

```cpp
std::forward_list<int> values1(10 , 5);
std::forward_list<int> values2(values1);
```

- 通过拷贝已有的list容器中的部分元素创建新的容器

```cpp
//拷贝普通数组，创建list容器
int a[] = { 1,2,3,4,5 };
std::forward_list<int> values(a, a+5);
//拷贝其它类型的容器，创建 list 容器
std::array<int, 5>arr{ 11,12,13,14,15 };
std::forward_list<int>values(arr.begin()+2, arr.end());//拷贝arr容器中的{13,14,15}
```

> 仔细观察,单链表和双链表的初始化方式都是一样的



##### 单链表- forward_list 容器可用的成员函数

重要的函数已加粗标出

|      成员函数       |                             功能                             |
| :-----------------: | :----------------------------------------------------------: |
|   before_begin()    |    返回一个前向迭代器，其指向容器中第一个元素之前的位置。    |
|     **begin()**     |      返回一个前向迭代器，其指向容器中第一个元素的位置。      |
|      **end()**      |   返回一个前向迭代器，其指向容器中最后一个元素之后的位置。   |
|   cbefore_begin()   | 和 before_begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
|      cbegin()       | 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
|       cend()        | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 |
|     **empty()**     | 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 |
|     max_size()      | 返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。 |
|     **front()**     |                    返回第一个元素的引用。                    |
|      assign()       |                 用新元素替换容器中原有内容。                 |
|  **push_front()**   |                   在容器头部插入一个元素。                   |
| **emplace_front()** | 在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。 |
|   **pop_front()**   |                   删除容器头部的一个元素。                   |
| **emplace_after()** | 在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。和 insert_after() 的功能相同，但效率更高。 |
| **insert_after()**  | 在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。 |
|  **erase_after()**  |          删除容器中某个指定位置或区域内的所有元素。          |
|       swap()        | 交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。 |
|      resize()       |                       调整容器的大小。                       |
|     **clear()**     |                   删除容器存储的所有元素。                   |
|   splice_after()    | 将某个 forward_list 容器中指定位置或区域内的元素插入到另一个容器的指定位置之后。 |
|   **remove(val)**   |               删除容器中所有等于 val 的元素。                |
|   **remove_if()**   |                  删除容器中满足条件的元素。                  |
|      unique()       |            删除容器中相邻的重复元素，只保留一个。            |
|       merge()       | 合并两个事先已排好序的 forward_list 容器，并且合并之后的 forward_list 容器依然是有序的。 |
|     **sort()**      |          通过更改容器中元素的位置，将它们进行排序。          |
|      reverse()      |                    反转容器中元素的顺序。                    |

> 关于empalace()函数和insert()的效率问题前面已经讨论 这里不再涉及

- 通过表我们知道，forward_list 容器中是不提供 size() 函数的，但如果想要获取 forward_list 容器中存储元素的个数，可以使用头文件 `<iterator>` 中的 distance() 函数。举个例子

```cpp
	std::forward_list<int> my_words{1,2,3,4};
    int count = std::distance(std::begin(my_words), std::end(my_words));
    cout << count;
```



#### 6. array、vector 和 deque 容器的函数成员

| 函数成员         | 函数功能                                                     | array<T,N> | vector | deque |
| ---------------- | ------------------------------------------------------------ | ---------- | ------ | ----- |
| **begin()**      | 返回指向容器中第一个元素的迭代器。                           | 是         | 是     | 是    |
| **end()**        | 返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。 | 是         | 是     | 是    |
| rbegin()         | 返回指向最后一个元素的迭代器。                               | 是         | 是     | 是    |
| rend()           | 返回指向第一个元素所在位置前一个位置的迭代器。               | 是         | 是     | 是    |
| cbegin()         | 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 | 是         | 是     | 是    |
| cend()           | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 | 是         | 是     | 是    |
| crbegin()        | 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 | 是         | 是     | 是    |
| crend()          | 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 | 是         | 是     | 是    |
| assign()         | 用新元素替换原有内容。                                       | -          | 是     | 是    |
| operator=()      | 复制同类型容器的元素，或者用初始化列表替换现有内容。         | 是         | 是     | 是    |
| **size()**       | 返回实际元素个数。                                           | 是         | 是     | 是    |
| max_size()       | 返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。 | 是         | 是     | 是    |
| capacity()       | 返回当前容量。                                               | -          | 是     | -     |
| **empty()**      | 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 | 是         | 是     | 是    |
| resize()         | 改变实际元素的个数。                                         | -          | 是     | 是    |
| shrink _to_fit() | 将内存减少到等于当前元素实际所使用的大小。                   | -          | 是     | 是    |
| **front()**      | 返回第一个元素的引用。                                       | 是         | 是     | 是    |
| **back()**       | 返回最后一个元素的引用。                                     | 是         | 是     | 是    |
| **operator[]()** | 使用索引访问元素。                                           | 是         | 是     | 是    |
| at()             | 使用经过边界检査的索引访问元素。                             | 是         | 是     | 是    |
| **push_back()**  | 在序列的尾部添加一个元素。                                   | -          | 是     | 是    |
| **insert()**     | 在指定的位置插入一个或多个元素。                             | -          | 是     | 是    |
| emplace()        | 在指定的位置直接生成一个元素。                               | -          | 是     | 是    |
| emplace_back()   | 在序列尾部生成一个元素。                                     | -          | 是     | 是    |
| pop_back()       | 移出序列尾部的元素。                                         | -          | 是     | 是    |
| **erase()**      | 移出一个元素或一段元素。                                     | -          | 是     | 是    |
| **clear()**      | 移出所有的元素，容器大小变为 0。                             | -          | 是     | 是    |
| **swap()**       | 交换两个容器的所有元素。                                     | 是         | 是     | 是    |
| data()           | 返回指向容器中第一个元素的指针。                             |            |        |       |
| 是               | 是                                                           | -          |        |       |



#### 7. list 和 forward_list 的函数成员

list 和 forward_list 容器彼此非常相似，forward_list 中包含了 list 的大部分成员函数，而未包含那些需要反向遍历的函数。表 3 展示了 list 和 forward_list 的函数成员。

| 函数成员         | 函数功能                                                     | list | forward_list |
| ---------------- | ------------------------------------------------------------ | ---- | ------------ |
| **begin()**      | 返回指向容器中第一个元素的迭代器                             | 是   | 是           |
| **end()**        | 返回指向容器最后一个元素所在位置后一个位置的迭代器。         | 是   | 是           |
| rbegin()         | 返回指向最后一个元素的迭代器。                               | 是   | -            |
| rend()           | 返回指向第一个元素所在位置前一个位置的迭代器。               | 是   | -            |
| cbegin()         | 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 | 是   | 是           |
| before_begin()   | 返回指向第一个元素前一个位置的迭代器。                       | -    | 是           |
| cbefore_begin()  | 和 before_begin() 功能相同，只不过在其基础上，增加了 const 属性，即不能用该指针修改元素的值。 | -    | 是           |
| cend()           | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 | 是   | 是           |
| crbegin()        | 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 | 是   | -            |
| crend()          | 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 | 是   | -            |
| assign()         | 用新元素替换原有内容。                                       | 是   | 是           |
| operator=()      | 复制同类型容器的元素，或者用初始化列表替换现有内容。         | 是   | 是           |
| **size()**       | 返回实际元素个数。                                           | 是   | -            |
| max_size()       | 返回元素个数的最大值，这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。 | 是   | 是           |
| resize()         | 改变实际元素的个数。                                         | 是   | 是           |
| **empty()**      | 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 | 是   | 是           |
| **front()**      | 返回容器中第一个元素的引用。                                 | 是   | 是           |
| **back()**       | 返回容器中最后一个元素的引用。                               | 是   | -            |
| **push_back()**  | 在序列的尾部添加一个元素。                                   | 是   | -            |
| **push_front()** | 在序列的起始位置添加一个元素。                               | 是   | 是           |
| emplace()        | 在指定位置直接生成一个元素。                                 | 是   | -            |
| emplace_after()  | 在指定位置的后面直接生成一个元素。                           | -    | 是           |
| emplace_back()   | 在序列尾部生成一个元素。                                     | 是   | -            |
| cmplacc_front()  | 在序列的起始位生成一个元索。                                 | 是   | 是           |
| **insert()**     | 在指定的位置插入一个或多个元素。                             | 是   | -            |
| insert_after()   | 在指定位置的后面插入一个或多个元素。                         | -    | 是           |
| pop_back()       | 移除序列尾部的元素。                                         | 是   | -            |
| pop_front()      | 移除序列头部的元素。                                         | 是   | 是           |
| reverse()        | 反转容器中某一段的元素。                                     | 是   | 是           |
| **erase()**      | 移除指定位置的一个元素或一段元素。                           | 是   | -            |
| erase_after()    | 移除指定位置后面的一个元素或一段元素。                       | -    | 是           |
| remove()         | 移除所有和参数匹配的元素。                                   | 是   | 是           |
| remove_if()      | 移除满足一元函数条件的所有元素。                             | 是   | 是           |
| unique()         | 移除所有连续重复的元素。                                     | 是   | 是           |
| **clear()**      | 移除所有的元素，容器大小变为 0。                             | 是   | 是           |
| **swap()**       | 交换两个容器的所有元素。                                     | 是   | 是           |
| **sort()**       | 对元素进行排序。                                             | 是   | 是           |
| merge()          | 合并两个有序容器。                                           | 是   | 是           |
| splice()         | 移动指定位置前面的所有元素到另一个同类型的 list 中。         | 是   | -            |
| splice_after()   | 移动指定位置后面的所有元素到另一个同类型的 list 中。         | -    | 是           |

### 1.2 关联式容器

和序列式容器不同的是，关联式容器在存储元素时还会为每个元素在配备一个键，整体以键值对的方式存储到容器中。相比前者，关联式容器可以通过键值直接找到对应的元素，而无需遍历整个容器。另外，关联式容器在存储元素，默认会根据各元素键值的大小做升序排序。

相比其它类型容器，关联式容器查找、访问、插入和删除指定元素的效率更高。

弃用序列式容器，转而选用关联式容器存储元素，往往就是看中了关联式容器可以快速查找、读取或者删除所存储的元素，同时该类型容器插入元素的效率也比序列式容器高。

关联式容器所具备的这些特性，归咎于 STL 标准库在实现该类型容器时，底层选用了 「红黑树」这种数据结构来组织和存储各个键值对。

关联式容器，包括 map、multimap、set 以及 multiset 这 4 种容器。

| 关联式容器名称 |                             特点                             |
| :------------: | :----------------------------------------------------------: |
|      map       | 定义在 `<map>` 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根据各元素键的大小，默认进行升序排序（调用 `std::less<T>`）。 |
|      set       | 定义在 `<set>` 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序（调用 `std::less<T>`）。 |
|    multimap    | 定义在 `<map>` 头文件中，和 map 容器唯一的不同在于，multimap 容器中存储元素的键可以重复。 |
|    multiset    | 定义在 `<set>` 头文件中，和 set 容器唯一的不同在于，multiset 容器中存储元素的值可以重复（一旦值重复，则意味着键也是重复的）。 |

#### 1. pair类模板

pair 类模板定义在`<utility>`头文件中，所以在使用该类模板之前，需引入此头文件。

C++ STL 标准库提供了 pair 类模板，其专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素<first, second>

##### pair类的构造方法

```cpp
#1) 默认构造函数，即创建空的 pair 对象
pair(); 
pair <string, double> pair1;

#2) 直接使用 2 个元素初始化成 pair 对象
pair (const first_type& a, const second_type& b);
pair <string, string> pair2("STL教程","http://c.biancheng.net/stl/"); 

#3) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象
template<class U, class V> pair (const pair<U,V>& pr);
pair <string, string> pair3(pair2);

#4) 移动构造函数
template<class U, class V> pair (pair<U,V>&& pr);
pair <string, string> pair4(make_pair("C++教程", "http://c.biancheng.net/cplus/"));

#5) 使用右值引用参数，创建 pair 对象
template<class U, class V> pair (U&& a, V&& b);
pair <string, string> pair5(string("Python教程"), string("http://c.biancheng.net/python/"));  
```

`<utility>`头文件中除了提供创建 pair 对象的方法之外，还为 pair 对象重载了 <、<=、>、>=、==、!= 这 6 的运算符，其运算规则是：对于进行比较的 2 个 pair 对象，先比较 pair.first 元素的大小，如果相等则继续比较 pair.second 元素的大小。

#### 2. map

作为关联式容器的一种，map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。其中，各个键值对的键和值可以是任意数据类型，包括 C++ 基本数据类型（int、double 等）、使用结构体或类自定义的类型。

##### map-使用前

map 容器定义在 `<map>` 头文件中，并位于 std 命名空间中。因此，如果想使用 map 容器，代码中应包含如下语句：

```cpp
#include <map>
using namespace std;
```

map 容器的模板定义如下：

```cpp
template < class Key,                                     // 指定键（key）的类型
           class T,                                       // 指定值（value）的类型
           class Compare = less<Key>,                     // 指定排序规则
           class Alloc = allocator<pair<const Key,T> >    // 指定分配器对象的类型
           > class map;
```

可以看到，map 容器模板有 4 个参数，其中后 2 个参数都设有默认值。大多数场景中，我们只需要设定前 2 个参数的值，有些场景可能会用到第 3 个参数，但最后一个参数几乎不会用到。

##### map-创建与初始化

- 创建一个空的map容器

```cpp
std::map<std::string, int>myMap;
```

- 在创建map容器的同时进行初始化

```cpp
std::map<std::string, int>myMap{ {"C语言教程",10},{"STL教程",20} };

std::map<std::string, int>myMap{std::make_pair("C语言教程",10),std::make_pair("STL教程",20)};
```

- 利用已有的map容器创建新的map容器

```cpp
std::map<std::string, int>newMap(myMap);
```

- 利用已有map容器中的部分键值对创建新的map容器

```cpp
std::map<std::string, int>myMap{ {"C语言教程",10},{"STL教程",20} };
std::map<std::string, int>newMap(++myMap.begin(), myMap.end());
```

- 在以上几种创建 map 容器的基础上，我们都可以手动修改 map 容器的排序规则。默认情况下，map 容器调用 std::less 规则，根据容器内各键值对的键的大小，对所有键值对做升序排序。

```cpp
//以下两行等价
std::map<std::string, int>myMap{ {"C语言教程",10},{"STL教程",20} };
std::map<std::string, int, std::less<std::string> >myMap{ {"C语言教程",10},{"STL教程",20} };
```

下面程序手动修改了 myMap 容器的排序规则，令其作降序排序：

```cpp
std::map<std::string, int, std::greater<std::string> >myMap{ {"C语言教程",10},{"STL教程",20} };
```



##### map-map容器常用成员方法

| 成员方法         | 功能                                                         |
| ---------------- | ------------------------------------------------------------ |
| **begin()**      | 返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| **end()**        | 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| rbegin()         | 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
| rend()           | 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
| cbegin()         | 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
| cend()           | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
| crbegin()        | 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
| crend()          | 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
| **find(key)**    | 在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| lower_bound(key) | 返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| upper_bound(key) | 返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| equal_range(key) | 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。 |
| **empty()**      | 若容器为空，则返回 true；否则 false。                        |
| **size()**       | 返回当前 map 容器中存有键值对的个数。                        |
| max_size()       | 返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。 |
| operator[]       | map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。 |
| **at(key)**      | 找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。 |
| **insert()**     | 向 map 容器中插入键值对。                                    |
| **erase()**      | 删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对。后续章节还会对该方法做重点讲解。 |
| **swap()**       | 交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。 |
| **clear()**      | 清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0。   |
| **emplace()**    | 在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。 |
| emplace_hint()   | 在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。 |
| **count(key)**   | 在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。 |

##### map-map获取键对应值

map 容器的类模板中提供了以下 2 种方法，可直接获取 map 容器指定键对应的值。

- map 类模板中对[ ]运算符进行了重载，这意味着，类似于借助数组下标可以直接访问数组中元素，通过指定的键，我们可以轻松获取 map 容器中该键对应的值。

> 注意，只有当 map 容器中确实存有包含该指定键的键值对，借助重载的 [ ] 运算符才能成功获取该键对应的值；反之，若当前 map 容器中没有包含该指定键的键值对，则此时使用 [ ] 运算符将不再是访问容器中的元素，而变成了向该 map 容器中增添一个键值对。

```cpp
	//创建并初始化 map 容器
	std::map<std::string, std::string>myMap{ {"STL教程","http://c.biancheng.net/stl/"},
                                             {"C语言教程","http://c.biancheng.net/c/"},
                                             {"Java教程","http://c.biancheng.net/java/"} };
    string cValue = myMap["C语言教程"];
    cout << cValue << endl;
```

- 除了借助 [ ] 运算符获取 map 容器中指定键对应的值，还可以使用 at() 成员方法。和前一种方法相比，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出 out_of_range 异常。

```cpp
	//创建并初始化 map 容器
    std::map<std::string, std::string>myMap{ {"STL教程","http://c.biancheng.net/stl/"},
                                             {"C语言教程","http://c.biancheng.net/c/"},
                                             {"Java教程","http://c.biancheng.net/java/"} };
    cout << myMap.at("C语言教程") << endl;
    //下面一行代码会引发 out_of_range 异常
    //cout << myMap.at("Python教程") << endl;
1234567
```

- 如果以上方法都不适用，我们还可以遍历整个 map 容器，找到包含指定键的键值对，进而获取该键对应的值。

```cpp
	//创建并初始化 map 容器
    std::map<std::string, std::string>myMap{ {"STL教程","http://c.biancheng.net/stl/"},
                                             {"C语言教程","http://c.biancheng.net/c/"},
                                             {"Java教程","http://c.biancheng.net/java/"} };
    for (auto iter = myMap.begin(); iter != myMap.end(); ++iter) {
        //调用 string 类的 compare() 方法，找到一个键和指定字符串相同的键值对
        if (!iter->first.compare("C语言教程")) {
            cout << iter->first << " " << iter->second << endl;
        }
    }
```

##### map-map insert()插入数据

1. 向map容器的指定位置插入新键值对

```cpp
//以普通引用的方式传递 val 参数
iterator insert (const_iterator position, const value_type& val);
//以右值引用的方式传递 val 键值对参数
template <class P>
    iterator insert (const_iterator position, P&& val);
```

其中 val 为要插入的键值对变量。注意，和第 1 种方式的语法格式不同，这里 insert() 方法返回的是迭代器，而不再是 pair 对象：

- 如果插入成功，insert() 方法会返回一个指向 map 容器中已插入键值对的迭代器；
- 如果插入失败，insert() 方法同样会返回一个迭代器，该迭代器指向 map 容器中和 val 具有相同键的那个键值对。

示例:

```cpp
	//创建一个空 map 容器
    std::map<string, string> mymap;
   
    //创建一个真实存在的键值对变量
    std::pair<string, string> STL = { "STL教程","http://c.biancheng.net/stl/" };
    //指定要插入的位置
    std::map<string, string>::iterator it = mymap.begin();
    //向 it 位置以普通引用的方式插入 STL
    auto iter1 = mymap.insert(it, STL);
    cout << iter1->first << " " << iter1->second << endl;
    //向 it 位置以右值引用的方式插入临时键值对
    auto iter2 = mymap.insert(it, std::pair<string, string>("C语言教程", "http://c.biancheng.net/c/"));
    cout << iter2->first << " " << iter2->second << endl;
    //插入失败样例
    auto iter3 = mymap.insert(it, std::pair<string, string>("STL教程", "http://c.biancheng.net/java/"));
```

1. 利用insert() 方法向当前 map 容器中插入其它 map 容器指定区域内的所有键值对

```cpp
template <class InputIterator>
  void insert (InputIterator first, InputIterator last);
```

其中 first 和 last 都是迭代器，它们的组合<first,last>可以表示某 map 容器中的指定区域。

示例:

```cpp
	//创建并初始化 map 容器
    std::map<std::string, std::string>mymap{ {"STL教程","http://c.biancheng.net/stl/"},
                                                {"C语言教程","http://c.biancheng.net/c/"},
                                                {"Java教程","http://c.biancheng.net/java/"} };
    //创建一个空 map 容器
    std::map<std::string, std::string>copymap;
    //指定插入区域
    std::map<string, string>::iterator first = ++mymap.begin();
    std::map<string, string>::iterator last = mymap.end();
    //将<first,last>区域内的键值对插入到 copymap 中
    copymap.insert(first, last);
1234567891011
```

1. 利用insert() 方法一次向 map 容器中插入多个键值对

```cpp
void insert ({val1, val2, ...});
```

其中，vali 都表示的是键值对变量。

示例:

```cpp
	//创建空的 map 容器
    std::map<std::string, std::string>mymap;
    //向 mymap 容器中添加 3 个键值对
    mymap.insert({ {"STL教程", "http://c.biancheng.net/stl/"},
                   { "C语言教程","http://c.biancheng.net/c/" },
                   { "Java教程","http://c.biancheng.net/java/" } });
```

1. emplace(函数)

- 实现相同的插入操作，无论是用 emplace() 还是 emplace_hont()，都比 insert() 方法的效率高.
- 和 insert() 方法相比，emplace() 和 emplace_hint() 方法的使用要简单很多，因为它们各自只有一种语法格式。

```cpp
template <class... Args>
  pair<iterator,bool> emplace (Args&&... args);
```

- 参数 (Args&&… args) 指的是，这里只需要将创建新键值对所需的数据作为参数直接传入即可，此方法可以自行利用这些数据构建出指定的键值对。
- 另外，该方法的返回值也是一个 pair 对象，其中 pair.first 为一个迭代器，pair.second 为一个 bool 类型变量：
  - 当该方法将键值对成功插入到 map 容器中时，其返回的迭代器指向该新插入的键值对，同时 bool 变量的值为 true；
  - 当插入失败时，则表明 map 容器中存在具有相同键的键值对，此时返回的迭代器指向此具有相同键的键值对，同时 bool 变量的值为 false。

示例:

```cpp
	//创建并初始化 map 容器
    std::map<string, string>mymap;
    //插入键值对
    pair<map<string, string>::iterator, bool> ret = mymap.emplace("STL教程", "http://c.biancheng.net/stl/");
    cout << "1、ret.iter = <{" << ret.first->first << ", " << ret.first->second << "}, " << ret.second << ">" << endl;
    //插入新键值对
    ret = mymap.emplace("C语言教程", "http://c.biancheng.net/c/");
    cout << "2、ret.iter = <{" << ret.first->first << ", " << ret.first->second << "}, " << ret.second << ">" << endl;
    //失败插入的样例
    ret = mymap.emplace("STL教程", "http://c.biancheng.net/java/");
    cout << "3、ret.iter = <{" << ret.first->first << ", " << ret.first->second << "}, " << ret.second << ">" << endl;
```

#### 3. multimap容器

multimap容器与map容器比较相似，multimap 容器也用于存储 pair<const K， T> 类型的键值对（其中 K 表示键的类型，T 表示值的类型），其中各个键值对的键的值不能做修改；并且，该容器也会自行根据键的大小对存储的所有键值对做排序操作。和 map 容器的区别在于，multimap 容器中可以同时存储多（≥2）个键相同的键值对。

##### multimap-使用前

和 map 容器一样，实现 multimap 容器的类模板也定义在头文件，并位于 std 命名空间中。因此，在使用 multimap 容器前，程序应包含如下代码：

```cpp
#include <map>
using namespace std;
```

##### multimap-创建与初始化

- 创建一个空的map容器

```cpp
std::multimap<std::string, int>mymultimap;
```

- 在创建map容器的同时进行初始化

```cpp
//创建并初始化 multimap 容器
multimap<string, string>mymultimap{ {"C语言教程", "http://c.biancheng.net/c/"},
                                    {"Python教程", "http://c.biancheng.net/python/"},
                                    {"STL教程", "http://c.biancheng.net/stl/"} };
```

- 利用已有的map容器创建新的map容器

```cpp
multimap<string, string>newmultimap(mymultimap);
```

- 利用已有map容器中的部分键值对创建新的map容器

```cpp
//创建并初始化 multimap 容器
multimap<string, string>mymultimap{ {"C语言教程", "http://c.biancheng.net/c/"},
                                    {"Python教程", "http://c.biancheng.net/python/"},
                                    {"STL教程", "http://c.biancheng.net/stl/"} };
multimap<string, string>newmultimap(++mymultimap.begin(), mymultimap.end());
```

- 在以上几种创建 map 容器的基础上，我们都可以手动修改 map 容器的排序规则。默认情况下，map 容器调用 std::less 规则，根据容器内各键值对的键的大小，对所有键值对做升序排序。

```cpp
//以下两行等价
multimap<char, int>mymultimap{ {'a',1},{'b',2} };
multimap<char, int, std::less<char>>mymultimap{ {'a',1},{'b',2} };
```

下面程序利用了 STL 模板库提供的std::greater排序函数，实现令 multimap 容器对存储的键值对做降序排序：

```cpp
multimap<char, int, std::greater<char>>mymultimap{ {'a',1},{'b',2} };
```



##### multimap-multimap 容器常用成员方法

|     成员方法     |                             功能                             |
| :--------------: | :----------------------------------------------------------: |
|   **begin()**    | 返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
|    **end()**     | 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
|     rbegin()     | 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
|      rend()      | 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
|     cbegin()     | 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
|      cend()      | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
|    crbegin()     | 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
|     crend()      | 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 |
|  **find(key)**   | 在 multimap 容器中查找首个键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| lower_bound(key) | 返回一个指向当前 multimap 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| upper_bound(key) | 返回一个指向当前 multimap 容器中第一个大于 key 的键值对的迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| equal_range(key) | 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对。 |
|   **empty()**    |            若容器为空，则返回 true；否则 false。             |
|    **size()**    |          返回当前 multimap 容器中存有键值对的个数。          |
|    max_size()    | 返回 multimap 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。 |
|   **insert()**   |                向 multimap 容器中插入键值对。                |
|   **erase()**    | 删除 multimap 容器指定位置、指定键（key）值或者指定区域内的键值对。 |
|      swap()      | 交换 2 个 multimap 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。 |
|   **clear()**    | 清空 multimap 容器中所有的键值对，使 multimap 容器的 size() 为 0。 |
|  **emplace()**   | 在当前 multimap 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。 |
|  emplace_hint()  | 在本质上和 emplace() 在 multimap 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。 |
|  **count(key)**  | 在当前 multimap 容器中，查找键为 key 的键值对的个数并返回。  |

#### 4. set

和 map、multimap 容器不同，使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。

##### set-使用前

值得一提的是，set 容器定义于`<set>`头文件，并位于 std 命名空间中。因此如果想在程序中使用 set 容器，该程序代码应先包含如下语句：

```cpp
#include <set>
using namespace std;
```

set 容器的类模板定义如下：

```cpp
template < class T,                        // 键 key 和值 value 的类型
           class Compare = less<T>,        // 指定 set 容器内部的排序规则
           class Alloc = allocator<T>      // 指定分配器对象的类型
           > class set;
```

注意，由于 set 容器存储的各个键值对，其键和值完全相同，也就意味着它们的类型相同，因此 set 容器类模板的定义中，仅有第 1 个参数用于设定存储数据的类型。

> 对于 set 类模板中的 3 个参数，后 2 个参数自带默认值，且几乎所有场景中只需使用前 2 个参数，第 3 个参数不会用到。

##### set-创建与初始化

- 创建空的set容器

```cpp
std::set<std::string> myset;
```

- 创建set容器的同时进行初始化

```cpp
std::set<std::string> myset{"http://c.biancheng.net/java/",
                            "http://c.biancheng.net/stl/",
                            "http://c.biancheng.net/python/"};
```

- 利用已有set容器创建新的set容器(拷贝)

```cpp
std::set<std::string> copyset(myset);
//等同于
//std::set<std::string> copyset = myset
```

- 利用已有set容器的部分元素创建新的set容器

```cpp
std::set<std::string> myset{ "http://c.biancheng.net/java/",
                    "http://c.biancheng.net/stl/",
                    "http://c.biancheng.net/python/" };
std::set<std::string> copyset(++myset.begin(), myset.end());
```

- 创建set容器的同时修改排序规则

```cpp
std::set<std::string,std::greater<string> > myset{
    "http://c.biancheng.net/java/",
    "http://c.biancheng.net/stl/",
    "http://c.biancheng.net/python/"};
```



##### set-set 容器常用成员方法

常用函数已加粗标出

|      成员方法      |                             功能                             |
| :----------------: | :----------------------------------------------------------: |
|    **begin()**     | 返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
|     **end()**      | 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
|      rbegin()      | 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
|       rend()       | 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
|      cbegin()      | 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 |
|       cend()       | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 |
|     crbegin()      | 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 |
|      crend()       | 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 |
|   **find(val)**    | 在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
|  lower_bound(val)  | 返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
|  upper_bound(val)  | 返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
|  equal_range(val)  | 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。 |
|    **empty()**     |            若容器为空，则返回 true；否则 false。             |
|     **size()**     |             返回当前 set 容器中存有元素的个数。              |
|     max_size()     | 返回 set 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。 |
|    **insert()**    |                   向 set 容器中插入元素。                    |
|    **erase()**     |                 删除 set 容器中存储的元素。                  |
|       swap()       | 交换 2 个 set 容器中存储的所有元素。这意味着，操作的 2 个 set 容器的类型必须相同。 |
|    **clear()**     |   清空 set 容器中所有的元素，即令 set 容器的 size() 为 0。   |
|   **emplace()**    | 在当前 set 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。 |
| **emplace_hint()** | 在本质上和 emplace() 在 set 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数 |
|   **count(val)**   | 在当前 set 容器中，查找值为 val 的元素的个数，并返回。注意，由于 set 容器中各元素的值是唯一的，因此该函数的返回值最大为 1。 |

> emplace()系列函数比inser()系列函数效率更高,具体原因呢这里不再展开,看参考之前的讨论

##### set-set迭代器

和 map 容器不同，C++ STL 中的 set 容器类模板中未提供 at() 成员函数，也未对 [] 运算符进行重载。因此，要想访问 set 容器中存储的元素，只能借助 set 容器的迭代器。

值得一提的是，C++ STL 标准库为 set 容器配置的迭代器类型为双向迭代器。这意味着，假设 p 为此类型的迭代器，则其只能进行 ++p、p++、–p、p–、*p 操作，并且 2 个双向迭代器之间做比较，也只能使用 == 或者 != 运算符。

##### set-insert()函数详解

1. 直接传值

```cpp
//普通引用方式传参
pair<iterator,bool> insert (const value_type& val);
//右值引用方式传参
pair<iterator,bool> insert (value_type&& val);
```

其中，val 表示要添加的新元素，该方法的返回值为 pair 类型。

> 以上 2 种格式的区别仅在于传递参数的方式不同，即第一种采用普通引用的方式传参，而第二种采用右值引用的方式传参。右值引用为 C++ 11 新添加的一种引用方式，可阅读《C++ 右值引用》一文做详细了解。

可以看到，以上 2 种语法格式的 insert() 方法，返回的都是 pair 类型的值，其包含 2 个数据，一个迭代器和一个 bool 值：

- 当向 set 容器添加元素成功时，该迭代器指向 set 容器新添加的元素，bool 类型的值为 true；
- 如果添加失败，即证明原 set 容器中已存有相同的元素，此时返回的迭代器就指向容器中相同的此元素，同时 bool 类型的值为 false。

示例:

```cpp
	//创建并初始化set容器
    std::set<std::string> myset;
    //准备接受 insert() 的返回值
    pair<set<string>::iterator, bool> retpair;
    //采用普通引用传值方式
    string str = "http://c.biancheng.net/stl/";
    retpair = myset.insert(str);
```

1. 将元素插入到指定位置

```cpp
//以普通引用的方式传递 val 值
iterator insert (const_iterator position, const value_type& val);
//以右值引用的方式传递 val 值
iterator insert (const_iterator position, value_type&& val);
```

以上 2 种语法格式中，insert() 函数的返回值为迭代器：

- 当向 set 容器添加元素成功时，该迭代器指向容器中新添加的元素；
- 当添加失败时，证明原 set 容器中已有相同的元素，该迭代器就指向 set 容器中相同的这个元素。

示例:

```cpp
//创建并初始化set容器
    std::set<std::string> myset;
    //准备接受 insert() 的返回值
    set<string>::iterator iter;
    //采用普通引用传值方式
    string str = "http://c.biancheng.net/stl/";
    iter = myset.insert(myset.begin(),str);
    //采用右值引用传值方式
    iter = myset.insert(myset.end(),"http://c.biancheng.net/python/");
```

1. 向当前set容器插入其他set容器指定区域内的所有元素(两个set容器存储的元素类型要一致)

```cpp
template <class InputIterator>
  void insert (InputIterator first, InputIterator last);
```

其中 first 和 last 都是迭代器，它们的组合 [first,last) 可以表示另一 set 容器中的一块区域，该区域包括 first 迭代器指向的元素，但不包含 last 迭代器指向的元素。

示例:

```cpp
	//创建并初始化set容器
    std::set<std::string> myset{ "http://c.biancheng.net/stl/",
                                "http://c.biancheng.net/python/",
                                "http://c.biancheng.net/java/" };
    //创建一个同类型的空 set 容器
    std::set<std::string> otherset;
    //利用 myset 初始化 otherset
    otherset.insert(++myset.begin(), myset.end());
```

1. 一次向set容器中添加多个元素

```cpp
void insert ( {E1, E2,...,En} );
```

其中，Ei 表示新添加的元素。

示例:

```cpp
	//创建并初始化set容器
    std::set<std::string> myset;
    //向 myset 中添加多个元素
    myset.insert({ "http://c.biancheng.net/stl/",
        "http://c.biancheng.net/python/",
        "http://c.biancheng.net/java/" });
```

##### set-set删除数据

如果想删除 set 容器存储的元素，可以选择用 erase() 或者 clear() 成员方法。

- set 类模板中，erase() 方法有 3 种语法格式，分别如下：

```cpp
//删除 set 容器中值为 val 的元素
size_type erase (const value_type& val);
//删除 position 迭代器指向的元素
iterator  erase (const_iterator position);
//删除 [first,last) 区间内的所有元素
iterator  erase (const_iterator first, const_iterator last);
```

其中，第 1 种格式的 erase() 方法，其返回值为一个整数，表示成功删除的元素个数；后 2 种格式的 erase() 方法，返回值都是迭代器，其指向的是 set 容器中删除元素之后的第一个元素。

> 注意，如果要删除的元素就是 set 容器最后一个元素，则 erase() 方法返回的迭代器就指向新 set 容器中最后一个元素之后的位置（等价于 end() 方法返回的迭代器）。

示例:

```cpp
	//创建并初始化 set 容器
    std::set<int>myset{1,2,3,4,5};
    cout << "myset size = " << myset.size() << endl;//5
   
    //1) 调用第一种格式的 erase() 方法
    int num = myset.erase(2); //删除元素 2，myset={1,3,4,5}
    cout << "1、myset size = " << myset.size() << endl;//4
    cout << "num = " << num << endl;//1
    //2) 调用第二种格式的 erase() 方法
    set<int>::iterator iter = myset.erase(myset.begin()); //删除元素 1，myset={3,4,5}
    cout << "2、myset size = " << myset.size() << endl;//3
    cout << "iter->" << *iter << endl;//3
    //3) 调用第三种格式的 erase() 方法
    set<int>::iterator iter2 = myset.erase(myset.begin(), --myset.end());//删除元素 3,4，myset={5}
    cout << "3、myset size = " << myset.size() << endl;//1
    cout << "iter2->" << *iter2 << endl;//5
```

- 如果需要删除 set 容器中存储的所有元素，可以使用 clear() 成员方法。该方法的语法格式如下：

```cpp
void clear();
```

示例:

```cpp
	//创建并初始化 set 容器
    std::set<int>myset{1,2,3,4,5};
    cout << "1、myset size = " << myset.size() << endl;//5
    //清空 myset 容器
    myset.clear();
    cout << "2、myset size = " << myset.size() << endl;//0
```

#### 5.multiset

##### multiset-使用前

和 set 类模板一样，multiset 类模板也定义在头文件，并位于 std 命名空间中。这意味着，如果想在程序中使用 multiset 容器，该程序代码应包含如下语句：

```cpp
#include <set>
using namespace std;
```

multiset 容器类模板的定义如下所示：

```cpp
template < class T,                        // 存储元素的类型
           class Compare = less<T>,        // 指定容器内部的排序规则
           class Alloc = allocator<T> >    // 指定分配器对象的类型
           > class multiset;
```

显然，multiset 类模板有 3 个参数，其中后 2 个参数自带有默认值。值得一提的是，在实际使用中，我们最多只需要使用前 2 个参数即可，第 3 个参数不会用到。

##### multiset-创建与初始化

- 创建空的multiset容器

```cpp
std::multiset<std::string> mymultiset;
```

- 创建容器的同时进行初始化

```cpp
std::multiset<std::string> mymultiset{ "http://c.biancheng.net/java/",
                                       "http://c.biancheng.net/stl/",
                                       "http://c.biancheng.net/python/" };
```

- 利用已有的multiset容器创建新的容器(拷贝)

```cpp
std::multiset<std::string> copymultiset(mymultiset);
//等同于
//std::multiset<std::string> copymultiset = mymultiset;
```

- 利用已有的multiset容器的部分元素创建新的容器

```cpp
std::multiset<std::string> mymultiset{ "http://c.biancheng.net/java/",
                                       "http://c.biancheng.net/stl/",
                                       "http://c.biancheng.net/python/" };
std::set<std::string> copymultiset(++mymultiset.begin(), mymultiset.end());
```

- 创建容器的同时修改排序规则

```cpp
std::multiset<std::string, std::greater<string> > mymultiset{
    "http://c.biancheng.net/java/",
    "http://c.biancheng.net/stl/",
    "http://c.biancheng.net/python/" };
```



##### multiset-multiset 容器常用成员方法

重要方法已加粗标出

|     成员方法     |                             功能                             |
| :--------------: | :----------------------------------------------------------: |
|   **begin()**    | 返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
|    **end()**     | 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
|     rbegin()     | 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
|      rend()      | 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 |
|     cbegin()     | 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 |
|      cend()      | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 |
|    crbegin()     | 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 |
|     crend()      | 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 |
|    find(val)     | 在 multiset 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| lower_bound(val) | 返回一个指向当前 multiset 容器中第一个大于或等于 val 的元素的双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| upper_bound(val) | 返回一个指向当前 multiset 容器中第一个大于 val 的元素的迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 |
| equal_range(val) | 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含所有值为 val 的元素。 |
|   **empty()**    |            若容器为空，则返回 true；否则 false。             |
|    **size()**    |           返回当前 multiset 容器中存有元素的个数。           |
|    max_size()    | 返回 multiset 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。 |
|   **insert()**   |                 向 multiset 容器中插入元素。                 |
|   **erase()**    |             删除 multiset 容器中存储的指定元素。             |
|      swap()      | 交换 2 个 multiset 容器中存储的所有元素。这意味着，操作的 2 个 multiset 容器的类型必须相同。 |
|   **clear()**    | 清空 multiset 容器中所有的元素，即令 multiset 容器的 size() 为 0。 |
|  **emplace()**   | 在当前 multiset 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。 |
|  emplace_hint()  | 本质上和 emplace() 在 multiset 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。 |
|  **count(val)**  | 在当前 multiset 容器中，查找值为 val 的元素的个数，并返回。  |

> 注意，虽然 multiset 容器和 set 容器拥有的成员方法完全相同，但由于 multiset 容器允许存储多个值相同的元素，因此诸如 count()、find()、lower_bound()、upper_bound()、equal_range()等方法，更常用于 multiset 容器。

### 1.3 无序关联式容器

和关联式容器一样，无序容器也使用键值对（pair 类型）的方式存储数据。不过，本教程将二者分开进行讲解，因为它们有本质上的不同：

- 关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；
- 无序容器的底层实现采用的是哈希表的存储结构。

> C++ STL 底层采用哈希表实现无序容器时，会将所有数据存储到一整块连续的内存空间中，并且当数据存储位置发生冲突时，解决方法选用的是“链地址法”（又称“开链法”）。

基于底层实现采用了不同的数据结构，因此和关联式容器相比，无序容器具有以下 2 个特点：

- 无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，
- 和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。

**无序容器种类**

| 无序容器           | 功能                                                         |
| ------------------ | ------------------------------------------------------------ |
| unordered_map      | 存储键值对 <key, value> 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。 |
| unordered_multimap | 和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。 |
| unordered_set      | 不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。 |
| unordered_multiset | 和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。 |

> 注意:以上 4 种无序容器的名称，仅是在前面所学的 4 种关联式容器名称的基础上，添加了 “unordered_”。如果读者已经学完了 map、multimap、set 和 multiset 容器不难发现，以 map 和 unordered_map 为例，其实它们仅有一个区别，即 map 容器内存会对存储的键值对进行排序，而 unordered_map 不会。
>
>
> 针对有序容器和无序容器的使用选择，总的来说，实际场景中如果涉及大量遍历容器的操作，建议首选关联式容器；反之，如果更多的操作是通过键获取对应的值，则应首选无序容器。

#### 1. unordered_map

##### unordered_map-使用前

unordered_map 容器在<unordered_map>头文件中，并位于 std 命名空间中。因此，如果想使用该容器，代码中应包含如下语句：

```cpp
#include <unordered_map>
using namespace std;
```

unordered_map 容器模板的定义如下所示：

```cpp
template < class Key,                        //键值对中键的类型
           class T,                          //键值对中值的类型
           class Hash = hash<Key>,           //容器内部存储键值对所用的哈希函数
           class Pred = equal_to<Key>,       //判断各个键值对键相同的规则
           class Alloc = allocator< pair<const Key,T> >  // 指定分配器对象的类型
           > class unordered_map;
```

以上 5 个参数中，必须显式给前 2 个参数传值，并且除特殊情况外，最多只需要使用前 4 个参数，各自的含义和功能如表 1 所示。

##### unordered_map - 创建与初始化

- 创建一个空的unordered_map容器

```cpp
std::unordered_map<std::string, int>umap;
```

- 在创建unordered_map容器的同时进行初始化

```cpp
std::unordered_map<std::string, int>umap{ {"C语言教程",10},{"STL教程",20} };
```

- 利用已有的unordered_map容器创建新的map容器

```cpp
std::unordered_map<std::string, int>umap2(umap);
```

- 利用已有map容器中的部分键值对创建新的map容器

```cpp
std::unordered_map<std::string, int>umap{ {"C语言教程",10},{"STL教程",20} };
std::unordered_map<std::string, int>umap2(++umap.begin(), umap.end());
```



##### unordered_map - unordered_map类模板成员方法

unordered_map类模板成员方法

|      成员方法      |                             功能                             |
| :----------------: | :----------------------------------------------------------: |
|    **begin()**     |           返回指向容器中第一个键值对的正向迭代器。           |
|     **end()**      |      返回指向容器中最后一个键值对之后位置的正向迭代器。      |
|      cbegin()      | 和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。 |
|       cend()       | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。 |
|    **empty()**     |            若容器为空，则返回 true；否则 false。             |
|     **size()**     |               返回当前容器中存有键值对的个数。               |
|     max_size()     | 返回容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。 |
|   operator[key]    | 该模板类中重载了 [] 运算符，其功能是可以向访问数组中元素那样，只要给定某个键值对的键 key，就可以获取该键对应的值。注意，如果当前容器中没有以 key 为键的键值对，则其会使用该键向当前容器中插入一个新键值对。 |
|    **at(key)**     | 返回容器中存储的键 key 对应的值，如果 key 不存在，则会抛出 out_of_range 异常。 |
|   **find(key)**    | 查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。 |
|   **count(key)**   |            在容器中查找以 key 键的键值对的个数。             |
|  equal_range(key)  | 返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。 |
|   **emplace()**    |        向容器中添加新键值对，效率比 insert() 方法高。        |
|   emplace_hint()   |        向容器中添加新键值对，效率比 insert() 方法高。        |
|    **insert()**    |                    向容器中添加新键值对。                    |
|    **erase()**     |                       删除指定键值对。                       |
|    **clear()**     |           清空容器，即删除容器中存储的所有键值对。           |
|       swap()       | 交换 2 个 unordered_map 容器存储的键值对，前提是必须保证这 2 个容器的类型完全相等。 |
|   bucket_count()   | 返回当前容器底层存储键值对时，使用桶（一个线性链表代表一个桶）的数量。 |
| max_bucket_count() |  返回当前系统中，unordered_map 容器底层最多可以使用多少桶。  |
| **bucket_size(n)** |              返回第 n 个桶中存储键值对的数量。               |
|  **bucket(key)**   |            返回以 key 为键的键值对所在桶的编号。             |
|   load_factor()    | 返回 unordered_map 容器中当前的负载因子。负载因子，指的是的当前容器中存储键值对的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。 |
| max_load_factor()  |       返回或者设置当前 unordered_map 容器的负载因子。        |
|     rehash(n)      |             将当前容器底层使用桶的数量设置为 n。             |
|     reserve()      | 将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。 |
|  hash_function()   |               返回当前容器使用的哈希函数对象。               |

##### unordered_map - unordered_map获取元素

- 使用重载运算符[ ]

```cpp
	unordered_map<string, string> umap{
        {"Python教程","http://c.biancheng.net/python/"},
        {"Java教程","http://c.biancheng.net/java/"},
        {"Linux教程","http://c.biancheng.net/linux/"} };
    //获取 "Java教程" 对应的值
    string str = umap["Java教程"];
    cout << str << endl;
```

> 注意:若当前容器中并没有存储以 [ ] 运算符内指定的元素作为键的键值对，则此时 [ ] 运算符的功能将转变为：向当前容器中添加以目标元素为键的键值对。

- 使用at函数

```cpp
 	unordered_map<string, string> umap{
        {"Python教程","http://c.biancheng.net/python/"},
        {"Java教程","http://c.biancheng.net/java/"},
        {"Linux教程","http://c.biancheng.net/linux/"} };
    //获取指定键对应的值
    string str = umap.at("Python教程");
    cout << str << endl;
```

> 注意:和使用 [ ] 运算符一样，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出out_of_range异常。

- 使用find()函数

```cpp
	//创建 umap 容器
    unordered_map<string, string> umap{
        {"Python教程","http://c.biancheng.net/python/"},
        {"Java教程","http://c.biancheng.net/java/"},
        {"Linux教程","http://c.biancheng.net/linux/"} };
    //查找成功
    unordered_map<string, string>::iterator iter = umap.find("Python教程");
    cout << iter->first << " " << iter->second << endl;
    //查找失败
    unordered_map<string, string>::iterator iter2 = umap.find("GO教程");
    if (iter2 == umap.end()) {
        cout << "当前容器中没有以\"GO教程\"为键的键值对";
    }
```

> 通过 find() 方法得到的是一个正向迭代器，该迭代器的指向分以下 2 种情况：
>
> - 当 find() 方法成功找到以指定元素作为键的键值对时，其返回的迭代器就指向该键值对；
> - 当 find() 方法查找失败时，其返回的迭代器和 end() 方法返回的迭代器一样，指向容器中最后一个键值对之后的位置。

- 通过迭代器遍历整个容器

```cpp
	//创建 umap 容器
    unordered_map<string, string> umap{
        {"Python教程","http://c.biancheng.net/python/"},
        {"Java教程","http://c.biancheng.net/java/"},
        {"Linux教程","http://c.biancheng.net/linux/"} };
    //遍历整个容器中存储的键值对
    for (auto iter = umap.begin(); iter != umap.end(); ++iter) {
        //判断当前的键值对是否就是要找的
        if (!iter->first.compare("Java教程")) {
            cout << iter->second << endl;
            break;
        }
    }
```

##### unordered_map -insert()

1. insert() 方法可以将 pair 类型的键值对元素添加到 unordered_map 容器中

```cpp
//以普通方式传递参数
pair<iterator,bool> insert ( const value_type& val );
//以右值引用的方式传递参数
template <class P>
    pair<iterator,bool> insert ( P&& val );
```

参数 val 表示要添加到容器中的目标键值对元素；该方法的返回值为 pair类型值，内部包含一个 iterator 迭代器和 bool 变量：

- 当 insert() 将 val 成功添加到容器中时，返回的迭代器指向新添加的键值对，bool 值为 True；
  当 insert() 添加键值对失败时，意味着当前容器中本就存储有和要添加键值对的键相等的键值对，这种情况下，返回的迭代器将指向这个导致插入操作失败的迭代器，bool 值为 False。

示例:

```cpp
	//创建一个空 map 容器
    std::map<string, string> mymap;
   
    //创建一个真实存在的键值对变量
    std::pair<string, string> STL = { "STL教程","http://c.biancheng.net/stl/" };
    //指定要插入的位置
    std::map<string, string>::iterator it = mymap.begin();
    //向 it 位置以普通引用的方式插入 STL
    auto iter1 = mymap.insert(it, STL);
    cout << iter1->first << " " << iter1->second << endl;
    //向 it 位置以右值引用的方式插入临时键值对
    auto iter2 = mymap.insert(it, std::pair<string, string>("C语言教程", "http://c.biancheng.net/c/"));
    cout << iter2->first << " " << iter2->second << endl;
    //插入失败样例
    auto iter3 = mymap.insert(it, std::pair<string, string>("STL教程", "http://c.biancheng.net/java/"));
```

1. insert() 方法还可以指定新键值对要添加到容器中的位置

```cpp
//以普通方式传递 val 参数
iterator insert ( const_iterator hint, const value_type& val );
//以右值引用方法传递 val 参数
template <class P>
    iterator insert ( const_iterator hint, P&& val );
```

其中 first 和 last 都是迭代器，它们的组合<first,last>可以表示某 map 容器中的指定区域。

示例:

```cpp
	//创建空 umap 容器
    unordered_map<string, string> umap;
    //构建要添加的键值对
    std::pair<string, string>mypair("STL教程", "http://c.biancheng.net/stl/");
    //创建接收 insert() 方法返回值的迭代器类型变量
    unordered_map<string, string>::iterator iter;
    //调用第一种语法格式
    iter = umap.insert(umap.begin(), mypair);
   
    //调用第二种语法格式
    iter = umap.insert(umap.begin(),std::make_pair("Python教程", "http://c.biancheng.net/python/"));
```

1. insert() 方法还支持将某一个 unordered_map 容器中指定区域内的所有键值对，复制到另一个 unordered_map 容器中

```cpp
void insert ({val1, val2, ...});
```

其中，vali 都表示的是键值对变量。

示例:

```cpp
	//创建空的 map 容器
    std::map<std::string, std::string>mymap;
    //向 mymap 容器中添加 3 个键值对
    mymap.insert({ {"STL教程", "http://c.biancheng.net/stl/"},
                   { "C语言教程","http://c.biancheng.net/c/" },
                   { "Java教程","http://c.biancheng.net/java/" } });
```

1. insert() 方法还支持一次向 unordered_map 容器添加多个键值对，其语法格式如下：

```cpp
void insert ( initializer_list<value_type> il );
```

- 参数 (Args&&… args) 指的是，这里只需要将创建新键值对所需的数据作为参数直接传入即可，此方法可以自行利用这些数据构建出指定的键值对。
- 另外，该方法的返回值也是一个 pair 对象，其中 pair.first 为一个迭代器，pair.second 为一个 bool 类型变量：
  - 当该方法将键值对成功插入到 map 容器中时，其返回的迭代器指向该新插入的键值对，同时 bool 变量的值为 true；
  - 当插入失败时，则表明 map 容器中存在具有相同键的键值对，此时返回的迭代器指向此具有相同键的键值对，同时 bool 变量的值为 false。

示例:

```cpp
	//创建空的 umap 容器
    unordered_map<string, string> umap;
    //向 umap 容器同时添加多个键值对
    umap.insert({ {"STL教程","http://c.biancheng.net/stl/"},
    {"Python教程","http://c.biancheng.net/python/"},
    {"Java教程","http://c.biancheng.net/java/"} });
```

##### unordered_map-unordered_map删除元素

C++ STL 标准库为了方便用户可以随时删除 unordered_map 容器中存储的键值对，unordered_map 容器类模板中提供了以下 2 个成员方法：

- erase()：删除 unordered_map 容器中指定的键值对；
- clear()：删除 unordered_map 容器中所有的键值对，即清空容器。

1. erase()函数

- erase() 方法可以接受一个正向迭代器，并删除该迭代器指向的键值对。该方法的语法格式如下

```cpp
iterator erase ( const_iterator position );
```

示例:

```cpp
cout << "erase:" << endl;
    //定义一个接收 erase() 方法的迭代器
    unordered_map<string,string>::iterator ret;
    //删除容器中第一个键值对
    ret = umap.erase(umap.begin());
```

- 我们还可以直接将要删除键值对的键作为参数直接传给 erase() 方法，该方法会自行去 unordered_map 容器中找和给定键相同的键值对，将其删除。

```cpp
size_type erase ( const key_type& k );
```

```cpp
int delNum = umap.erase("Python教程");
```

- 除了支持删除 unordered_map 容器中指定的某个键值对，erase() 方法还支持一次删除指定范围内的所有键值对

```cpp
iterator erase ( const_iterator first, const_iterator last );
```

```cpp
	//创建 umap 容器
    unordered_map<string, string> umap{
        {"STL教程", "http://c.biancheng.net/stl/"},
        {"Python教程", "http://c.biancheng.net/python/"},
        {"Java教程", "http://c.biancheng.net/java/"} };
    //first 指向第一个键值对
    unordered_map<string, string>::iterator first = umap.begin();
    //last 指向最后一个键值对
    unordered_map<string, string>::iterator last = --umap.end();
    //删除[fist,last)范围内的键值对
    auto ret = umap.erase(first, last);
```

#### 2. unordered_multimap

##### unordered_multimap-使用前

STL 标准库中实现 unordered_multimap 容器的模板类并没有定义在以自己名称命名的头文件中，而是和 unordered_map 容器一样，定义在<unordered_map>头文件，且位于 std 命名空间中。因此，在使用 unordered_multimap 容器之前，程序中应包含如下 2 行代码：

```cpp
#include <unordered_map>
using namespace std;
```

unordered_multimap 容器模板的定义如下所示：

```cpp
template < class Key,      //键（key）的类型
           class T,        //值（value）的类型
           class Hash = hash<Key>,  //底层存储键值对时采用的哈希函数
           class Pred = equal_to<Key>,  //判断各个键值对的键相等的规则
           class Alloc = allocator< pair<const Key,T> > // 指定分配器对象的类型
           > class unordered_multimap;
```

以上 5 个参数中，必须显式给前 2 个参数传值，且除极个别的情况外，最多只使用前 4 个参数

##### unordered_multimap-创建与初始化

- 创建一个空的unordered_multimap容器

```cpp
std::unordered_multimap<std::string, int>myummap;
```

- 在创建unordered_multimap容器的同时进行初始化

```cpp
std::unordered_multimap<std::string, int>umap{ {"C语言教程",10},{"STL教程",20} };
```

- 利用已有的unordered_multimap容器创建新的map容器

```cpp
std::unordered_map<std::string, int>myummap2(myummap);
```

- 利用已有unordered_multimap容器中的部分键值对创建新的map容器

```cpp
std::unordered_multimap<std::string, int>myummap{ {"C语言教程",10},{"STL教程",20} };
std::unordered_multimap<std::string, int>myummap2(++myummap.begin(), umap.end());
```

##### unordered_multimap类模板成员方法

| 成员方法           | 功能                                                         |
| ------------------ | ------------------------------------------------------------ |
| begin()            | 返回指向容器中第一个键值对的正向迭代器。                     |
| end()              | 返回指向容器中最后一个键值对之后位置的正向迭代器。           |
| cbegin()           | 和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。 |
| cend()             | 和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。 |
| empty()            | 若容器为空，则返回 true；否则 false。                        |
| size()             | 返回当前容器中存有键值对的个数。                             |
| max_size()         | 返回容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。 |
| find(key)          | 查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。 |
| count(key)         | 在容器中查找以 key 键的键值对的个数。                        |
| equal_range(key)   | 返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。 |
| emplace()          | 向容器中添加新键值对，效率比 insert() 方法高。               |
| emplace_hint()     | 向容器中添加新键值对，效率比 insert() 方法高。               |
| insert()           | 向容器中添加新键值对。                                       |
| erase()            | 删除指定键值对。                                             |
| clear()            | 清空容器，即删除容器中存储的所有键值对。                     |
| swap()             | 交换 2 个 unordered_multimap 容器存储的键值对，前提是必须保证这 2 个容器的类型完全相等。 |
| bucket_count()     | 返回当前容器底层存储键值对时，使用桶（一个线性链表代表一个桶）的数量。 |
| max_bucket_count() | 返回当前系统中，unordered_multimap 容器底层最多可以使用多少桶。 |
| bucket_size(n)     | 返回第 n 个桶中存储键值对的数量。                            |
| bucket(key)        | 返回以 key 为键的键值对所在桶的编号。                        |
| load_factor()      | 返回 unordered_multimap 容器中当前的负载因子。负载因子，指的是的当前容器中存储键值对的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。 |
| max_load_factor()  | 返回或者设置当前 unordered_multimap 容器的负载因子。         |
| rehash(n)          | 将当前容器底层使用桶的数量设置为 n。                         |
| reserve()          | 将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。 |
| hash_function()    | 返回当前容器使用的哈希函数对象。                             |

#### 3. unordered_set

##### unordered_set-使用前

实现 unordered_set 容器的模板类定义在<unordered_set>头文件，并位于 std 命名空间中。这意味着，如果程序中需要使用该类型容器，则首先应该包含如下代码：

```cpp
#include <unordered_set>
using namespace std;
```

unordered_set 容器的类模板定义如下：

```cpp
template < class Key,            //容器中存储元素的类型
           class Hash = hash<Key>,    //确定元素存储位置所用的哈希函数
           class Pred = equal_to<Key>,   //判断各个元素是否相等所用的函数
           class Alloc = allocator<Key>   //指定分配器对象的类型
           > class unordered_set;
```

可以看到，以上 4 个参数中，只有第一个参数没有默认值，这意味着如果我们想创建一个 unordered_set 容器，至少需要手动传递 1 个参数。事实上，在 99% 的实际场景中最多只需要使用前 3 个参数（各自含义如表 1 所示），最后一个参数保持默认值即可。

##### unordered_set-创建与初始化

- 创建一个空的unordered_set 容器

```cpp
std::unordered_set<std::string> uset;
```

- 在创建unordered_set 容器的同时进行初始化

```cpp
    std::unordered_set<std::string> uset{ "http://c.biancheng.net/c/",
                                          "http://c.biancheng.net/java/",
                                          "http://c.biancheng.net/linux/" };
```

- 利用已有的unordered_set 容器创建新的unordered_set 容器

```cpp
std::unordered_set<std::string> uset2(uset);
```

- 利用已有unordered_set 容器中的部分键值对创建新的unordered_set 容器

```cpp
    //传入 2 个迭代器，
    std::unordered_set<std::string> uset2(++uset.begin(),uset.end());
```



##### unordered_set - unordered_set 类模板成员方法

| 成员方法           | 功能                                                         |
| ------------------ | ------------------------------------------------------------ |
| begin()            | 返回指向容器中第一个元素的正向迭代器。                       |
| end();             | 返回指向容器中最后一个元素之后位置的正向迭代器。             |
| cbegin()           | 和 begin() 功能相同，只不过其返回的是 const 类型的正向迭代器。 |
| cend()             | 和 end() 功能相同，只不过其返回的是 const 类型的正向迭代器。 |
| empty()            | 若容器为空，则返回 true；否则 false。                        |
| size()             | 返回当前容器中存有元素的个数。                               |
| max_size()         | 返回容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。 |
| find(key)          | 查找以值为 key 的元素，如果找到，则返回一个指向该元素的正向迭代器；反之，则返回一个指向容器中最后一个元素之后位置的迭代器（如果 end() 方法返回的迭代器）。 |
| count(key)         | 在容器中查找值为 key 的元素的个数。                          |
| equal_range(key)   | 返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中值为 key 的元素所在的范围。 |
| emplace()          | 向容器中添加新元素，效率比 insert() 方法高。                 |
| emplace_hint()     | 向容器中添加新元素，效率比 insert() 方法高。                 |
| insert()           | 向容器中添加新元素。                                         |
| erase()            | 删除指定元素。                                               |
| clear()            | 清空容器，即删除容器中存储的所有元素。                       |
| swap()             | 交换 2 个 unordered_map 容器存储的元素，前提是必须保证这 2 个容器的类型完全相等。 |
| bucket_count()     | 返回当前容器底层存储元素时，使用桶（一个线性链表代表一个桶）的数量。 |
| max_bucket_count() | 返回当前系统中，unordered_map 容器底层最多可以使用多少桶。   |
| bucket_size(n)     | 返回第 n 个桶中存储元素的数量。                              |
| bucket(key)        | 返回值为 key 的元素所在桶的编号。                            |
| load_factor()      | 返回 unordered_map 容器中当前的负载因子。负载因子，指的是的当前容器中存储元素的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。 |
| max_load_factor()  | 返回或者设置当前 unordered_map 容器的负载因子。              |
| rehash(n)          | 将当前容器底层使用桶的数量设置为 n。                         |
| reserve()          | 将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。 |
| hash_function()    | 返回当前容器使用的哈希函数对象。                             |

#### 4. unordered_multiset

##### unordered_multiset-使用前

实现 unordered_multiset 容器的模板类并没有定义在以该容器名命名的文件中，而是和 unordered_set 容器共用同一个<unordered_set>头文件，并且也位于 std 命名空间。因此，如果程序中需要使用该类型容器，应包含如下代码：

\#include <unordered_set>
using namespace std;

unordered_multiset 容器类模板的定义如下：

纯文本复制

```cpp
template < class Key,            //容器中存储元素的类型
           class Hash = hash<Key>,    //确定元素存储位置所用的哈希函数
           class Pred = equal_to<Key>,   //判断各个元素是否相等所用的函数
           class Alloc = allocator<Key>   //指定分配器对象的类型
           > class unordered_multiset;
```

> 需要说明的是，在 99% 的实际场景中，最多只需要使用前 3 个参数（各自含义如表 1 所示），最后一个参数保持默认值即可。

##### unordered_multiset-创建与初始化

- 创建一个空的unordered_multiset 容器

```cpp
    std::unordered_multiset<std::string> umset;
```

- 在创建unordered_multiset 容器的同时进行初始化

```cpp
    std::unordered_multiset<std::string> umset{ "http://c.biancheng.net/c/",
                                                "http://c.biancheng.net/java/",
                                                "http://c.biancheng.net/linux/" };
```

- 利用已有的unordered_multiset 容器创建新的unordered_multiset 容器

```cpp
std::unordered_multiset<std::string> umset2(umset);
```

- 利用已有unordered_set 容器中的部分键值对创建新的unordered_set 容器

```cpp
        //传入 2 个迭代器，
    std::unordered_multiset<std::string> umset2(++umset.begin(), umset.end());
```



##### unordered_set 类模板成员方法

| 成员方法           | 功能                                                         |
| ------------------ | ------------------------------------------------------------ |
| begin()            | 返回指向容器中第一个元素的正向迭代器。                       |
| end();             | 返回指向容器中最后一个元素之后位置的正向迭代器。             |
| cbegin()           | 和 begin() 功能相同，只不过其返回的是 const 类型的正向迭代器。 |
| cend()             | 和 end() 功能相同，只不过其返回的是 const 类型的正向迭代器。 |
| empty()            | 若容器为空，则返回 true；否则 false。                        |
| size()             | 返回当前容器中存有元素的个数。                               |
| max_size()         | 返回容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。 |
| find(key)          | 查找以值为 key 的元素，如果找到，则返回一个指向该元素的正向迭代器；反之，则返回一个指向容器中最后一个元素之后位置的迭代器（如果 end() 方法返回的迭代器）。 |
| count(key)         | 在容器中查找值为 key 的元素的个数。                          |
| equal_range(key)   | 返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中值为 key 的元素所在的范围。 |
| emplace()          | 向容器中添加新元素，效率比 insert() 方法高。                 |
| emplace_hint()     | 向容器中添加新元素，效率比 insert() 方法高。                 |
| insert()           | 向容器中添加新元素。                                         |
| erase()            | 删除指定元素。                                               |
| clear()            | 清空容器，即删除容器中存储的所有元素。                       |
| swap()             | 交换 2 个 unordered_multimap 容器存储的元素，前提是必须保证这 2 个容器的类型完全相等。 |
| bucket_count()     | 返回当前容器底层存储元素时，使用桶（一个线性链表代表一个桶）的数量。 |
| max_bucket_count() | 返回当前系统中，容器底层最多可以使用多少桶。                 |
| bucket_size(n)     | 返回第 n 个桶中存储元素的数量。                              |
| bucket(key)        | 返回值为 key 的元素所在桶的编号。                            |
| load_factor()      | 返回容器当前的负载因子。所谓负载因子，指的是的当前容器中存储元素的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。 |
| max_load_factor()  | 返回或者设置当前 unordered_map 容器的负载因子。              |
| rehash(n)          | 将当前容器底层使用桶的数量设置为 n。                         |
| reserve()          | 将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。 |
| hash_function()    | 返回当前容器使用的哈希函数对象。                             |

### 1.4 其他

#### 1.String

##### String - 创建与初始化

- 构造

```cpp
	string strs ;//生成空字符串
    string s(str);//生成字符串str的复制品
    string s(str, stridx) ; //将字符串str中始于stridx的部分作为构造函数的初值
    string s(str, strbegin, strlen); //将字符串str中始于strbegin、长度为strlen的部分作为字符串初值
    string s(cstr);//以C_string类型cstr作为字符串s的初值
    string s(cstr,char_len);//以C_string类型cstr的前char_len个字符串作为字符串s的初值
    string s(num, c);//生成一个字符串，包含num个c字符
    string s(strs, beg, end) ;//以区间[beg, end]内的字符作为字符串s的初值
```

- 析构

```cpp
 ~string() ;    //销毁所有内存，释放内存
```



##### String - string 类的所有成员函数

| 函数名称                          | 功能                         |
| --------------------------------- | ---------------------------- |
| 构造函数                          | 产生或复制字符串             |
| 析构函数                          | 销毁字符串                   |
| =，assign                         | 赋以新值                     |
| Swap                              | 交换两个字符串的内容         |
| + =，append( )，push_back()       | 添加字符                     |
| insert ()                         | 插入字符                     |
| erase()                           | 删除字符                     |
| clear ()                          | 移除全部字符                 |
| resize ()                         | 改变字符数量                 |
| replace()                         | 替换字符                     |
| +                                 | 串联字符串                   |
| ==，！ =，<，<=，>，>=，compare() | 比较字符串内容               |
| size()，length()                  | 返回字符数量                 |
| max_size ()                       | 返回字符的最大可能个数       |
| empty ()                          | 判断字符串是否为空           |
| capacity ()                       | 返回重新分配之前的字符容量   |
| reserve()                         | 保留内存以存储一定数量的字符 |
| [],at()                           | 存取单一字符                 |
| >>，getline()                     | 从 stream 中读取某值         |
| <<                                | 将值写入 stream              |
| copy()                            | 将内容复制为一个 C - string  |
| c_str()                           | 将内容以 C - string 形式返回 |
| data()                            | 将内容以字符数组形式返回     |
| substr()                          | 返回子字符串                 |
| find()                            | 搜寻某子字符串或字符         |
| begin( )，end()                   | 提供正向迭代器支持           |
| rbegin()，rend()                  | 提供逆向迭代器支持           |
| get_allocator()                   | 返回配置器                   |

#### 2.栈

##### 栈-使用前

由于 stack 适配器以模板类 stack<T,Container=deque>（其中 T 为存储元素的类型，Container 表示底层容器的类型）的形式位于头文件中，并定义在 std 命名空间里。因此，在创建该容器之前，程序中应包含以下 2 行代码：

```cpp
#include <stack>
using namespace std;
```

##### 栈-创建与初始化

- 创建一个不包含任何元素的 stack 适配器，并采用默认的 deque 基础容器

```cpp
std::stack<int> values;
```

- stack<T,Container=deque> 模板类提供了 2 个参数，通过指定第二个模板类型参数，我们可以使用出 deque 容器外的其它序列式容器，只要该容器支持 empty()、size()、back()、push_back()、pop_back() 这 5 个成员函数即可。

```cpp
std::stack<std::string, std::list<int>> values;
```

- 可以用一个基础容器来初始化 stack 适配器，只要该容器的类型和 stack 底层使用的基础容器类型相同即可。

```cpp
std::list<int> values {1, 2, 3};
std::stack<int,std::list<int>> my_stack (values);
```

- 可以用一个 stack 适配器来初始化另一个 stack 适配器，只要它们存储的元素类型以及底层采用的基础容器类型相同即可。

```cpp
std::list<int> values{ 1, 2, 3 };
std::stack<int, std::list<int>> my_stack1(values);
std::stack<int, std::list<int>> my_stack=my_stack1;
//std::stack<int, std::list<int>> my_stack(my_stack1);
```

##### 栈-常用函数

stack容器适配器支持的成员函数

| 成员函数                  | 功能                                                         |
| ------------------------- | ------------------------------------------------------------ |
| empty()                   | 当 stack 栈中没有元素时，该成员函数返回 true；反之，返回 false。 |
| size()                    | 返回 stack 栈中存储元素的个数。                              |
| top()                     | 返回一个栈顶元素的引用，类型为 T&。如果栈为空，程序会报错。  |
| push(const T& val)        | 先复制 val，再将 val 副本压入栈顶。这是通过调用底层容器的    |
| push(T&& obj)             | 以移动元素的方式将其压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。 |
| pop()                     | 弹出栈顶元素。                                               |
| emplace(arg…)             | arg… 可以是一个参数，也可以是多个参数，但它们都只用于构造一个对象，并在栈顶直接生成该对象，作为新的栈顶元素。 |
| swap(stack & other_stack) | 将两个 stack 适配器中的元素进行互换，需要注意的是，进行互换的 2 个 stack 适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。 |

#### 3.queue

##### queue- 使用前

queue 容器适配器以模板类 queue<T,Container=deque>（其中 T 为存储元素的类型，Container 表示底层容器的类型）的形式位于头文件中，并定义在 std 命名空间里。因此，在创建该容器之前，程序中应包含以下 2 行代码：

```cpp
#include <queue>
using namespace std;
```

##### queue-创建与初始化

- 创建一个空的 queue 容器适配器，其底层使用的基础容器选择默认的 deque 容器

```cpp
std::queue<int> values;
```

- 手动指定 queue 容器适配器底层采用的基础容器类型

> 作为 queue 容器适配器的基础容器，其必须提供 front()、back()、push_back()、pop_front()、empty() 和 size() 这几个成员函数，符合条件的序列式容器仅有 deque 和 list。

- 可以用基础容器来初始化 queue 容器适配器，只要该容器类型和 queue 底层使用的基础容器类型相同即可。

```cpp
std::deque<int> values{1,2,3};
std::queue<int> my_queue(values);
```

- 可以直接通过 queue 容器适配器来初始化另一个 queue 容器适配器，只要它们存储的元素类型以及底层采用的基础容器类型相同即可。

```cpp
std::deque<int> values{1,2,3};
std::queue<int> my_queue1(values);
std::queue<int> my_queue(my_queue1);
//或者使用
//std::queue<int> my_queue = my_queue1;
```

##### queue-queue容器适配器支持的成员函数

|         成员函数         |                             功能                             |
| :----------------------: | :----------------------------------------------------------: |
|         empty()          |            如果 queue 中没有元素的话，返回 true。            |
|          size()          |                  返回 queue 中元素的个数。                   |
|         front()          | 返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 |
|          back()          | 返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 |
|    push(const T& obj)    | 在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。 |
|        emplace()         |              在 queue 的尾部直接添加一个元素。               |
|      push(T&& obj)       | 以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。 |
|          pop()           |                 删除 queue 中的第一个元素。                  |
| swap(queue &other_queue) | 将两个 queue 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 queue 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。 |

#### 4.priority_queue（优先队列）

priority_queue 容器适配器模拟的也是队列这种存储结构，即使用此容器适配器存储元素只能“从一端进（称为队尾），从另一端出（称为队头）”，且每次只能访问 priority_queue 中位于队头的元素。

但是，priority_queue 容器适配器中元素的存和取，遵循的并不是 “First in,First out”（先入先出）原则，而是“First in，Largest out”原则。直白的翻译，指的就是先进队列的元素并不一定先出队列，而是优先级最大的元素最先出队列。

##### priority_queue-使用前

由于 priority_queue 容器适配器模板位于头文件中，并定义在 std 命名空间里，因此在试图创建该类型容器之前，程序中需包含以下 2 行代码：

```cpp
#include <queue>
using namespace std;
```

##### priority_queue-创建与初始化

- 创建一个空的 priority_queue 容器适配器，第底层采用默认的 vector 容器，排序方式也采用默认的 std::less 方法

```cpp
std::priority_queue<int> values;
```

- 可以使用普通数组或其它容器中指定范围内的数据，对 priority_queue 容器适配器进行初始化

```cpp
//使用普通数组
int values[]{4,1,3,2};
std::priority_queue<int>copy_values(values,values+4);//{4,2,3,1}
//使用序列式容器
std::array<int,4>values{ 4,1,3,2 };
std::priority_queue<int>copy_values(values.begin(),values.end());//{4,2,3,1}
```

- 可以手动指定 priority_queue 使用的底层容器以及排序规则

```cpp
int values[]{ 4,1,2,3 };
std::priority_queue<int, std::deque<int>, std::greater<int> >copy_values(values, values+4);//{1,3,2,4}
```

##### priority_queue-常用函数

priority_queue 提供的成员函数

|          成员函数           |                             功能                             |
| :-------------------------: | :----------------------------------------------------------: |
|           empty()           | 如果 priority_queue 为空的话，返回 true；反之，返回 false。  |
|           size()            |            返回 priority_queue 中存储元素的个数。            |
|            top()            |         返回 priority_queue 中第一个元素的引用形式。         |
|     push(const T& obj)      | 根据既定的排序规则，将元素 obj 的副本存储到 priority_queue 中适当的位置。 |
|        push(T&& obj)        | 根据既定的排序规则，将元素 obj 移动存储到 priority_queue 中适当的位置。 |
|    emplace(Args&&… args)    | Args&&… args 表示构造一个存储类型的元素所需要的数据（对于类对象来说，可能需要多个数据构造出一个对象）。此函数的功能是根据既定的排序规则，在容器适配器适当的位置直接生成该新元素。 |
|            pop()            |         移除 priority_queue 容器适配器中第一个元素。         |
| swap(priority_queue& other) | 将两个 priority_queue 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 priority_queue 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。 |



## 2. 迭代器定义

常用的迭代器按功能强弱分为输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器 5 种。

1. 前向迭代器（# iterator）
   假设 p 是一个前向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 == 和 != 运算符进行比较。此外，两个正向迭代器可以互相赋值。

2. 双向迭代器（bidirectional iterator）
   双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 --p 或者 p-- 操作（即一次向后移动一个位置）。

3. 随机访问迭代器（random access iterator）
   随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：

   - p+=i：使得 p 往后移动 i 个元素。
   - p-=i：使得 p 往前移动 i 个元素。
   - p+i：返回 p 后面第 i 个元素的迭代器。
   - p-i：返回 p 前面第 i 个元素的迭代器。
   - p[i]：返回 p 后面第 i 个元素的引用。

   此外，两个随机访问迭代器 p1、p2 还可以用 <、>、<=、>= 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。

**迭代器定义方式**

| 迭代器定义方式 | 具体格式                                   |
| -------------- | ------------------------------------------ |
| 正向迭代器     | 容器类名::iterator 迭代器名;               |
| 常量正向迭代器 | 容器类名::const_iterator 迭代器名;         |
| 反向迭代器     | 容器类名::reverse_iterator 迭代器名;       |
| 常量反向迭代器 | 容器类名::const_reverse_iterator 迭代器名; |

反向迭代器和正向迭代器的区别在于：

- 对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素；
- 而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。

**反向迭代器重载的运算符**

| 重载运算符  | 功能                                                         |
| ----------- | ------------------------------------------------------------ |
| operator*   | 以引用的形式返回当前迭代器指向的元素。                       |
| operator+   | 返回一个反向迭代器，其指向距离当前指向的元素之后 n 个位置的元素。此操作要求基础迭代器为随机访问迭代器。 |
| operator++  | 重载前置 ++ 和后置 ++ 运算符。                               |
| operator+=  | 当前反向迭代器前进 n 个位置，此操作要求基础迭代器为随机访问迭代器。 |
| operator-   | 返回一个反向迭代器，其指向距离当前指向的元素之前 n 个位置的元素。此操作要求基础迭代器为随机访问迭代器。 |
| operator–   | 重载前置 – 和后置 – 运算符。                                 |
| operator-=  | 当前反向迭代器后退 n 个位置，此操作要求基础迭代器为随机访问迭代器。 |
| operator->  | 返回一个指针，其指向当前迭代器指向的元素。                   |
| operator[n] | 访问和当前反向迭代器相距 n 个位置处的元素。                  |