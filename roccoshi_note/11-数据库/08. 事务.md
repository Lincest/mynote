# 08. 事务

## 1 | 事务的ACID特性

- 原子性Atomicity: 事务要么全做, 要么全不做
- 一致性Consistency: 事务让数据库从一个一致性状态-->另一个一致性状态
- 隔离性Isolation: 事务的执行不能被其他事务干扰
- 持续性Durability: 事务提交后对数据库中数据的改变为永久性的

## 2 | 并发控制

几种并发冲突:

1. **丢失修改** (写-写冲突)
2. **不可重复读** (读-写冲突)
3. **读“脏”数据** (写-读冲突)

## 3 | 封锁机制

**X锁**: 排他锁, 持有X锁的人能读写数据库

**S锁:** 共享锁, 持有S锁的人能读不能写数据库

仅能有一个事务拥有X锁, 可以有多个事务同时拥有S锁

### 一级封锁协议

修改数据之前先加X锁, 事务结束后释放

解决问题: **丢失修改**

### 二级封锁协议

在一级封锁协议基础上增加在读取数据前必须对数据加S锁, 读完后即可释放

解决问题: **丢失修改和读“脏”数据**

### 三级封锁协议

在一级封锁协议的基础上增加在读取数据前必须对数据加S锁, 在事务结束后才可释放

解决问题: **丢失修改, 不可重复读, 读“脏”数据**

## 4 | 并发调度的可串行性

**可串行化调度的定义:**

> 定义: 多个并发事务的执行是正确的, 当且仅当其结果与按一定次序串行地执行这些事务时的结果相同

**可串行性**是并发事务正确调度的准则, 一个给定的并发调度当且仅当它是可串行化的才认为是正确的调度

**冲突可串行化调度:** 

将并发调度保证冲突操作次序不变的情况下交换不冲突操作的次序得到另一个串行调度, 则称这个并发调度为冲突可串行化的调度, 如果一个调度是冲突可串行化的, 那么则一定是可串行化的调度。

注意: 冲突可串行化调度是可串行化调度的充分非必要条件

## 5 | 两段锁协议

两段锁协议: 

> 先统一加锁, 事务结束时统一释放锁

- 遵守两段锁协议也会发生死锁

- 遵守两段锁协议是可串行化调度的充分条件