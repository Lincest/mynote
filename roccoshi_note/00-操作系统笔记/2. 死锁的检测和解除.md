# 2. 死锁的检测和解除

## 资源分配图 ##

资源分配图是一种数据结构 : 

<!--more-->

```mermaid
graph LR

A[数据分配图] -->B[两种结点]
A-->C[两种边]
B-->D[进程结点:对应一个进程]
B-->E[资源结点:对应一类资源,一类资源可能有多个]
C-->F[进程结点->资源结点:表示进程想申请几个资源<每条边代表一个>]
C-->G[资源节点->进程结点:表示已经为进程分配了几个资源<每条边代表一个>]

```

如图:

![](http://roccoshi.um5.net/img/1591346986377.png)

## 用资源分配图判断系统是否死锁 ##

### 方法 : ###

<img src="http://roccoshi.um5.net/img/1591347046229.png" style="zoom:50%;" />

### e.x. ###

没有死锁的资源分配图 :

![](http://roccoshi.um5.net/img/1591347095188.png)

死锁了的资源分配图 : 

![](http://roccoshi.um5.net/img/1591347144597.png)



## 死锁的解除 ##

### 资源剥夺法 ###

挂起(暂时放在外存)某些 **死锁** 进程, 并抢占它的资源, 让这些资源分配给其他的死锁进程, 注意需要防止被挂起的进程长时间得不到资源而饥饿



### 撤销进程法 ###

强制某些死锁进程, 并剥夺这些进程的资源.

优点 : 实现简单

缺点 : 代价大, 比如有些进程已经运行了很长时间甚至接近结束, 突然剥夺将功亏一篑



### 进程回退法 ###

让一个或多个死锁进程回退到足以避免死锁的地步

缺点 : 不太容易实现--系统需要记录进程的历史信息并设置还原点



可以根据 : 

- 进程优先级
- 已执行多长时间
- 还要多久能完成
- 已经使用了多少资源

等方式决定对那个死锁进程执行解除方案








