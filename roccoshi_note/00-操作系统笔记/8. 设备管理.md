# 8. 设备管理

## IO设备

I/O : Input / output

I/O设备就是可以将数据输入到计算机或者可以接收计算机输出数据的外部设备， 属于计算机中的硬件部件

UNIX系统将外部设备抽象为一种特殊的文件， 用户可以使用与文件操作相同的方式对外部设备进行操作

Write : 向外部设备写出数据

Read : 向外部设备读入数据

**IO设备的分类**

![1592651417440](http://pic.roccoshi.top/img/1592651417440.png)

## IO控制器

> CPU无法直接控制I/O设备的机械部件, 因此I/O设备还要有一个电子部件作为CPU和I/O设备机械部分之间的 "中介", 用于实现CPU对设备的控制

这个机械部件就是 I / O控制器, 又称设备控制器. CPU可控制I/O控制器, 又由I/O控制器来控制IO设备的机械部件

### IO控制器的功能 

1. 接受和识别CPU发出的命令
2. 向CPU报告设备的状态
3. 数据交换
4. 地址识别

### IO控制器的组成

1. **CPU与控制器的接口** : 用于实现CPU与控制器之间的通信, CPU通过控制线发出命令, 通过地址线指明要操作的设备, 通过数据线来取出输入数据, 或放入输出数据
2. **IO逻辑** : 负责接收和识别CPU的各种命令, 并负责对设备发出命令
3. **控制器与设备的接口** : 用于实现控制器与设备之间的通信

![1592659795663](http://pic.roccoshi.top/img/1592659795663.png)



## IO控制方式

![1592660152476](http://pic.roccoshi.top/img/1592660152476.png)



### 程序直接控制方式

通过 **轮询** 实现

![1592660341983](http://pic.roccoshi.top/img/1592660341983.png)

优点 : 实现简单.

缺点  : CPU的干预很频繁, 在IO操作开始之前, 完成之后都需要CPU的介入, 并且等待IO完成的过程中CPU需要**不断地轮询检查**, CPU长期处于**"忙等"** 状态, CPU利用率低



 ### 中断驱动方式

引入中断机制, 由于IO设备速度很慢, 因此在CPU发出读/写命令后, 可将等待IO的进程阻塞, 先切换到别的进程执行

![1592661047204](http://pic.roccoshi.top/img/1592661047204.png)

CPU只需要在每次IO开始之前和完成之后介入, 解决了程序直接控制方式中CPU需要不停轮询的特点, CPU的利用率得到明显提升.

缺点 : 每个字在I/O设备与内存之间的传输都需要经过CPU, 而频繁的中断处理会消耗较多的CPU时间.

### DMA方式

与 " 中断驱动方式 " 相比, DMA方式有这样几个改进 : 

1. 数据的**传送单位是 " 块 "**
2. 数据的流向是从设备直接放入内存, 或者从内存直接到设备, 不需要CPU作为中介
3. 仅在传送一个或多个数据块的**开始和结束**时才需要CPU的干预

**DMA控制器 :** 

![1592662527916](http://pic.roccoshi.top/img/1592662527916.png)

DMA的优缺点 : 

![1592662664963](http://pic.roccoshi.top/img/1592662664963.png)

### 通道控制方式

**通道** : 一种硬件, 通道可以识别并执行一系列**通道指令**

![1592662921901](http://pic.roccoshi.top/img/1592662921901.png)

### 总结 

![1592662962459](http://pic.roccoshi.top/img/1592662962459.png)



## IO软件层次结构



![1592665817370](http://pic.roccoshi.top/img/1592665817370.png)

 **设备驱动程序** : 直接涉及到硬件具体细节且与中断无关的操作

**设备独立性软件** : 不涉及硬件且对各种设备都需要进行的管理工作



## I/O核心子系统

![1592723764934](http://pic.roccoshi.top/img/1592723764934.png)

- I/O调度 : 比如磁盘调度 ( 先来先服务, SCAN, LOOK...)

- 设备保护 : UNIX中设备被看作文件, 每个设备也会有对应的FCB ( 文件控制块 ). 当用户请求访问某个设备时, 系统根据FCB中记录的信息来判断用户是否有相应的访问权限, 以此实现 " 设备保护" 的功能.

### 假脱机技术 ( SPOOLing )

假脱机技术 ( SPOOLing技术 ) 是用软件的方式模拟脱机技术.

SPOOLing系统的组成如下 : 

![1592736126286](http://pic.roccoshi.top/img/1592736126286.png)

**独占式设备** : 只允许各个进程串行使用的设备

**共享设备** : 允许多个进程 " 同时 " 使用的设备

> 打印机是一种 " 独占式设备 " , 但是可以用SPOOLing技术改造成 " 共享设备 "

 e.g. 共享打印机原理分析

![1592736560272](http://pic.roccoshi.top/img/1592736560272.png)

### 设备的分配与回收

从进程运行的安全性上考虑, 设备分配有两种方式 : 

1. **安全分配方式** : 为进程分配一个设备后就将进程阻塞, 本次I/O完成后才将进程唤醒.
2. **不安全分配方式** : 进程发出I/O请求后, 系统为其分配I/O设备, 进程可继续执行, 之后还可以发出新的I/O请求. 只有某个I/O请求得不到满足时才将进程阻塞.

安全分配方式破坏了死锁的"请求与保持"条件, 不会死锁, 但是对于一个进程来说, CPU和I/O设备只能串行工作

不安全分配方式下进程的计算任务和I/O任务可以并行处理, 使进程迅速推进, 但是可能发生死锁

#### 设备分配管理中的数据结构

 **设备, 控制器, 通道之间的关系** : 

![1592737373904](http://pic.roccoshi.top/img/1592737373904.png)

**设备控制表 ( DCT )** : 系统为每个设备配置一张DCT, 用于记录设备情况

![1592737575682](http://pic.roccoshi.top/img/1592737575682.png)

**控制器控制表 ( COCT )** : 系统根据COCT对控制器进行操作和管理

![1592737705727](http://pic.roccoshi.top/img/1592737705727.png)

**通道控制表 ( CHCT )** : 系统根据CHCT的信息对通道进行操作和管理

![1592737836895](http://pic.roccoshi.top/img/1592737836895.png)

**系统设备表 ( SDT ) ** : 记录了系统中全部设备的情况, 每个设备对应一个`表目`  

![1592737908392](http://pic.roccoshi.top/img/1592737908392.png)

#### 设备分配的步骤

1. 根据进程请求的物理设备名查找SDT
2. 根据SDT找到DCT, 若设备忙碌则将进程PCB挂到设备等待队列中, 不忙碌则将设备分配给进程
3. 根据DCT找到COCT, 若控制器忙碌则将进程PCB挂到控制器等待队列中, 不忙碌则将控制器分配给进程
4. 根据COCT找到CHCT, 若通道忙碌则将PCB挂到通道等待队列中, 不忙碌则将通道分配给进程

> 只有设备, 控制器, 通道三者都分配成功时, 这次设备分配才算成功, 之后便可启动I/O设备进行数据传送

可改进处 : 第一步中,可以通过LUT ( 逻辑设备表 )实现逻辑设备名到物理设备名的映射, 用户编程时只需要使用逻辑设备名申请设备而不必记忆物理设备名.



## 缓冲区管理

### 缓冲区的概念

> 缓冲区是一个存储区域, 可以由专门的硬件寄存器组成, 也可以利用内存作为缓冲区.

使用**硬件作为缓冲区**的成本较高, 容量较小, 一般仅用在对速度要求非常高的场合. 比如联想寄存器 ( 快表 ) 就是硬件作为缓冲区

一般情况下, 更多的是利用**内存作为缓冲区** 



### 缓冲区有什么作用 ? 

> 1. 缓和CPU与IO设备之间速度不匹配的矛盾
> 2. 减少对CPU的中断频率, 放宽对CPU中断相应时间的限制
> 3. 解决数据粒度不匹配的问题
> 4. 提高CPU与IO设备之间的并行性

![1592742788028](http://pic.roccoshi.top/img/1592742788028.png)



### 单缓冲

![1592743016842](http://pic.roccoshi.top/img/1592743016842.png)

假设设备把缓冲区充满的时间为$T$ , CPU处理工作区数据的时间为$C$, 缓冲区向工作区传送的时间为$M$, 则采用单缓冲策略每处理一块数据平均耗时为 : 

> $$
> Max(C,T) + M
> $$
>

![1592743583663](http://pic.roccoshi.top/img/1592743583663.png)



### 双缓冲

![1592743703204](http://pic.roccoshi.top/img/1592743703204.png)

 ### 循环缓冲区

![1592744137388](http://pic.roccoshi.top/img/1592744137388.png)

### 缓冲池

![1592744222939](http://pic.roccoshi.top/img/1592744222939.png)

