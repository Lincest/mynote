{"./":{"url":"./","title":"Introduction","keywords":"","body":"roccoshi的个人笔记库roccoshi的个人笔记库 是一个同步和保存笔记的地方 页面发布在gh-pages即 https://github.roccoshi.top/mynote 采用github actions自动集成, 方案见 https://zlogs.net/gitbook-action/#source 涉及的相关计算机书籍等资源本人一般会上传至https://cutt.ly/computerBooks 作者主页 https://home.roccoshi.top Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-10-19 15:04:39 "},"roccoshi_note/":{"url":"roccoshi_note/","title":"Roccoshi Note","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 16:18:26 "},"roccoshi_note/00-操作系统笔记/":{"url":"roccoshi_note/00-操作系统笔记/","title":"00-操作系统笔记","keywords":"","body":"考纲考纲 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/00-操作系统笔记/0. 作业管理 进程管理.html":{"url":"roccoshi_note/00-操作系统笔记/0. 作业管理 进程管理.html","title":"0. 作业管理 进程管理","keywords":"","body":"0. 作业管理 进程管理调度算法0. 作业管理 进程管理 1 | 系统调用是操作系统向上层提供的接口, 目态(用户态)即可执行 2 | 进程由程序段, 数据段和PCB三部分组成 3 | 进程的三种状态 : 4 | 线程 : 程序执行流的最小单位, 基本的CPU执行单元, 同一进程的不同线程共享进程的资源 5 | 处理机调度 : 高级调度-作业调度 中级调度-内存调度 低级调度-进程调度 6 | 调度算法的评价指标 调度算法 \\ Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/00-操作系统笔记/1. 信号量.html":{"url":"roccoshi_note/00-操作系统笔记/1. 信号量.html","title":"1. 信号量","keywords":"","body":"1. 信号量信号量的分类利用信号量实现同步与互斥同步互斥生产者-消费者问题吸烟者问题读-写者问题方案一方案二哲学家就餐问题方案一方案二方案三方案四1. 信号量 信号量 : 表示系统中某种资源的数量, 当它的值大于0时, 表示当前可用资源的数量; 当它的值小于0时, 其绝对值表示等待使用该资源的进程个数 P, V操作 : PV操作由P操作原语和V操作原语(不可中断)组成，针对信号量进行相应的操作. P操作相当于请求资源, V操作相当于释放资源 信号量的分类 整型信号量 本质就是一个数, 表示资源数量 int S = 1; // 整型信号量, 初始值为1, 表示系统中有一个资源 void P(int S){ // P操作 while(S 整型信号量的问题 : 存在\"忙等\", 即上述P操作时, 如果资源不够, 将一直执行while循环语句, 该进程会一直占用CPU, 为解决这个问题, 引入了记录型信号量 记录型信号量 除了记录资源数, 还加入了等待队列 定义如下: typedef struct{ int value; // 剩余资源数 struct process *L; // 等待队列 }semaphore; ​ 对应的P, V操作实现如下: void P(semaphore S){ S.value--; if(S.value 阻塞态 } // 如果剩余资源不够, 利用block原语使进程将进程挂起到S的等待队列(阻塞队列)中, 避免\"忙等\" } void V(semaphore S){ S.value++; if(S.value 就绪态 } // 释放资源后, 等待队列还有进程, 那么利用wakeup原语唤醒该进程 } 后文所使用的信号量均为semaphore即记录型信号量, 一般我们所说的信号量也均为记录型 利用信号量实现同步与互斥 同步 同步 : 保证\"一前一后\"执行两个操作 利用信号量实现同步 : semaphore S = 0; // 初始化信号量 = 0 P1(){ // P1进程 xx1; // 操作1 xx2; // 操作2 V(S); // 信号量++ } P2(){ P(S); xx3; // 操作3 xx4; // 操作4 } 总结就是 : 在\"前\"操作之后执行V操作, 在\"后\"操作之前执行P操作 互斥 互斥 : 实现对临界资源(一次只能供一个进程访问的资源)的访问 利用信号量实现互斥: semaphore mutex = 1; // 互斥信号量mutex, 初始化为1 P1(){ P(mutex); 访问临界区; V(mutex); } P2(){ P(mutex); 访问临界区; V(mutex); } 生产者-消费者问题 问题本质 : 实现对一个大小为n的缓冲区的互斥访问, 存取操作 问题描述: 生产者消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了两个共享固定大小缓冲区——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。 关键点 : 生产者消费者共享一个大小为n, 初始为空的缓冲区----缓冲区即临界资源 缓冲区未满时生产者才可以将产品放入----设置empty信号量 缓冲区不为空时消费者才可以将产品取出----设置full信号量 实现 : 信号量设置 : semaphore mutex = 1; // 互斥信号量, 实现对缓冲区的互斥访问 semaphore empty = n; // 同步信号量, 表示空闲缓冲区数(可放产品数) semaphore full = 0; // 同步信号量, 表示非空缓冲区数(放入产品数) 生产者消费者操作: producer(){ // 生产者 while(1){ P(empty); P(mutex); 产品放入缓冲区; V(mutex); V(full); } } consumer(){ // 消费者 while(1){ P(full); P(mutex); 取出产品; V(mutex); V(empty); } } tips : P(mutex)互斥操作必须在同步操作之后, 否则会引发\"死锁\": // 如果改变 P(mutex)和P(empty)顺序, 假设此时empty=0,即缓冲区已满 producer(){ // 生产者 while(1){ P(mutex); P(empty); 产品放入缓冲区; V(full); V(mutex); } } 比如我生产者先P(mutex)申请到了临界资源访问权限, 但是之后P(empty)时被阻塞, 此时消费者一方又由于mutex被生产者占有而无法取出产品, 导致互相等待对方释放资源, 即死锁 在此处, 如果缓冲区大小为1, 可以不设置mutex信号量(互斥可以由empty和full满足) 吸烟者问题 问题本质 : 可以生产多个产品的单生产者问题 问题描述 : 假设一个系统中有三个抽烟者进程，每个抽烟者不断地卷烟并抽烟。抽烟者卷起并抽掉一颗烟需要有三种材料：烟草、纸和胶水。一个抽烟者有烟草，一个有纸，另一个有胶水。系统中还有两个供应者进程，它们无限地供应所有三种材料，但每次仅轮流提供三种材料中的两种。得到缺失的两种材料的抽烟者在卷起并抽掉一颗烟后会发信号通知供应者，让它继续提供另外的两种材料。这一过程重复进行。 关键点 : 临界资源---桌子, 视为缓冲区, 大小为1 ---- 设置同步信号量finish 产品有3种不同的组合, 分别给3个不同的人使用 ---- 设置同步信号量offer1, offer2, offer3 生产者如何实现轮流生产3种产品 ---- for i in range(3)即可 注意这里不需要设置额外的互斥信号量mutex, 因为缓冲区大小为1 实现 : 信号量设置: semaphore offer1 = 0, offer2 = 0, offer3 = 0; semaphore finish = 0; // 抽烟是否完成 int i = 0; // 实现\"轮流生产\" provider(){ while(1){ if(i == 0) V(offer1); else if(i == 1) V(offer2); else if(i == 2) V(offer3); i = (i + 1) % 3; P(finish); // 注意由于finish初值为0,所以将P(finish)放在后面 } } smoker1(){ while(1){ P(offer1); // 拿烟,抽了 V(finish); // 完成抽烟,告诉生产者可以继续生产下一个了 } } smoker2(){ while(1){ P(offer2); // 拿烟,抽了 V(finish); // 完成抽烟,告诉生产者可以继续生产下一个了 } } smoker3(){ while(1){ P(offer3); // 拿烟,抽了 V(finish); // 完成抽烟,告诉生产者可以继续生产下一个了 } } 读-写者问题 问题本质 : 允许多个进程同时读缓冲区, 但是只允许一个进程写缓冲区 问题描述 : 一个共享文件, 可以有多个读者同时读文件, 或者一个写着向文件中写信息, 任一写者完成写操作前不允许其他读 / 写者工作, 写者执行写操作前所有的读者应当退出 关键点 : 实现多个读者同时读 实现读者-写者,写者-写者之间的互斥 实现 : 方案一 信号量设置 : semaphore rw = 1; // 实现对文件的互斥访问 int count = 0; // 记录读者的数目 semaphore mutex = 1; // 实现互斥 写者 : writer(){ while(1){ P(rw); write......... // 写文件 V(rw); } } 读者 : reader(){ while(1){ P(mutex); // 这里的mutex进用于实现count的互斥, 防止两个读者同时进入时出问题 if(count == 0) P(rw); // 第一个读者进来时将文件\"锁定\" count++; // 每来一个读者,count+1 V(mutex); read........ // 读文件 P(mutex) count--; if(count == 0) V(rw); // 最后一个读者退出时将文件权限释放 V(mutex); } } 方案一的问题 仔细分析后, 我们从上述方案中可以发现一个问题, 那就是如果读者源源不断的到来, 写者将一直被挂起\"饿死\", 这个方案实际上是不公平的, 具有\"读进程优先的特性\", 为了解决这个问题, 我们可以引入一个新的信号量w=1, 实现读者写者的公平性. 方案二 信号量设置 : semaphore rw = 1; int count = 0; semaphore mutex = 1; semaphore w = 1; // 方案一基础上增加 写者 : writer(){ while(1){ P(w); P(rw); write......... // 写文件 V(rw); V(w); } } 读者 : reader(){ while(1){ P(w); P(mutex); if(count == 0) P(rw); count++; V(mutex); V(w); //注意V(w)放在read之前 read........ P(mutex) count--; if(count == 0) V(rw); V(mutex); } } 分析 : 可以看到, 在方案二中, 如果读者读的过程中有写着想要访问, 那么该写者进程将挂在信号量w的等待队列上, 当该读者读完退出后, 写者即可以写, 当一个读者在读的时候, 它已经V(w)操作了, 也不会影响读者读的并行 哲学家就餐问题 问题本质 : 进程需持有多个临界资源才可以工作, 如何避免分配不当导致\"死锁\" 问题描述 : 哲学家就餐问题可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和筷子而不是意大利面和餐叉来描述，因为很明显，吃米饭必须用两根筷子。 由于有5只筷子, 相当于5个临界资源, 我们定义信号量数组chopstick[5]来表示这5个临界资源 semaphore chopstick[5] = {1,1,1,1,1} 同时为了方便描述, 我们给哲学家和筷子都编号 根据编号有如下定义: 哲学家i 号的左手筷子为chopstick[i] , 右手为chopstick[(i+1)%5] 我们很容易想到一种方式分配临界资源: 方案一 Pi(){ // Pi表示第i个哲学家进程 while(1){ P(chopstick[i]); // 拿左边筷子 P(chopstick[(i + 1) % 5]); // 拿右边筷子 eat...... // 吃饭 V(chopstick[i]); // 放下左边筷子 V(chopstick[(i + 1) % 5]); // 放下右边筷子 } } 这个方案有一个很明显的问题, 那就是如果五个哲学家同时拿筷子, 那么每个人都将拿起自己左手的筷子而等待右手的筷子 , 也就导致了\"死锁\"的局面, 如下图: 我们可以通过几种方式改变这种死锁局面, 核心思想均是防止所有人同时拿到1根筷子 : 方案二 描述 : 限制最多四人同时就餐 semaphore cnt = 4; // 限制4个人 semaphore chopstick[5] = {1,1,1,1,1}; semaphore Pi(){ // Pi表示第i个哲学家进程 while(1){ P(cnt); P(chopstick[i]); // 拿左边筷子 P(chopstick[(i + 1) % 5]); // 拿右边筷子 eat...... // 吃饭 V(chopstick[i]); // 放下左边筷子 V(chopstick[(i + 1) % 5]); // 放下右边筷子 V(cnt); } } 方案三 描述 : 奇数号先拿左手的筷子, 偶数号先拿右手的筷子 semaphore chopstick[5] = {1,1,1,1,1}; Pi(){ // Pi表示第i个哲学家进程 while(1){ if(i % 2 == 1){ // 奇数号 P(chopstick[i]); // 拿左边筷子 P(chopstick[(i + 1) % 5]); // 拿右边筷子 } else{ // 偶数号 P(chopstick[(i + 1) % 5]); // 拿右边筷子 P(chopstick[i]); // 拿左边筷子 } eat...... // 吃饭 V(chopstick[i]); // 放下左边筷子 V(chopstick[(i + 1) % 5]); // 放下右边筷子 } } 方案四 描述 : 互斥\"拿筷子\"这个动作 semaphore chopstick[5] = {1,1,1,1,1}; semaphore mutex = 1; Pi(){ // Pi表示第i个哲学家进程 while(1){ P(mutex); // 互斥 P(chopstick[i]); // 拿左边筷子 P(chopstick[(i + 1) % 5]); // 拿右边筷子 V(mutex); eat...... // 吃饭 V(chopstick[i]); // 放下左边筷子 V(chopstick[(i + 1) % 5]); // 放下右边筷子 } } 四种方法都很好理解, 总而言之就是不让五个哲学家都陷入等待的局面就ok啦~ 参考 https://www.bilibili.com/video/BV1YE411D7nH?p=26 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/00-操作系统笔记/2. 死锁的检测和解除.html":{"url":"roccoshi_note/00-操作系统笔记/2. 死锁的检测和解除.html","title":"2. 死锁的检测和解除","keywords":"","body":"2. 死锁的检测和解除资源分配图用资源分配图判断系统是否死锁方法 :e.x.死锁的解除资源剥夺法撤销进程法进程回退法2. 死锁的检测和解除 资源分配图 资源分配图是一种数据结构 : graph LR A[数据分配图] -->B[两种结点] A-->C[两种边] B-->D[进程结点:对应一个进程] B-->E[资源结点:对应一类资源,一类资源可能有多个] C-->F[进程结点->资源结点:表示进程想申请几个资源] C-->G[资源节点->进程结点:表示已经为进程分配了几个资源] 如图: 用资源分配图判断系统是否死锁 方法 : e.x. 没有死锁的资源分配图 : 死锁了的资源分配图 : 死锁的解除 资源剥夺法 挂起(暂时放在外存)某些 死锁 进程, 并抢占它的资源, 让这些资源分配给其他的死锁进程, 注意需要防止被挂起的进程长时间得不到资源而饥饿 撤销进程法 强制某些死锁进程, 并剥夺这些进程的资源. 优点 : 实现简单 缺点 : 代价大, 比如有些进程已经运行了很长时间甚至接近结束, 突然剥夺将功亏一篑 进程回退法 让一个或多个死锁进程回退到足以避免死锁的地步 缺点 : 不太容易实现--系统需要记录进程的历史信息并设置还原点 可以根据 : 进程优先级 已执行多长时间 还要多久能完成 已经使用了多少资源 等方式决定对那个死锁进程执行解除方案 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/00-操作系统笔记/3. 分页存储.html":{"url":"roccoshi_note/00-操作系统笔记/3. 分页存储.html","title":"3. 分页存储","keywords":"","body":"3. 分页存储基本分页存储管理页框和页面地址转换的实现3. 分页存储 内存管理学习笔记 : 操作系统---内存管理(上) 概念 覆盖交换技术 连续分配管理方式 操作系统---内存管理(中) 分页存储 操作系统---内存管理(下) 分段存储 段页式存储 虚拟内存 请求分页管理方式 本节笔记对应的课件下载地址 大纲 : 基本分页存储管理 页框和页面 思想 : 把内存分为一个个相等的小分区, 再按照分区大小把进程拆分成一个个小部分. 页框 : 页面 : 注意区分页框和页面的概念, 页框是针对内存的, 页面是针对进程的 地址转换的实现 特点 : 页面离散存放, 但是页面内部连续存放 访问逻辑地址A : ( 重点 ) 确定逻辑地址A的 \" 页号 \" P 找到P号页面在内存中的起始地址 ( 需要查找页表 ) 确定逻辑地址A的 \" 页内偏移 \" W 逻辑地址 Ａ的物理地址 = P号页面在内存中的起始地址 + 页内偏移量W 页号和页内偏移量 e.g. 为了方便计算页号和页内偏移量, 页面大小一般设置为2的整数幂( why ? ) : ( 妙啊 ) 页表 tips : 页表中的页号是\"隐含\"的, 可以不占用存储空间 e.g. 假设某系统物理内存大小为 4GB， 页面大小为 4KB， 则 每个页表项至少应该为多少字节？ 内存块大小=页面大小=4KB= 2122^{12}2​12​​B 4GB 的内存总共会被分为232212=220\\frac{2^{32}}{2^{12}} = 2^{20}​2​12​​​​2​32​​​​=2​20​​个内存块 内存块号的范围应该是 0 220−10 ~ 2^{20} -10 2​20​​−1 内存块号至少要用 20 bit 来表示 至少要用3B来表示块号(3*8=24bit) (但是, 为了方便页表的查询, 常常会让一个页表项占更多的字节, 使得每个页面恰好可以装得下整数个页表项) 如何理解 \"页号是隐含的\" : 基本地址变换机构 框图 : ( 重点 ! ) 步骤总结 : 根据逻辑地址计算出页号和页内偏移量 判断页号是否越界 查询页表, 找到页号对应的页表项, 确定页面存放的内存块号 用内存块号和页内偏移量得到物理地址 ( 页表长度*物理块号 + 页内偏移 = 物理地址 ( 计算机直接采用拼接物理块号和页内偏移的方式得到物理地址 ) ) 访问目标单元 ( 一共需要访问两次内存 : 第一次用来查页表, 第二次用于访问目标内存单元 ) 具有快表的地址变换机构 局部性原理 时间局部性 如果执行了程序中的某条指令, 那么不久之后这条指令很有可能再次执行; 如果某个数据被访问过, 不久之后该数据很可能再次被访问 ( 程序中存在大量的循环 ) 空间局部性 一旦程序访问了某个存储单元, 在不久之后, 其附近的存储单元也很有可能被访问到 ( 很多数据在内存中连续存放 ) 快表(TLB) 快表又成为联想寄存器(TLB), 是一种访问速度比内存块很多的高速缓冲存储器, 用来存放当前访问的若干页表项, 以加速地址变换的过程. 与此对应的, 内存中的页表常称为慢表. 步骤总结 : 快表与基本地址变换机构的比较 : tips : TLB 和 普通 Cache 的区别——TLB 中只有页表项的副本， 而普通 Cache 中可能会有其他各种数据的副本 两级页表 单级页表存在的问题 : 由于页号隐式表示, 所以要根据页号查询页表需要 : K 号页对应的页表项存放位置 = 页表始址 + K 4 要在*所有的页表项都连续存放的基础上才能用这种方法找到页表项 同时, 由局部性原理可知, 很多时候, 进程在一段时间内只需要访问某几个页面就可以正常运行了, 因此没有必要让整个页表都常驻内存 解决 : 把页表再分页并离散存储， 然后再建立一张页表记录页表各个部分的存放位置， 称为页目录表， 或称外层页表， 或称顶层页表. e.g. 关于页表常驻内存的解决 -- ( 虚拟存储技术 ) , 在页表项中增加一个标志位, 用于表示该页面是否已经调入内存 注意: 如果采用多级页表机制, 各级页表不能超过一个页面 两级页表的访存次数分析 : n级页表访存次数为n+1次: ( 以2级页表为例 ) 访问内存中的页目录表 ( 顶级页表 ) 访问内存中的二级页表 访问目标内存单元 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/00-操作系统笔记/4. 分段存储  段页式  请求分页.html":{"url":"roccoshi_note/00-操作系统笔记/4. 分段存储  段页式  请求分页.html","title":"4. 分段存储  段页式  请求分页","keywords":"","body":"基本分段存储管理方式分段系统的组成:段表查找过程分段和分页的对比段页式内存管理方式分页, 分段管理的优缺点分析段页式管理的结构段表, 页表查找过程虚拟内存传统存储管理方式的特征, 缺点请求分页管理方式页表机制缺页中断机构页面置换算法页面分配策略基本分段存储管理方式 分段 : 进程的地址空间会按照自身的逻辑关系划分为若干个段, 每个段都有一个段名, 每段从0开始编址 内存分配规则 : 以段为单位进行分配, 每个段在内存中占据连续空间, 但各段之间可以不相邻 分段系统的组成: 段号------ 段号的位数决定了每个进程最多可以分为几个段 段内地址------段内地址的位数决定了每个段的最大长度是多少 段表 程序分为多个段, 各个段离散地装入内存, 为了保证程序能正常运行, 就必须能从物理内存中找到各个逻辑段的存放位置. 为此, 需为每个进程建立一张段映射表, 简称 \" 段表 \" . 关于段表 : 每个段对应一个段表项, 记录着该段在内存中的起始位置 ( 基址 ) 和 段长 各个段表项的长度是相同的, 因此和页号一样, 段号是\" 隐含 \"的, 不占据存储空间 查找过程 分段和分页的对比 页是信息的物理单位, 分页的主要目的是为了实现离散分配, 提高内存利用率. 分页仅仅是系统管理上的需要, 完全是系统行为, 对用户是不可见的 段是信息的逻辑单位, 分段的主要目的是更好地满足用户需求. 一个段通常包含着一组属于一个逻辑模块的信息, 分段对用户是可见的, 用户编程时需要显式地给出段名 页的大小是固定且由系统决定, 段的长度却不固定, 决定于用户编写的程序 分页的用户进程地址空间是一维的, 分段的用户进程是二维的. 分段比分页更容易实现信息的共享和保护 段页式内存管理方式 分页, 分段管理的优缺点分析 优点 缺点 分页管理 内存空间利用率高. 不会产生外部碎片, 只有少量的内部碎片 不方便逻辑模块实现信息的共享与保护 分段管理 方便实现逻辑模块信息的共享与保护 如果段长过大, 为其分配很大的连续空间会很不方便, 并且段式管理会产生外部碎片 段页式管理的结构 先分段 , 再分页 段页式管理的逻辑地址结构 : 由段号, 页号, 页内偏移 组成 段号的位数决定了每个进程最多可以分为几个段 页号位数决定了每个段最大有多少页 页内偏移量决定了页面大小和内存块的大小 注意 : \"分段\"对用户是可见的, 而将各段\"分页\"对用户是不可见的, 系统会根据段内地址自动划分页号和段内偏移量, 因此段页式管理的地址结构是\"二维\"的. 段表, 页表 每一个进程对应一个段表, 每一个段又对应一个页表, 因此一个进程可能对应多个页表. 查找过程 由逻辑地址得到段号, 页号, 页内偏移 段号与段表寄存器的段长度比较, 检查是否越界 由段表始址, 段号找到对应段表项 ---- ( 一次访存) 根据段表中记录的页表长度, 检查页号是否越界 由段表中的页表地址, 页号得到查询页表, 找到相应页表项 ---- ( 二次访存) 由页面存放的内存块号, 页内偏移得到最终的物理地址 访问目标单元 ---- ( 三次访存) 虚拟内存 传统存储管理方式的特征, 缺点 一次性 : 作业必须一次性全部装入内存才能开始运行 作业很大时, 无法装入导致大作业无法运行 大量作业要求运行时内存无法容纳所有作业, 导致多道程序并发度下降 驻留性 : 一旦作业被装入内存, 就会一直驻留在内存中, 直到作业运行结束, 这样会导致内存中驻留大量的, 暂时用不到的数据, 浪费内存资源 虚拟内存---基于局部性原理 在程序装入时, 将程序中很快会用到的部分装入内存, 暂时用不到的部分留在外存, 就可以让程序开始执行. 在程序执行过程中, 当所访问的信息不在内存时, 由操作系统负责将所需信息由外存调入内存, 然后继续执行程序. 内存空间不够时, 操作系统负责将内存中暂时用不到的信息换出到外存 在用户看来, 就有一个比实际内存大很多的内存, 这就叫虚拟内存 注意 : 虚拟内存的最大容量是由计算机的地址结构 ( CPU的寻址范围 ) 确定的, 虚拟内存的实际容量 = $ min( 内存容量 + 外存容量, CPU寻址范围) $ 虚拟内存的实现 : 请求分页存储管理 请求分段存储管理 请求段页式存储管理 操作系统需要提供的功能 : 请求调页 ( 段 ) 页面置换 ( 段置换 ) 缺页时请求掉页不一定页面置换, 若还有可用的内存块, 就不用进行页面置换 请求分页管理方式 页表机制 缺页中断机构 在请求分页操作系统中, 每当要访问的页面不在内存时, 便产生一个缺页中断, 然后由操作系统的缺页中断处理程序处理中断 此时缺页的进程阻塞, 放入阻塞队列, 调页完成后再将其唤醒, 放回就绪队列 如果内存中有空闲块, 则为进程分配一个空闲块, 将所缺页面装入该块, 并修改页表中相应的页表项 如果内存中没有空闲块, 则由页面置换算法选择一个页面淘汰, 若该页面在内存期间被修改过, 则要将其写回外存, 未修改过的页面不用写回外存 缺页中断是因为当前执行的指令想要访问目标页面未调入内存而产生的, 因此属于内中断 : 页面置换算法 最佳置换算法OPT 每次选择淘汰的页面是以后永不使用或者在最长时间内不会使用的页面, 保证最低的缺页率 . 但是操作系统无法预判页面访问序列, 这种算法是无法实现的 先进先出置换算法 FIFO 每次淘汰的页面是最早进入内存的页面 实现 : 将调入内存的页面根据调入的先后顺序排成一个队列, 需要置换页面的时候选择队首的页面. 实现简单, 算法性能差, 不适应进程实际运行时的规律 最近最久未使用算法 LRU 当需要淘汰一个页面的时候, 选择现有页面中t值最大的, 即最近最久未使用的页面. 做题时的方法 : 需要淘汰页面时, 逆向检查此时在内存中的几个页面号, 最后一个出现的页号就是需要被淘汰的 LRU算法的特点 : 性能好, 但实现起来需要专门的硬件支持, 算法开销大 时钟置换算法 ( CLOCK ) / 最近未用算法 ( NRU ) 他们是同一种算法. 简单的CLOCK算法的实现方法 : 简单的时钟置换算法仅考虑到了一个页面最近是否被访问过, 但是事实上, 如果被淘汰的页面没有被修改过, 就不需要执行I/O操作写回外存. 只有被淘汰的页面被修改过时, 才需要写回外存------因此, 除了考虑一个页面最近有没有被访问过之外, 操作系统还应该考虑页面有没有被修改过. 在其他条件都相同时, 应该优先淘汰没有修改过的页面, 避免I/O操作, 这就是改进型的时钟置换算法的思想. 利用 (访问位R, 修改位M) 的形式表示各页面状态 对应页面 第一轮 : 找第一个 (0, 0)的帧用于替换 ( 不修改标志位 ) 最近没访问且没修改 第二轮 : 找第一个 (0, 1)的帧用于替换 ( 将所有扫描过的帧访问位设为0) 最近没访问但修改过 第三轮 : 找第一个 (1, 0)的帧用于替换 ( 不修改标志位 ) 最近访问过但没修改 第四轮 : 找第一个 (1, 1)的帧用于替换 最近访问过也修改过 特点 : 开销小, 性能也不错 页面分配策略 驻留集 请求分页存储管理器中给进程分配的物理块的集合. ( 系统给进程分配了n各物理块 ----的另一种表述 : 驻留集大小为n) 在采用虚拟存储技术的系统中, 驻留集的大小一般小于进程的总大小 如果驻留集太小, 会导致缺页频繁, 系统要花大量的时间来处理缺页, 实际用于进程推进的时间很少 如果驻留集太大, 会导致多道程序并发度下降, 资源利用率降低 几种分配策略 固定分配全局置换不存在, 因为进程物理块固定后不会再分配给别人 可变分配全局置换 : 只要缺页就给分配新物理块 可变分配局部置换 : 根据发生缺页的频率来动态地增加或减少进程的物理块 何时调入页面 预调页策略 请求调页策略 何处调入页面 文件区用于调入不会被修改的数据, 对换区用用于调入可能被修改的数据 抖动现象 工作集 一般来说 驻留集的大小不能小于工作集的大小, 否则进程运行过程中将频繁缺页. Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/00-操作系统笔记/5. 内存管理.html":{"url":"roccoshi_note/00-操作系统笔记/5. 内存管理.html","title":"5. 内存管理","keywords":"","body":"5. 内存管理大纲什么是内存存储单元逻辑地址和物理地址编译, 链接, 装入内存管理的概念内存空间的扩充覆盖与交换内存空间的分配和回收连续分配管理方式5. 内存管理 大纲 什么是内存 内存是用于存放数据的硬件 程序执行前需要先放到内存中才能被cpu处理 存储单元 如果计算机\"按字节编址\", 每个存储单元大小为8 bit 如果计算机\"按字编址\", 每个存储单元大小为16 bit 逻辑地址和物理地址 指令的编指一般采用逻辑地址, 即相对地址 物理地址 = 起始地址 + 逻辑地址 (理解) 编译, 链接, 装入 编译 : 由编译程序将用户源代码编译成若干个目标模块 链接 : 由连接程序将编译后形成的一组目标模块以及所需函数连接在一起, 形成一个完整的装入模块 链接的三种方式 : 静态链接-----装入模块不再拆开 装入时动态链接-----将各目标模块装入内存时, 边装入边链接的连接方式 运行时动态链接-----在程序执行中需要该目标模块时才对它进行链接 装入 : 由装入程序将装入模块装入内存运行 装入的三种方式: 绝对装入 静态重定位 动态重定位 绝对装入 : 在编译时, 如果知道程序将放到内存的哪个位置, 编译程序将产生绝对地址的目标代码, 装入程序按照装入模块中的地址, 将程序和数据装入内存 ------灵活性低, 只适合单道程序环境 静态重定位 : 又称为可重定位装入. 编译, 链接后的装入模块地址都是从0开始的, 指令中使用的地址和数据存放的地址都是相对于起始地址而言的逻辑地址. 可以根据内存的当前状况将装入模块装入到内存的适当位置. 装入时对地址进行\"重定位\", 逻辑地址变换为物理地址(地址变换是在装入时一次完成的). 动态重定位 : 装入程序把装入模块装入内存后不会立即把逻辑地址转换为物理地址, 而是把地址转换推迟到程序真正要执行时才进行. 因此装入内存后所有的地址依然是逻辑地址. 这种方式需要一个重定位寄存器(存放装入模块的起始位置)的支持 内存管理的概念 进程应该放在内存的哪里? 操作系统如何记录哪些内存区域已经被分配了, 哪些还空闲? 当进程运行结束之后, 如何将进程占用的内存空间释放? 操作系统负责内存空间的分配与回收 操作系统需要提供某种技术从逻辑上对内存空间进行扩充 操作系统需要实现地址转换功能, 负责程序的逻辑地址和物理地址的转换 操作系统需要提供内存保护功能, 保证各进程在各自存储空间内运行, 互不干扰 实现内存保护的两种方法: 在CPU设置一对上, 下限寄存器, 存放进程的上, 下限地址. 进程的指令要访问某个地址时, CPU检查是否越界 采用重定位寄存器(又叫基地址寄存器) 和界地址寄存器(又叫限长寄存器) 进行越界检查. 重定位寄存器中存放的是进程的起始物理地址, 界地址寄存器中存放的是进程的最大逻辑地址. 内存空间的扩充 覆盖与交换 覆盖, 交换, 虚拟存储技术常用于实现内存空间的扩充 覆盖技术 覆盖技术的思想 : 将程序分为多个段, 常用的段常驻内存, 不常用的段在需要的时候调入内存 内存中分为一个\"固定区\" 和若干个\"覆盖区\", 常用的段放在固定区, 不常用的段放在覆盖区 缺点 : 必须由程序员声明覆盖结构, 对用户不透明, 增加了用户的编程负担, 覆盖技术只用于早期的操作系统中. 交换技术 交换技术的思想 : 内存空间紧张时, 系统将内存中某些进程暂时换出外存, 把外存中某些已具备运行条件的进程换入内存(即进程在内存与磁盘间动态调度) 内存空间的分配和回收 连续分配管理方式 单一连续分配 在单一连续分配的方式中, 内存被分为系统区和用户区, 系统区用于存放操作系统的相关数据, 用户区用于存放用户进程的相关数据, 内存中只能有一道用户程序, 用户程序独占整个用户区空间. 优点 : 实现简单, 无外部碎片; 可以采用覆盖技术扩充内存; 不一定需要采取内存保护 缺点 : 只能用于单用户, 单任务的操作系统中; 有内部碎片; 存储器利用率极低 内部碎片 : 分配给某进程的内存区域有一部分没有用上, 即存在\" 内部碎片 \". 外部碎片 : 内存中的某些空闲分区由于太小而难以利用 固定分区分配 在产生了支持多道程序的系统后, 为了能在内存中装入多道程序而互相之间不产生干扰, 将整个用户区划分为若干个固定大小的分区(分区大小可以相等也可以不相等), 在每个分区中只能装入一道作业, 形成了最早的可运行多道程序的内存管理方式. 操作系统建立一个数据结构----分区说明表, 来实现各个分区的分配和回收, 每个表对应一个分区, 通常按分区大小排列. 每个表项包括对应分区的大小, 起始地址, 状态 优点 : 实现简单, 无外部碎片; 缺点 : 有内部碎片; 存储器利用率不高; 动态分区分配 动态分区分配又称为可变分区分配, 这种分配方式不会预先划分内存分区. 而是在进程装入内存时根据进程大小动态地建立分区, 并使得分区的大小正好适合进程的需要. 几个问题 : 系统用什么数据结构记录内存的使用情况? 当多个空闲分区都满足需求应该选择哪个分区进行分配? 如何进行分区的分配和回收操作? 常用的数据结构 : 空闲分区表, 空闲分区链 动态分配不会产生内部碎片, 而会产生外部碎片, 外部碎片可以通过\" 紧凑\"的方式解决(把基地址迁移) 四种动态分配的算法 首次适应算法 每次都从低地址开始查找, 找到第一个能满足大小的空闲分区 实现 : 把空闲分区按地址递增的次序排列. 每次分配内存时顺序地查找空闲分区链, 找到大小能满足要求的第一个空闲分区. 最佳适应算法 优先使用小的空闲分区 实现 : 空闲分区按容量递增次序链接. 每次分配内存时顺序查找空闲分区链, 找到大小能满足要求的第一个空闲分区 缺点 : 每次都选择最小的分区进行分配, 会留下越来越多的容量很小难以利用的内存块, 即产生很多的外部碎片 最坏适应算法 优先使用大的空闲分区 实现 : 空闲分区按容量递减次序链接 缺点 : 每次都选用最大的分区进行分配, 当较大的连续空闲区被小号之后, 如果有大进程到来则没有内存分区可以利用 邻近适应算法 在首次适应算法的基础上, 每次都从上次查找结束的位置开始查找空闲分区链(表), 找到大小能满足的第一个空闲分区 缺点 : 邻近适应算法导致无论低地址还是高地址的空闲分区都有相同的概率被使用, 也就导致了高地址部分的大分区更可能被使用划分为小分区, 最后导致没有大分区可用 综合来看, 首次适应算法的性能最好 算法开销大 : 最佳适应法, 最坏适应法 ( 需要经常排序) 算法开销小 : 首次适应算法, 邻近适应算法 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/00-操作系统笔记/6. 文件管理.html":{"url":"roccoshi_note/00-操作系统笔记/6. 文件管理.html","title":"6. 文件管理","keywords":"","body":"6. 文件管理文件的简介一个文件的属性文件的分类操作系统应该向上提供的功能文件的逻辑结构有结构文件文件目录文件控制块FCB单级目录结构两级目录结构多级目录结构 ( 树形目录结构 )无环图目录结构索引结点 ( FCB的改进 )文件的物理结构文件块和磁盘块文件分配方式---连续分配文件分配方式---链接分配文件分配方式---索引分配文件存储空间管理空闲表法空闲链表法位示图法成组链接法文件的基本操作创建文件删除文件打开文件关闭文件读文件, 写文件文件共享基于索引结点的共享方式 ( 硬链接 )基于符号链的共享方式 ( 软连接 )文件保护文件系统的层次结构6. 文件管理 文件的简介 一个文件的属性 文件名 标识符 类型 位置 大小 创建时间, 上次修改时间 文件所有者信息 保护信息 文件的分类 无结构文件 ( 流式文件) 如文本文件, 由一些二进制或字符流组成 有结构文件 ( 记录式文件 ) 如数据库表, 由一组相似的记录组成, 又称 \"记录式文件\" 记录 : 一组相关数据项的集合 操作系统应该向上提供的功能 创建文件---create系统调用 读文件---read系统调用 删除文件---delete系统调用 写文件---write系统调用 打开文件---open系统调用 关闭文件---close系统调用 文件的逻辑结构 graph LR A[文件的逻辑结构]---B[有结构文件] A---C[无结构文件] B---b1[顺序文件] B---b2[索引文件] B---b3[索引顺序文件] 这里重点讨论有结构文件 有结构文件 有结构文件由一组相似的记录组成, 又称记录式文件 . 每条记录又由若干个数据项组成, 如数据库表文件. 一般来说, 每条记录有一个数据项可作为关键字. 根据各条记录的长度是否相等, 可分为定长记录和可变长记录两种. 顺序文件 文件中的记录一个接一个地顺序排列( 逻辑上 ) , 记录可以是定长的或可变长的. 各个记录在物理上可以顺序存储或链式存储. 索引文件 索引顺序文件 索引顺序文件是索引文件和顺序文件思想的结合. 索引顺序文件中, 同样会为文件建立一张索引表, 但不同的是, 并不是每个记录都对应一个索引表, 而是一组记录对应一个索引表项 当记录过多的时候可以建立多级索引表 文件目录 文件控制块FCB 单级目录结构 早期的操作系统并不支持多级目录, 整个系统只建立一张目录表, 每个文件占一个目录项 单级目录实现了\"按名存取\", 但是不允许文件重名 单级目录不支持多用户操作系统 两级目录结构 早期的多用户操作系统采用两级目录结构, 分为主文件目录和用户文件目录. 多级目录结构 ( 树形目录结构 ) 理解 : 相对目录可以减少磁盘I/O操作次数 无环图目录结构 索引结点 ( FCB的改进 ) 将fcb除了文件名之外的所有信息放入索引结点存在外存, 只有找到对应的目录项时才将索引节点调入内存. 文件的物理结构 文件块和磁盘块 在内存管理中, 进程的逻辑地址空间被分为一个个的页面 同样的, 在外存管理中, 为了方便对文件数据的管理, 文件的逻辑地址空间也被分为了一个个的文件块 于是文件的逻辑地址也可以表示为 (逻辑块号, 块内地址)的形式 文件分配方式---连续分配 连续分配方式要求每个文件在磁盘上占有一组连续的块 操作系统可以直接算出逻辑块号对应的物理块号, 因此连续分配支持顺序访问和直接访问( 随机访问 ) 优点 : 连续分配的文件在顺序读/写时速度最快 缺点 : 采用连续分配的文件不方便拓展 存储利用率低, 会产生难以利用的磁盘碎片. ( 可以采用紧凑的方法来处理碎片, 但是需要耗费很大的时间代价 ) 文件分配方式---链接分配 隐式链接 采用隐式链接的链接分配方式, 很方便文件拓展 , 另外, 所有的空闲磁盘块都可以被利用, 不会有碎片问题, 外存利用率高 显式链接 文件分配方式---索引分配 文件离散地分配在各个磁盘块中, 系统为每个文件建立一张索引表, 索引表中记录了文件的各个逻辑块对应的物理块. 索引表存放的磁盘块称为索引块, 文件数据存放的磁盘块称为数据块 . 索引分配方式可以支持随机访问, 文件拓展也很容易实现, 但是索引表需要占用一定的存储空间 多层索引 K层索引访问一个数据块需要K+1次读磁盘操作 多层索引的各层索引大小不能超过一个磁盘块 会计算文件的长度 混合索引 混合索引是多种分配方式的结合 e.g. 一个文件的顶级索引表中既包含直接地址索引 , 又包含一级间接索引 ,还包含两级间接索引 ... 好处 : 对于小文件来说只需要很少的读磁盘操作 文件存储空间管理 空闲表法 空闲表记录空闲盘块号的起始地址和空闲块数 要求 : 连续的存储空间 如何分配磁盘块 : 与内存管理的动态分区类似, 为一个文件分配连续的存储空间. 同样可以采用首次适应 , 最佳适应 , 最坏适应等算法. 如何回收磁盘块 : 空闲链表法 空闲盘块链 空闲盘区链 位示图法 成组链接法 UNIX系统采用了成组链接法对空闲块进行管理 讲的很好的一篇图文结合博客 文件的基本操作 创建文件 使用 \"create系统调用\" 在外存中找到文件所需的时间 根据文件的存放路径的信息找到该目录对应的目录文件, 在目录中创建该文件对应的目录项 ( 目录项中包含了文件名, 文件在外存中的存放位置等信息 ) 删除文件 使用 \"delete系统调用\" 打开文件 打开文件表 读写指针 ：读 / 写操作进行到的位置记录 访问权限 : 只读 / 只写 / 可读可写.... 打开文件时不会把文件的数据直接读入内存 ( 读文件时才读入内存 ) 关闭文件 读文件, 写文件 文件共享 多个用户共享同一个文件, 意味着系统中只有 \"一份\" 文件数据 . 并且只要某个用户改了该文件的数据, 其他用户也可以看到文件数据的变化. 基于索引结点的共享方式 ( 硬链接 ) 删除 : 基于符号链的共享方式 ( 软连接 ) e.g. windows下的快捷方式 文件保护 口令保护 ( 口令放在系统中, 不太安全 ) 加密保护 ( 安全性高, 但加密 / 解密 需要耗费一定的时间 访问控制 文件系统的层次结构 e.g. Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/00-操作系统笔记/7. 磁盘.html":{"url":"roccoshi_note/00-操作系统笔记/7. 磁盘.html","title":"7. 磁盘","keywords":"","body":"7. 磁盘磁盘的结构磁盘, 磁道, 扇区数据的读写盘面, 柱面磁盘的分类磁盘调度算法 ( 寻道时间 )一次读 / 写操作所需要的时间先来先服务算法 FCFS最短寻找时间优先 SSTF扫描算法 SCAN ( 电梯算法 )总结减少磁盘 ( 延迟时间 ) 的办法交替编号错位命名磁盘地址结构的设计磁盘管理磁盘初始化磁盘的引导块坏块的管理7. 磁盘 磁盘的结构 磁盘, 磁道, 扇区 磁盘的表面由一些磁性物质组成, 可以用这些磁性物质来记录二进制数据 磁道 : 磁盘的盘面被划分成一个个磁道, 一个圈就是一个磁道 扇区 : 每一个磁道被划分成一个个扇区, 每个扇区就是一个个 \" 数据块 \", 各个扇区存放的数据量相同 ( 最内侧磁道上的扇区面积最小, 因此数据密度最大 ) 数据的读写 盘面, 柱面 如何根据地址读取一个块 : 磁盘的分类 根据磁头是否可以移动 : 活动头磁盘 固定头磁盘 根据盘片是否可以更换 : 固定盘磁盘 可换盘磁盘 磁盘调度算法 ( 寻道时间 ) 一次读 / 写操作所需要的时间 graph LR A[一次读/写操作所需要的时间]---B[寻道时间] A---C[延迟时间] A---D[传输时间] 寻找时间 (寻道时间) 在读 / 写数据之前, 把磁头移动到指定磁道所花的时间 启动磁头臂的时间 移动磁头的时间 延迟时间 通过旋转磁盘, 使磁头定位到目标扇区所需要的时间 传输时间 由磁盘读出 或 向磁盘写入数据所需要的时间 磁盘调度算法会直接影响寻道时间 先来先服务算法 FCFS 根据进程请求访问磁盘的先后顺序进行调度 最短寻找时间优先 SSTF ​ 可能产生 饥饿 现象 扫描算法 SCAN ( 电梯算法 ) SSTF算法产生饥饿的原因 : 磁头可能会在一个小区域内来回移动 SCAN : 只有磁头移动到最外侧磁道的时候才能往内移动, 移动到最内侧磁道的时候才能往外移动 LOOK调度算法 ( SCAN的改进 ) 在扫描算法的基础上增加 : 如果在磁头移动方向上已经没有别的请求, 就可以立即改变磁头移动方向 循环扫描算法 C-SCAN SCAN算法对于各个位置磁道的响应频率不平均, C-SCAN算法就是为了解决这个问题, 规定只有磁头朝特定方向移动时才处理磁道访问请求, 而返回时 直接快速移动至起始端而不处理任何情况 C-LOOK 调度算法 C-LOOK = C-SCAN + LOOK 总结 减少磁盘 ( 延迟时间 ) 的办法 延迟时间 : 把目标扇区转动到磁头下所花的时间 由于磁头读入一个扇区数据后需要一小段时间处理, 如果逻辑上相邻的扇区在物理上也相邻, 则读入几个连续的逻辑扇区, 可能需要很长的 \" 延迟时间 \". 交替编号 采用交替编号的策略, 让逻辑上相邻的扇区在物理上有一定的间隔, 可以使读取连续的逻辑扇区所需要的延迟时间更小 错位命名 将盘面之间的扇区不同样按顺序编号 而是使用0号盘面的1号扇区下是1号盘面的4号扇区....这样的方式 这样使得读取完磁盘块之后还有一段时间处理, 从而减少了延迟时间 磁盘地址结构的设计 采用 ( 柱面号, 盘面号, 扇区号 )--- 三维, 二维, 一维 磁盘管理 磁盘初始化 进行低级格式化 ( 物理格式化 ), 将磁盘的各个磁道划分为扇区, 一个扇区通常可分为头, 数据区, 尾三个部分. 管理扇区所需要的各种数据结构 ( 校验码等 )一般存放在头, 尾两个部分 将磁盘分区 , 每个分区由若干柱面组成 进行逻辑格式化, 创建文件系统. 包括创建文件系统的根目录, 初始化 磁盘的引导块 计算机开机时需要进行一系列初始化的工作, 这些初始化工作是通过执行初始化程序 (自举程序) 完成的. 初始化程序 ( 自举程序 ) 如果直接放在ROM中, 会很不方便, 因为ROM中的数据无法更改, 解决方法 : ROM中只存放很小的 \" 自举装入程序 \" 开机时计算机先运行 \" 自举装入程序 \", 通过执行该程序就可以找到引导块, 并将完整的\" 自举程序 \" 读入内存, 完成初始化 坏块的管理 对于简单的磁盘 ,可以在逻辑格式化时, 对磁盘进行坏块检查, 表明哪些扇区是坏扇区. 这种处理方式中, 坏块对操作系统不透明 对于复杂的磁盘 , 磁盘控制器 ( 磁盘设备内部的一个硬件部件 ) 会维护一个坏块链表. 在磁盘出厂前进行低级格式化时就将坏块链进行初始化. 会保留一些 \" 备用扇区 \" 用于替换坏块. 这种方案称为扇区备用 . 这种处理方式中, 坏块对操作系统透明. Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/00-操作系统笔记/8. 设备管理.html":{"url":"roccoshi_note/00-操作系统笔记/8. 设备管理.html","title":"8. 设备管理","keywords":"","body":"8. 设备管理IO设备IO控制器IO控制器的功能IO控制器的组成IO控制方式程序直接控制方式中断驱动方式DMA方式通道控制方式总结IO软件层次结构I/O核心子系统假脱机技术 ( SPOOLing )设备的分配与回收缓冲区管理缓冲区的概念缓冲区有什么作用 ?单缓冲双缓冲循环缓冲区缓冲池8. 设备管理 IO设备 I/O : Input / output I/O设备就是可以将数据输入到计算机或者可以接收计算机输出数据的外部设备， 属于计算机中的硬件部件 UNIX系统将外部设备抽象为一种特殊的文件， 用户可以使用与文件操作相同的方式对外部设备进行操作 Write : 向外部设备写出数据 Read : 向外部设备读入数据 IO设备的分类 IO控制器 CPU无法直接控制I/O设备的机械部件, 因此I/O设备还要有一个电子部件作为CPU和I/O设备机械部分之间的 \"中介\", 用于实现CPU对设备的控制 这个机械部件就是 I / O控制器, 又称设备控制器. CPU可控制I/O控制器, 又由I/O控制器来控制IO设备的机械部件 IO控制器的功能 接受和识别CPU发出的命令 向CPU报告设备的状态 数据交换 地址识别 IO控制器的组成 CPU与控制器的接口 : 用于实现CPU与控制器之间的通信, CPU通过控制线发出命令, 通过地址线指明要操作的设备, 通过数据线来取出输入数据, 或放入输出数据 IO逻辑 : 负责接收和识别CPU的各种命令, 并负责对设备发出命令 控制器与设备的接口 : 用于实现控制器与设备之间的通信 IO控制方式 程序直接控制方式 通过 轮询 实现 优点 : 实现简单. 缺点 : CPU的干预很频繁, 在IO操作开始之前, 完成之后都需要CPU的介入, 并且等待IO完成的过程中CPU需要不断地轮询检查, CPU长期处于\"忙等\" 状态, CPU利用率低 中断驱动方式 引入中断机制, 由于IO设备速度很慢, 因此在CPU发出读/写命令后, 可将等待IO的进程阻塞, 先切换到别的进程执行 CPU只需要在每次IO开始之前和完成之后介入, 解决了程序直接控制方式中CPU需要不停轮询的特点, CPU的利用率得到明显提升. 缺点 : 每个字在I/O设备与内存之间的传输都需要经过CPU, 而频繁的中断处理会消耗较多的CPU时间. DMA方式 与 \" 中断驱动方式 \" 相比, DMA方式有这样几个改进 : 数据的传送单位是 \" 块 \" 数据的流向是从设备直接放入内存, 或者从内存直接到设备, 不需要CPU作为中介 仅在传送一个或多个数据块的开始和结束时才需要CPU的干预 DMA控制器 : DMA的优缺点 : 通道控制方式 通道 : 一种硬件, 通道可以识别并执行一系列通道指令 总结 IO软件层次结构 设备驱动程序 : 直接涉及到硬件具体细节且与中断无关的操作 设备独立性软件 : 不涉及硬件且对各种设备都需要进行的管理工作 I/O核心子系统 I/O调度 : 比如磁盘调度 ( 先来先服务, SCAN, LOOK...) 设备保护 : UNIX中设备被看作文件, 每个设备也会有对应的FCB ( 文件控制块 ). 当用户请求访问某个设备时, 系统根据FCB中记录的信息来判断用户是否有相应的访问权限, 以此实现 \" 设备保护\" 的功能. 假脱机技术 ( SPOOLing ) 假脱机技术 ( SPOOLing技术 ) 是用软件的方式模拟脱机技术. SPOOLing系统的组成如下 : 独占式设备 : 只允许各个进程串行使用的设备 共享设备 : 允许多个进程 \" 同时 \" 使用的设备 打印机是一种 \" 独占式设备 \" , 但是可以用SPOOLing技术改造成 \" 共享设备 \" e.g. 共享打印机原理分析 设备的分配与回收 从进程运行的安全性上考虑, 设备分配有两种方式 : 安全分配方式 : 为进程分配一个设备后就将进程阻塞, 本次I/O完成后才将进程唤醒. 不安全分配方式 : 进程发出I/O请求后, 系统为其分配I/O设备, 进程可继续执行, 之后还可以发出新的I/O请求. 只有某个I/O请求得不到满足时才将进程阻塞. 安全分配方式破坏了死锁的\"请求与保持\"条件, 不会死锁, 但是对于一个进程来说, CPU和I/O设备只能串行工作 不安全分配方式下进程的计算任务和I/O任务可以并行处理, 使进程迅速推进, 但是可能发生死锁 设备分配管理中的数据结构 设备, 控制器, 通道之间的关系 : 设备控制表 ( DCT ) : 系统为每个设备配置一张DCT, 用于记录设备情况 控制器控制表 ( COCT ) : 系统根据COCT对控制器进行操作和管理 通道控制表 ( CHCT ) : 系统根据CHCT的信息对通道进行操作和管理 系统设备表 ( SDT ) : 记录了系统中全部设备的情况, 每个设备对应一个表目 设备分配的步骤 根据进程请求的物理设备名查找SDT 根据SDT找到DCT, 若设备忙碌则将进程PCB挂到设备等待队列中, 不忙碌则将设备分配给进程 根据DCT找到COCT, 若控制器忙碌则将进程PCB挂到控制器等待队列中, 不忙碌则将控制器分配给进程 根据COCT找到CHCT, 若通道忙碌则将PCB挂到通道等待队列中, 不忙碌则将通道分配给进程 只有设备, 控制器, 通道三者都分配成功时, 这次设备分配才算成功, 之后便可启动I/O设备进行数据传送 可改进处 : 第一步中,可以通过LUT ( 逻辑设备表 )实现逻辑设备名到物理设备名的映射, 用户编程时只需要使用逻辑设备名申请设备而不必记忆物理设备名. 缓冲区管理 缓冲区的概念 缓冲区是一个存储区域, 可以由专门的硬件寄存器组成, 也可以利用内存作为缓冲区. 使用硬件作为缓冲区的成本较高, 容量较小, 一般仅用在对速度要求非常高的场合. 比如联想寄存器 ( 快表 ) 就是硬件作为缓冲区 一般情况下, 更多的是利用内存作为缓冲区 缓冲区有什么作用 ? 缓和CPU与IO设备之间速度不匹配的矛盾 减少对CPU的中断频率, 放宽对CPU中断相应时间的限制 解决数据粒度不匹配的问题 提高CPU与IO设备之间的并行性 单缓冲 假设设备把缓冲区充满的时间为$T$ , CPU处理工作区数据的时间为$C$, 缓冲区向工作区传送的时间为$M$, 则采用单缓冲策略每处理一块数据平均耗时为 : >Max(C,T)+M> > Max(C,T) + M > >Max(C,T)+M> 双缓冲 循环缓冲区 缓冲池 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/":{"url":"roccoshi_note/01-计算机网络笔记/","title":"01-计算机网络笔记","keywords":"","body":"考纲考纲 1-10 11-19 20-23 24-25 RIP基于UDP BGP基于TCP OSPF基于IP Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/1. 物理层/":{"url":"roccoshi_note/01-计算机网络笔记/1. 物理层/","title":"1. 物理层","keywords":"","body":"物理层物理层 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/1. 物理层/1.1 码元 波特 速率 带宽.html":{"url":"roccoshi_note/01-计算机网络笔记/1. 物理层/1.1 码元 波特 速率 带宽.html","title":"1.1 码元 波特 速率 带宽","keywords":"","body":"1.1 码元, 波特, 速率, 带宽1.1 码元, 波特, 速率, 带宽 名词 解释 码元 M进制码元 : 有M种高低不同的信号波形 ( M种离散状态 ) 速率 分为 码元传输速率 和 信息传输速率 码元传输速率 : 单位是波特 ( baud ), 一波特表示每秒钟传输一个码元 信息传输速率 : 又叫比特率, 单位是比特/秒 ( bit/s ) 带宽 网络中一点到另一点所能通过的最高数据率 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/1. 物理层/1.2 奈奎斯特定理和香农定理.html":{"url":"roccoshi_note/01-计算机网络笔记/1. 物理层/1.2 奈奎斯特定理和香农定理.html","title":"1.2 奈奎斯特定理和香农定理","keywords":"","body":"1.2 奈奎斯特定理和香农定理奈奎斯特定理 :香农定理 :1.2 奈奎斯特定理和香农定理 奈奎斯特定理 : 在理想低通条件下, 为了避免码间串扰, 极限码元传输速率为 2W Baud , 其中W为信道带宽, 单位是HZ 理想低通信道下的极限数据传输率 = ( V是码元的种类数 ) 2W×log2V(b/s) 2W\\times \\log _2V\\,\\,\\left( b/s \\right) 2W×log​2​​V(b/s) 香农定理 : 信噪比 : 信噪比=信号平均功率噪声平均功率,常记为SN,并用分贝(db)作为度量单位 \\text{信噪比} = \\frac{\\text{信号平均功率}}{\\text{噪声平均功率}}, \\text{常记为} \\frac{S}{N}, \\text{并用分贝(db)作为度量单位} 信噪比=​噪声平均功率​​信号平均功率​​,常记为​N​​S​​,并用分贝(db)作为度量单位 信噪比(db)=10log10(SN) \\text{信噪比}(db) = 10 log _{10} (\\frac{S}{N}) 信噪比(db)=10log​10​​(​N​​S​​) 香农定理 : 在带宽有限且有噪声的信道中, 为不产生误差, 信息的数据传输速率的上限值为 : Wlog2(1+SN)(b/s) W\\log _2\\left( 1+\\frac{S}{N} \\right) (b/s) Wlog​2​​(1+​N​​S​​)(b/s) 香农定理和奈奎斯特定理都是限制了数据传输速率, 不同的是前者是无噪声条件下, 后者是有噪声条件下 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/1. 物理层/1.3 编码与调制.html":{"url":"roccoshi_note/01-计算机网络笔记/1. 物理层/1.3 编码与调制.html","title":"1.3 编码与调制","keywords":"","body":"1.3 编码与调制数字数据编码为数字信号数字数据调制为模拟信号模拟数据编码为数字信号1.3 编码与调制 数字数据编码为数字信号 1. 非归零编码---NRZ 高1低0, 编码易实现但是没有检错功能 2. 归零编码---RZ 信号电平在一个码元之内需要恢复到0的编码方式 3. 反向不归零编码 (NRZI) 信号电平翻转表示0, 信号电平不变表示1 4. 曼彻斯特编码 用间隔的高低电平表示0, 1 优点 : 具有自同步功能 缺点 : 曼彻斯特编码的频率要比NRZ高一倍，传输等量数据所需的带宽大一倍 5. 差分曼彻斯特编码 在曼彻斯特编码的基础上采用码间的同或异来表示0, 1 同1异0 6. 4B/5B编码 用5bit来表示4bit的数据, 编码效率80% 数字数据调制为模拟信号 方法 缩写 调幅 ( 幅移键控 ) 2ASK 调频 ( 频移键控 ) 2FSK 调相 ( 相移键控 ) 2PSK 调幅 + 调相 QAM 模拟数据编码为数字信号 抽样 f采>=2f信号最高频率 f _\\text{采} >= 2f _\\text{信号最高频率} f​采​​>=2f​信号最高频率​​ 量化 编码 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/1. 物理层/1.4 传输介质和物理层设备.html":{"url":"roccoshi_note/01-计算机网络笔记/1. 物理层/1.4 传输介质和物理层设备.html","title":"1.4 传输介质和物理层设备","keywords":"","body":"1.4 传输介质 物理层设备传输介质物理层设备中继器集线器1.4 传输介质 物理层设备 传输介质 导向性传输介质 非导向性传输介质 导向性传输介质 : 双绞线 --- 可以传输模拟和数字信号 ( 有屏蔽双绞线STP, 无屏蔽双绞线UTP ) 同轴电缆 --- 只能传输数字信号 光纤 物理层设备 中继器 由于存在损耗, 在线路上传输的信号功率会逐渐衰减, 衰减到一定程度时会造成信号失真, 导致接收错误 中继器对信号进行再生和还原, 对衰减的信号进行放大, 保持与原数据相同, 以增加信号传输的距离, 延长 网络的长度 集线器 集线器对信号进行再生放大转发, 对衰减的信号进行放大, 接着转发到其他所有处于工作状态的端口上, 以增加信号传输的距离, 延长网络的长度 集线器不具备信号的定向传送能力, 是一个共享式设备 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/","title":"2. 数据链路层","keywords":"","body":"数据链路层数据链路层 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.5 流量控制和可靠传输/":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.5 流量控制和可靠传输/","title":"2.5 流量控制和可靠传输","keywords":"","body":"流量控制与可靠传输流量控制的方法---自动重传请求( ARQ )流量控制与可靠传输 关于数据链路层和传输层的流量控制手段 : 数据链路层的流量控制手段 : 接收方收不下就不回复确认 传输端的流量控制手段 : 接收端给发送端一个窗口公告 可靠传输的解释 : 发送端发送的内容接收端要确保收到 流量控制的解释 : 控制发送速率, 使接收方有足够的缓冲空间来接收每一个帧 流量控制的方法---自动重传请求( ARQ ) 自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。 停止-等待ARQ协议 每发送完一个帧就停止发送, 等待对方的确认, 在收到确认后再发送下一个帧 发送窗口大小 = 1, 接收窗口大小 = 1 滑动窗口协议 后退N帧ARQ协议 ( GBN ) 发送窗口大小 > 1, 接收窗口大小 = 1 选择重传ARQ协议 ( SR ) 发送窗口大小 > 1, 接收窗口大小 > 1 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.5 流量控制和可靠传输/2.5.1 停止-等待协议.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.5 流量控制和可靠传输/2.5.1 停止-等待协议.html","title":"2.5.1 停止-等待协议","keywords":"","body":"2.5.1 停止-等待协议停止等待协议的性能分析2.5.1 停止-等待协议 每发送完一个帧就停止发送, 等待对方的确认, 在收到确认后再发送下一个帧 当数据帧丢失或者检测到帧出错 RTT : 往返时延 (Round-trip delay time ) 帧一去 + 一回 = 1个RTT 一般采用超时计时器的方式, 每次发送一个帧就启动一次计时器, 当计时器到时间没有收到确认就再发送一次, 计时器的时间设置要大于RTT 注意 : 发完一个帧后需要保留副本 数据帧和确认帧必须编号 当ACK丢失 ack丢失后会触发超时重传机制, 由于数据帧有编号, 所以接收方收到第二次同编号数据帧时会重传确认帧并丢弃重复的帧 当ACK迟到 由于1帧已经发送, 0帧的确认收到后不做处理, 直接丢弃即可 停止等待协议的性能分析 优点 : 简单 缺点 : 信道利用率太低 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.5 流量控制和可靠传输/2.5.2 后退N帧协议GBN.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.5 流量控制和可靠传输/2.5.2 后退N帧协议GBN.html","title":"2.5.2 后退N帧协议GBN","keywords":"","body":"2.5.2 后退N帧协议GBN后退N帧协议中的滑动窗口累计确认超时事件接收方要做的事滑动窗口的长度例题GBN的性能分析优点不足2.5.2 后退N帧协议GBN 后退N帧协议中的滑动窗口 发送窗口 : 大小>1 接收窗口 : 大小=1 接收窗口收到帧后发送一个ack, 发送窗口收到这个ack后向前滑动一格 累计确认 在GBN协议中, 对n号帧采用累积确认的方式, 表明接收方已经收到n号帧以及它之前的全部帧 注意 : 帧的编号是循环的如 0 1 2 3 0 1 2 3 0 1...... 超时事件 在GBN协议中, 如果出现超时, 发送方将重传所有已发送但未被确认的帧 接收方要做的事 当正确收到了n号帧 ( 按序 ) : 为n号帧发送一个ACK (累计确认), 并且将该帧中的数据部分发送给上层 其余情况 : 均丢帧 , 并为最近按序接收的所有帧重新发送ACK, 接收方无需缓存任何失序帧, 只需要维护一个信息---预期下一个按序接收的帧序号 滑动窗口流程 滑动窗口的长度 若采用n个比特对帧编号, 那么滑动窗口发送的尺寸应当满足 1=WT=2n−1 1 1=W​T​​=2​n​​−1 因为如果滑动窗口尺寸过大, 就会使得接收方无法取别新帧和旧帧 比如用2个bit对帧编号, 则帧为0 1 2 3 0 1 2 3 .... 那么滑动窗口的大小这时候应该是 1~3 , 若更大则无法取别新帧和旧帧 例题 例题 GBN的性能分析 优点 因连续发送数据帧而提高了信道的利用率 不足 在重传时必须把原来已经正确传送的数据帧重传, 使得传输效率降低 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.5 流量控制和可靠传输/2.5.3 选择重传协议SR.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.5 流量控制和可靠传输/2.5.3 选择重传协议SR.html","title":"2.5.3 选择重传协议SR","keywords":"","body":"2.5.3 选择重传协议SR选择重传协议中的滑动窗口发送方接收方运行中的SR流程滑动窗口长度总结与例题例题 :2.5.3 选择重传协议SR preview : GBN采用累计确认 + 批量重传的方式, 导致接收方会在某一帧出错时丢弃后面大量未出错的帧, 那么是否有一种方法可以只重传出错的帧 ? 解决方法 : 设置单个确认, 同时加大接收窗口, 设置接收缓存, 缓存乱序到达的帧 选择重传协议中的滑动窗口 发送方和接收方的窗口 发送方 此时下界移动到2号, 同时发送5号帧 接收方 来者不拒的接收方 运行中的SR流程 模拟SR的运行 滑动窗口长度 发送窗口一般 = 接收窗口, 大小为 : WTmax=WRmax=2n−1 W_\\text{Tmax} = W_\\text{Rmax} = 2^{n-1} W​Tmax​​=W​Rmax​​=2​n−1​​ 总结与例题 对数据帧逐一确认, 收一个确认你一个 只重传出错帧 接收方有缓存 窗口长度最大为2n−12^{n-1}2​n−1​​ 例题 : 例题 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/","title":"2.6 介质访问控制","keywords":"","body":"介质访问控制传输数据使用的两种链路介质访问控制静态划分信道---信道划分介质访问控制动态分配信道介质访问控制 传输数据使用的两种链路 点对点链路 : 两个相邻结点通过一个链路相连, 没有第三者 应用 : PPP协议, 常用于广域网 广播式链路 : 所有主机共享通信介质 应用 : 早期的总线以太网和无线局域网, 常用于局域网 典型拓扑结构 : 总线型, 星型 介质访问控制 介质访问控制的内容就是, 采取一定的措施, 使得两对节点之间的通信不会发生相互干扰的情况 静态划分信道---信道划分介质访问控制 频分多路复用FDM ( Frequency-division multiplexing ) 时分多路复用TDM ( Time-division multiplexing ) 码分多路复用CDM ( Code-division multiplexing) 波分多路复用WDM ( Wavelength-division multiplexing ) 动态分配信道 轮询访问介质访问控制 轮询协议 令牌传递协议 随机访问介质访问控制 ALOHA协议 CSMA协议 CSMA/CD协议 CSMA/CA协议 三种方式的对比总结 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.1 信道划分介质访问控制.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.1 信道划分介质访问控制.html","title":"2.6.1 信道划分介质访问控制","keywords":"","body":"2.6.1 信道划分介质访问控制多路复用技术频分多路复用FDM时分多路复用TDM波分多路复用WDM码分多路复用CDM2.6.1 信道划分介质访问控制 信道划分介质访问控制的概念 : 将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开, 把时域和频域资源合理地分配给网络上的设备 多路复用技术 把多个信号组合在一条物理信道上进行传输, 使得多个计算机或终端设备共享信道资源, 提高信道利用率 多路复用技术和共享信道 频分多路复用FDM 用户在分配到一定的频带后, 在通信过程中自始至终都占用这个频带 频分复用的所有用户在同样的时间占用不同的带宽 ( 频率带宽 ) 资源 FDM 频分多路复用充分利用传输介质带宽, 系统效率较高, 实现也比较容易 时分多路复用TDM 将时间划分为一段段等长的时分复用帧, 每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙, 所有用户轮流占用信道 TDM FDM可以类比为\"并行\" TDM可以类比为\"并发\" 波分多路复用WDM 波分多路复用就是\"光的频分多路复用\", 在一根光纤中传输多种不同波长 (频率) 的光信号, 由于波长 ( 频率 )不同, 所以各路光信号互不干扰, 最后再用波长分解复用器将各路波长分解出来 WDM 码分多路复用CDM 码分多址(CDMA)是码分复用的一种方式 ( 注意不要和CSMA搞混了 ) 码分多路复用的过程 : 一个比特分为多个码片(chip), 每一个站点被指定一个唯一的m位的码片序列 当发送比特'1'时发送码片序列, 发送'0'时发送码片序列的反码 如何在同一信道中不相互冲突 : 多个站点同时发送数据时, 要求各个站点的码片序列相互正交 合并过程 : 各路数据在信道中线性相加 分离过程 :合并的数据与源站码片进行规格化内积 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.2 ALOHA协议.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.2 ALOHA协议.html","title":"2.6.2 ALOHA协议","keywords":"","body":"2.6.2 ALOHA协议纯ALOHA协议时隙ALOHA协议2.6.2 ALOHA协议 纯ALOHA协议 思想 : 不监听信道, 不按时间槽发送, 随机重发, 想发就发 冲突检测 : 如果发生冲突, 接收方就会检测出差错, 然后不予确认, 发送方在一定时间内收不到就会判断发生了冲突 冲突解决 : 超时后等待一段随机时间再重传 时隙ALOHA协议 思想 : 把时间分成若干个相同的时间片, 所有用户在时间片开始时刻同步接入网络信道, 若发生冲突, 则必须等到下一个时间片开始时刻再发送 纯ALOHA协议比时隙ALOHA吞吐量更低, 效率也更低 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.3 CSMA协议.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.3 CSMA协议.html","title":"2.6.3 CSMA协议","keywords":"","body":"2.6.3 CSMA协议1-坚持CSMA非坚持CSMAp-坚持CSMA2.6.3 CSMA协议 CSMA : 载波监听多路访问协议 ( carrier sense multiple access) CS : 当几个站同时在发送数据时, 总线上的「电压摆动值」将会增大, 当一个站检测到电压摆动值超过一定的门限值时, 就认为总线上有几个站同时在发送数据, 表明产生了冲突 MA : 多点接入, 表示许多计算机以多点接入的方式连接在一根总线上 协议思想 : 发送帧之前, 监听信道 3种CSMA协议 1-坚持CSMA 思想 : 如果一个主机要发送消息, 那么它先监听信道, 如果信道空闲则直接传输, 不必等待, 如果信道忙则一直监听, 直到空闲马上传输. 如果有冲突, 则等待一个随机长的时间再监听, 重复上述过程 优点 : 信道空闲则可以马上发送数据, 避免了信道利用率的损失 缺点 : 如果有两个或两个以上的站点有数据要发送, 冲突则不可避免 非坚持CSMA 思想 : 如果一个主机要发送消息, 那么它先监听信道, 如果信道空闲则直接传输, 不必等待, 如果信道忙则等待一个随机时间之后再监听 优点 : 采用随机重发延迟时间可以减少冲突发生的可能性 缺点 : 大家可能都在延迟等待的过程中, 使得信道空闲时无数据传输, 信道使用率降低 p-坚持CSMA 思想 : 如果一个主机要发送消息, 那么它先监听信道, 如果信道空闲则以p概率直接传输, 以1-p概率等待到下一个时间槽再传输 1-坚持CSMA就是p=1的p-坚持CSMA 优点 : 综合了1-坚持CSMA和非坚持CSMA的特点 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.4 CSMACD协议.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.4 CSMACD协议.html","title":"2.6.4 CSMACD协议","keywords":"","body":"2.6.4 CSMA/CD协议传播时延对载波监听的影响如何确定碰撞后的重传时机截断二进制指数规避算法最小帧长问题2.6.4 CSMA/CD协议 CSMA/CD : 载波监听多路访问/碰撞检测 ( carrier sense multiple access with collision detection ) CS : 当几个站同时在发送数据时, 总线上的「电压摆动值」将会增大, 当一个站检测到电压摆动值超过一定的门限值时, 就认为总线上有几个站同时在发送数据, 表明产生了冲突 MA : 多点接入, 表示许多计算机以多点接入的方式连接在一根总线上 --- \"总线型网络\" 总线网络 CD : 碰撞检测, 即「边发送边监听」, 适配器边发送数据边检测信道上信号电压的变化情况, 以便判断自己在发送数据时其他站是否也在发送数据 --- \"半双工网络\" 传播时延对载波监听的影响 由于在总线型网络中, 每一台工作站都会收到整个总线的网络流量, 所以碰撞检测的原理就是当自己在发出数据帧后的 (2*传播时延t ) 内收到了来自别的主机的数据帧, 则说明发生了碰撞 如何确定碰撞后的重传时机 截断二进制指数规避算法 截断二进制指数规避算法 流程 最小帧长问题 由于CSMA/CD存在的意义就是在冲突检测到后及时停止帧的发送, 如果存在检测到冲突时帧已发送完毕的情况则CSMA/CD无意义 所以帧的传输时延至少要两倍于信号在总线中的传播时延 即 : 帧长数据传输速率⩾2τ \\frac{\\text{帧长}}{\\text{数据传输速率}}\\geqslant 2\\tau ​数据传输速率​​帧长​​⩾2τ 最小帧长 : 最小帧长=2τ×数据传输速率 \\text{最小帧长}=2\\tau \\times \\text{数据传输速率} 最小帧长=2τ×数据传输速率 ( 以太网规定最短帧长为64B, 小于64B均为无效帧 ) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.5 CSMACA协议.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.5 CSMACA协议.html","title":"2.6.5 CSMACA协议","keywords":"","body":"2.6.5 CSMA/CA协议适用场景工作原理CSMA/CD 和 CSMA/CA的对比2.6.5 CSMA/CA协议 CSMA/CA : 载波监听多路访问/碰撞避免 ( carrier sense multiple access with collision avoidance ) 适用场景 名称 适用场景 CSMA/CD 总线式以太网 CSMA/CA 无线局域网 工作原理 在发送数据前, 先检测信道是否空闲 如果信道空闲则发出RTS ( request to send ), RTS包括发送端的地址 接收端的地址 下一份数据将持续发送的时间 等信息 信道忙则等待 接受收到RTS后, 将响应CTS ( clear to send ). 发送端收到CTS后, 开始发送数据 ( 同时预约信道 : 告诉其他站点自己要传输多久的数据 ) 接收端收到数据帧后, 将用CRC来检验数据是否正确, 如果正确则响应ACK帧 发送端如果收到了ACK帧就进行下一个数据帧的发送, 如果没有就一直重传数据帧 CSMA/CD 和 CSMA/CA的对比 CSMA/CD 和 CSMA/CA的对比 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.6 轮询访问介质访问控制.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.6 轮询访问介质访问控制.html","title":"2.6.6 轮询访问介质访问控制","keywords":"","body":"2.6.6 轮询访问介质访问控制轮询协议令牌传递协议2.6.6 轮询访问介质访问控制 轮询协议 主结点轮流「邀请」从属结点发送数据 主结点与从属结点 问题 : 轮询开销 等待延迟 单点故障 ( 主结点出故障, 则系统故障 ) 令牌传递协议 令牌 : 一个特殊格式的mac控制帧, 不包含任何信息, 控制信道的使用, 确保同一时刻只有一个结点独占信道 令牌环网 每个结点都可以在一定的时间内 ( 令牌持有时间 ) 获得发送数据的权利, 并不是无限制地持有令牌 问题 : 令牌开销 等待延迟 单点故障 采用令牌传递方式的网络常用于负载较重且通信量较大的网路中 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.1 数据链路层基本概念和功能.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.1 数据链路层基本概念和功能.html","title":"2.1 数据链路层基本概念和功能","keywords":"","body":"2.1 数据链路层基本概念和功能数据链路层的基本概念数据链路层的功能概述2.1 数据链路层基本概念和功能 数据链路层的基本概念 名词 解释 结点 主机, 路由器 链路 网络中两结点间的物理通道 数据链路 网络中两结点间的逻辑通道 帧 链路层的协议数据单元, 封装网络层数据报 数据链路层的功能概述 为网络层提供服务 ( 无确认无连接服务 有确认无连接服务 有确认有连接服务 ) 链路管理 ( 链接的建立, 维持, 释放 ) 组帧 流量控制 差错控制 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.2 封装成帧的几种方法.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.2 封装成帧的几种方法.html","title":"2.2 封装成帧的几种方法","keywords":"","body":"2.2 封装成帧的几种方法一. 字符计数法二. 字符填充法三. 零比特填充法四. 违规编码法2.2 封装成帧的几种方法 组帧的几个方案 : 一. 字符计数法 二. 字符填充法 上述方法法的劣势 : 解决方法 : 三. 零比特填充法 四. 违规编码法 目前普遍使用的方法是比特填充法和违规编码法 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.3 检错编码--CRC 奇偶校验码.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.3 检错编码--CRC 奇偶校验码.html","title":"2.3 检错编码--CRC 奇偶校验码","keywords":"","body":"2.3 检错编码: CRC冗余循环校验码 奇偶校验码差错的种类检错编码循环冗余校验码CRC奇偶校验码2.3 检错编码: CRC冗余循环校验码 奇偶校验码 差错的种类 检错编码 循环冗余校验码CRC 核心公式 : 发送端数据÷生成多项式=X⋯⋯CRC校验码 \\text{发送端数据} \\div \\text{生成多项式} = X \\cdots \\cdots \\text{CRC校验码} 发送端数据÷生成多项式=X⋯⋯CRC校验码 生成多项式 : 生成多项式G(x)=X4+X2+1等价于10101 \\text{生成多项式} G(x) = \\text{X}^4+\\text{X}^2+1 \\text{等价于10101} 生成多项式G(x)=X​4​​+X​2​​+1等价于10101 CRC的工作过程 : CRC的校验 : 把余数加到发送端数据上组成要发送的信息M, 校验时M应当被G(x)严格整除, 如果除不尽, 余数指明出错位所在的位置 CRC 例 例题 : 生成多项式的阶数r = 4 , 在发送的数据后添4个0, 使之成为11010110110000 计算模2除法 ( 异或 ) 取余数为CRC校验码 奇偶校验码 奇校验码 : 在编码的最后一位添1或0使得整个编码中1的出现个数为奇数 偶校验码 : 在编码的最后一位添1或0使得整个编码中1的出现个数为偶数 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.4 纠错编码--海明码.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.4 纠错编码--海明码.html","title":"2.4 纠错编码--海明码","keywords":"","body":"2.4 纠错编码: 海明码海明距离最小海明距离使用海明码的步骤海明不等式----确定校验码的位数r确定校验码的位置求出校验码的值检错与纠错2.4 纠错编码: 海明码 海明码的功能 : 发现双比特错, 纠正单比特错 海明距离 海明距离 最小海明距离 检测k位错 : 海明距离 ≥ k + 1 纠正k位错 : 海明距离 ＞2k + 1 使用海明码的步骤 海明不等式----确定校验码的位数r 2r⩾k+r+1(k为数据位数,r为冗余位数) 2^{\\text{r}}\\geqslant \\text{k}+\\text{r}+1 \\left( \\text{k为数据位数}, \\text{r为冗余位数} \\right) 2​r​​⩾k+r+1(k为数据位数,r为冗余位数) 确定校验码的位置 将第x位校验码填入2的x-1次方的位置, 举例如下 : 求出校验码的值 注意 : 二进制从0001也就是1开始 检错与纠错 方法 : 将各个位按上述规则异或处理后组成一个二进制数, 如果有差错, 则组成的二进制数表示差错所在的数据位. 注意 : 上述规则的海明码只能发现并纠正一位错, 如果要实现发现二位错的功能, 还需要在最后一位加上奇偶校验位. 如下 : Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.7 局域网.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.7 局域网.html","title":"2.7 局域网","keywords":"","body":"2.7 局域网局域网局域网拓扑结构局域网介质访问控制方法局域网的分类IEEE802标准MAC子层和LLC子层以太网以太网标准10BASE-T以太网适配器与mac地址以太网mac帧高速以太网无线局域网IEEE 802.112.7 局域网 局域网 局域网 ( Local Area Network) : 简称LAN, 是指在某一区域内由多台计算机互联组成的计算机组, 使用广播信道 局域网的几个特点 : 覆盖的地理范围较小, 只在一个相对独立的局部范围内联, 如集中的建筑内 使用专门铺设的传输介质 ( 双绞线, 同轴电缆 ) 进行联网, 数据传输速率高 ( 10Mb/s - 10Gb/s ) 通信延迟时间短, 误码率低, 可靠性较高 各站为平等关系, 共享传输信道 多采用分布式控制和广播式通信, 能进行广播和组播 要素 : 网络拓扑 传输介质 介质访问控制方法 局域网拓扑结构 局域网拓扑结构 局域网介质访问控制方法 CSMA/CD -- 总线型局域网 令牌总线 -- 总线型局域网 令牌环 -- 环形局域网 局域网的分类 以太网 --- 应用最为广泛的局域网, 包括标准以太网, 快速以太网, 千兆以太网和10G以太网, 他们都符合IEEE802.3系列标准规范. 逻辑拓扑总线型, 物理拓扑是星型或是拓展星形. 使用CSMA/CD 令牌环网 --- 物理上采用星型拓扑, 逻辑上是环形拓扑, 造价高, (已被淘汰) FDDI网 --- 物理上采用了双环拓扑结构, 逻辑上是环形拓扑结构 ATM网 --- 较新型的单元交换技术, 使用53字节固定长度的单元进行交换 无线局域网 --- WLAN, 采用IEEE802.11标准 IEEE802标准 IEEE802 MAC子层和LLC子层 IEEE802标准所描述的局域网参考模型只对应OSI参考模型的数据链路层与物理层, 它将数据链路层划分为逻辑链路层LLC子层和介质访问控制层MAC子层 MAC子层和LLC子层 以太网 以太网 --- 应用最为广泛的局域网, 包括标准以太网, 快速以太网, 千兆以太网和10G以太网, 他们都符合IEEE802.3系列标准规范. 逻辑拓扑总线型, 物理拓扑是星型或是拓展星形. 使用CSMA/CD 以太网的优势 : 造价低廉 ( 以太网网卡不到100元 ) 是应用最广泛的局域网技术 比令牌环网, ATM网便宜与简单 满足网络速率要求 : 10Mb/s - 10Gb/s 以太网标准 DIX Ethernet V2 : 第一个局域网产品规约 IEEE802.3 : IEEE 802委员会802.3工作组指定的第一个IEEE的以太网标准 10BASE-T以太网 10BASE-T以太网是传送基带信号的双绞线以太网, T表示采用双绞线, 现10BASE-T采用的是无屏蔽双绞线, 传输速率是10Mb/s 物理上星型拓扑, 逻辑上总线型, 每段双绞线最长为100m 采用曼彻斯特编码 采用CSMA/CD介质访问控制 适配器与mac地址 适配器与mac地址 以太网mac帧 最常用的mac帧是以太网v2的格式 以太网v2 mac帧 FCS : CRC校验码 高速以太网 高速以太网 无线局域网 IEEE 802.11 IEEE 802.11 是无线局域网通用的标准, 它是由IEEE所定义的无线网络的通用标准, mac子层采用CSMA/CA 802.11的帧头格式 802.11的帧头格式 发送端和接收端--无线接入点 ( 基站 ) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.8 广域网PPP协议HDLC协议.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.8 广域网PPP协议HDLC协议.html","title":"2.8 广域网PPP协议HDLC协议","keywords":"","body":"2.8 广域网PPP协议和HDLC协议广域网PPP协议ppp协议的三个组成部分HDLC协议HDLC的「站」HDLC的帧格式总结2.8 广域网PPP协议和HDLC协议 广域网 广域网通常跨接很大的物理范围, 所覆盖的范围从几十公里到上千公里, 它能连接多个城市和国家, 或横跨几个洲并能提供远距离通信, 形成国际性的远程网络 广域网的通信子网通常采用「分组交换」技术, 广域网的通信子网可以利用公用分组交换网, 卫星通信网和无线分组交换网, 它将分布在不同地区的局域网或计算机系统互连起来, 达到资源共享的目的, 如因特网是世界范围内最大的广域网 广域网 PPP协议 点对点协议（Point to Point Protocol，PPP）为在点对点连接上传输多协议数据包提供了一个标准方法。 PPP 最初设计是为两个对等节点之间的IP 流量传输提供一种封装协议。 PPP协议的「特点」 : 简单 : 对于链路层的帧, 无需纠错, 无需编号, 无需流量控制 封装成帧 : 帧定界符 透明传输 : 与帧定界符一样的比特组合的数据应该如何处理, 异步线路用字节填充, 同步线路用比特填充 多种网络层协议 多种类型链路 : 同步/异步 串行/并行 差错检测 : 错就丢弃 检测连接状态 最大传送单元MTU 网络层地址协商 : 知道通信双方的网络层地址 数据压缩协商 ppp协议的三个组成部分 一个将ip数据报封装到串行链路的方法 「链路控制协议LCP」: 建立并维护数据连接 ( 身份验证 ) 「网络控制协议NCP」: 为网络层协议建立和配置逻辑连接 PPP协议的帧格式 HDLC协议 高级数据链路控制（HDLC，High-level Data Link Control）是一组用于在网络结点间传送数据的协议，是由国际标准化组织（ISO）颁布的一种高可靠性、高效率的数据链路控制规程，其特点是各项数据和控制信息都以比特为单位，采用“帧”的格式传输 。 HDLC的数据报文可透明传输, 用「零比特插入法」实现透明传输 采用全双工通信 所有帧采用CRC校验, 对信息帧进行顺序编号, 传输可靠性高 HDLC的「站」 主站, 从站和复合站 HDLC的帧格式 HDLC帧 总结 PPP HDLC 通信链路 全双工 全双工 透明传输 字节填充, 比特填充 比特填充 差错检测 检测但不纠正 检测但不纠正 可靠性 不可靠 可靠 编号和确认机制 无编号有确认机制 有编号有确认机制 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.9 链路层设备--网桥交换机.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.9 链路层设备--网桥交换机.html","title":"2.9 链路层设备--网桥交换机","keywords":"","body":"2.9 链路层设备--网桥交换机冲突域冲突域和广播域网桥网桥分类交换机---多接口网桥2.9 链路层设备--网桥交换机 冲突域 在以太网中，如果某个CSMA/CD网络上的两台计算机在同时通信时会发生冲突，那么这个CSMA/CD网络就是一个冲突域（collision domain)。 如果以太网中各个网段以集线器连接，因为不能避免冲突，所以它们仍然是一个冲突域。 冲突域就是同一时间链路上只能有一个主机传送信息, 一个集线器下是一个冲突域, 冲突域之前通过主干集线器相连, 组成了一个更大的冲突域 冲突域和广播域 冲突域和广播域的对比 考点 : 冲突域和广播域的数量判断问题 如果一个路由器都没有, 就是一个广播域, 然后看网桥和交换机隔离出来的冲突域, 有几条线连上网桥/交换机就有几个冲突域 e.g. 例题 : 冲突域广播域数量判断 网桥 网桥根据mac帧的目的地址对帧进行转发和过滤, 当网桥收到一个帧时, 它并不向所有接口转发此帧, 而是先检查此帧的目的mac地址, 然后再确定将该帧转发到哪一个接口, 或者是把它丢弃 ( 过滤 ) 网桥 网段 网桥优点 : 过滤通信量, 增大吞吐量 扩大了物理范围 提高了可靠性 可以互联不同物理层, 不同mac子层和不同速率的以太网 网桥分类 1. 透明网桥 「透明」指以太网上的站点并不知道所发送的帧将经过哪几个网桥, 是一种即插即用的设备 通过建立「转发表」---自学习转发数据帧 ( 转发表相当于缓存 ) 网桥在转发数据帧时, 首先查找转发表, 如果转发表不存在对应的记录, 则记录当前地址+接口到转发表, 下次转发时直接从转发表调取记录, 会大大加快速度 转发表会在几分钟内更新, 不是一直不变的, 保证了动态性 透明网桥 转发表 2. 源路由网桥 源路由网桥 : 在发送帧时, 把详细的「最佳路由信息」( 路由最少/时间最短 ) 放在帧的首部 方法 : 源站以广播方式向欲通信的目的站发送一个「发现帧」, 返回的一条最短的路由就是\"最佳路由信息\" ( 类似bfs, dfs ) 交换机---多接口网桥 直通式交换机 : 查完目的地址就立刻转发 延迟小, 可靠性低, 无法支持具有不同速率的端口的交换 存储转发式交换机 : 将帧放入高速缓存, 并检查是否正确, 正确则转发, 错误则丢弃 延迟大, 可靠性高, 可以支持具有不同速率的端口的交换 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/","title":"3. 网络层","keywords":"","body":"网络层网络层的功能网络层 网络层的主要任务是把分组从源端传到目的端, 为分组交换网上的不同主机提供通信服务, 网络层的传输单位是数据报 网络层的功能 路由选择与分组转发 异构网络互连 拥塞控制 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.12 路由算法和路由协议/":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.12 路由算法和路由协议/","title":"3.12 路由算法和路由协议","keywords":"","body":"3.12 路由算法和路由协议路由表路由算法的分类路由协议的分类3.12 路由算法和路由协议 路由表 路由表 路由算法的分类 路由算法分类 路由协议的分类 路由选择协议 不同的自治系统内部协议可以不同, 自治系统之间使用外部网关协议 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.12 路由算法和路由协议/3.12.1 RIP协议和距离向量算法.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.12 路由算法和路由协议/3.12.1 RIP协议和距离向量算法.html","title":"3.12.1 RIP协议和距离向量算法","keywords":"","body":"3.12.1 RIP协议和距离向量算法RIP协议RIP的过程RIP的报文格式RIP中路由表的更新例题RIP的特点---好消息传的快 坏消息传得慢3.12.1 RIP协议和距离向量算法 RIP(Routing Information Protocol,路由信息协议）是一种内部网关协议（IGP），是一种动态路由选择协议，用于自治系统（AS）内的路由信息的传递。 RIP协议基于距离矢量算法（DistanceVectorAlgorithms），使用“跳数”(即metric)来衡量到达目标地址的路由距离。 RIP协议 RIP RIP的过程 仅和相邻路由器交换信息 路由器交换的信息是自己的路由表 每30秒交换一次路由信息, 然后路由器根据新信息更新路由表. 如果超过180s没有收到邻居路由器的通告, 则判定邻居没了, 并更新自己的路由表 经过若干次更新后, 所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址, 即「收敛」 RIP的报文格式 RIP采用UDP RIP中路由表的更新 路由表的更新过程 例题 例题1 例题2 RIP的特点---好消息传的快 坏消息传得慢 当网络出现故障时, RIP需要经过比较长的时间才能将信息传达到所有的路由器 --- \"慢收敛\" 坏消息传得慢 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.12 路由算法和路由协议/3.12.2 OSPF协议和链路状态算法.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.12 路由算法和路由协议/3.12.2 OSPF协议和链路状态算法.html","title":"3.12.2 OSPF协议和链路状态算法","keywords":"","body":"3.12.2 OSPF协议和链路状态算法OSPF的流程OSPF的区域OSPF分组OSPF的特点3.12.2 OSPF协议和链路状态算法 开放式最短路径优先（英语：Open Shortest Path First，缩写为 OSPF）是一种基于IP协议的路由协议。它是大中型网络上使用较为广泛的IGP协议。OSPF是对链路状态路由协议的一种实现，运作于自治系统内部。 OSPF 特点 : 洪泛法---广播 建立全网拓扑图 OSPF的流程 OSPF过程 OSPF的区域 OSPF的区域 OSPF分组 OSPF直接采用IP数据报 OSPF的特点 每隔30min刷新一次数据库的链路状态 当互联网规模很大时, OSPF协议要比距离向量协议好得多 OSPF不存在坏消息传得慢的问题, 它的收敛速度很快 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.12 路由算法和路由协议/3.12.3 BGP协议.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.12 路由算法和路由协议/3.12.3 BGP协议.html","title":"3.12.3 BGP协议","keywords":"","body":"3.12.3 BGP协议BGP的过程BGP报文BGP协议的特点4种BGP-4报文3.12.3 BGP协议 BGP BGP的过程 BGP交换信息的过程 BGP报文 BGP协议采用TCP传送 BGP协议的特点 BGP支持CIDR 在BGP刚运行时, BGP的邻站是交换整个的BGP路由表, 但是之后只需要在发生变化时更新即可. 节省了网络带宽和路由器处理开销 4种BGP-4报文 BGP的4种报文类型 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.12 路由算法和路由协议/3.12.4 三种路由协议的对比.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.12 路由算法和路由协议/3.12.4 三种路由协议的对比.html","title":"3.12.4 三种路由协议的对比","keywords":"","body":"3.12.4 三种路由协议的对比3.12.4 三种路由协议的对比 使用的传输协议 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.01 数据交换方式.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.01 数据交换方式.html","title":"3.01 数据交换方式","keywords":"","body":"3.1 数据交换方式3.1.1 电路交换电路交换的阶段电路交换的优/缺点3.1.2 报文交换3.1.3 分组交换比较总结3.1 数据交换方式 3.1.1 电路交换 电路交换举例: 电话网络 电路交换的阶段 建立连接 ( 电路建立 ) 通信 释放连接 ( 电路拆除 ) 特点 :「独占资源」 电路交换的优/缺点 优点 : 通信时延小 有序传输 没有冲突 实时性强 缺点 : 建立连接时间长 线路独占, 使用效率低 灵活性差 无差错控制能力 ( 没有检错和纠错 ) 3.1.2 报文交换 报文交换 报文 : 源应用发送的「信息整体」 优点 : 无需建立连接 存储转发, 动态分配线路 线路可靠性较高 线路利用率较高 多目标服务 缺点 : 有存储转发时延 报文大小不定, 需要网络节点有较大缓存空间 3.1.3 分组交换 分组交换 分组 : 把大的数据块分割成小的数据块 优点 : 无需建立连接 存储转发, 动态分配线路 线路可靠性较高 线路利用率较高 相对于报文交换, 「存储管理」更容易 缺点 : 有存储转发时延 需要传输额外的信息量 ( 报文需要拆分和重组, 需要附加编号等信息 ) 乱序到目的主机时, 需要对分组排序重组 分组交换和报文交换比起来, 有点像利用了「流水线」的思想, 从而减少了传送数据的时间 比较总结 三种交换方式的比较 报文交换和分组交换都采用存储转发 电路交换传输时间最小, 如果有传送时间远大于呼叫时间且数据量大的情况, 选择电路交换 从信道利用率看, 报文交换和分组交换优于电路交换, 其中分组交换时延更小 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.02 数据报和虚电路.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.02 数据报和虚电路.html","title":"3.02 数据报和虚电路","keywords":"","body":"3.2 数据报和虚电路几种传输单元名词数据报虚电路对比3.2 数据报和虚电路 数据报 虚电路 几种传输单元名词 层次 传输单元 应用层 报文 传输层 报文段 网络层 IP数据报 分组 数据链路层 帧 物理层 比特流 数据报 无连接 每个分组携带源和目的地址 路由器根据分组的目的地址转发分组 : 基于「路由协议」构建「转发表」, 检索转发表, 为每个分组独立选路 虚电路 虚电路是一条源主机到目的主机类似于电路的路径, 路径上所有结点都要维持这条虚电路的建立, 都维持一张虚电路表, 每一项记录了一个打开的虚电路的信息 对比 虚电路&数据报 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.03 IP数据报.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.03 IP数据报.html","title":"3.03 IP数据报","keywords":"","body":"3.3 IP数据报TCP/IP协议栈IP数据报格式最大传送单元MTUIP数据报分片3.3 IP数据报 TCP/IP协议栈 TCP/IP协议栈 IP数据报格式 一个ip数据报 IP数据报格式 名称 解释 版本 IPv4/IPv6 首部长度 单位是4B, 最小为5 区分服务 期望获得哪种类型的服务 总长度 首部+数据, 单位是1B 生存时间(TTL) IP分组的「保质期」每经过一个路由器-1, 变成0则丢弃 协议 数据部分的协议 首部检验和 只检验首部 可选字段 0~40B, 可以用来支持排错, 测量以及安全等措施 填充 全0, 把首部补充成4B的整数倍 标识 同一数据报的分片使用同一标识 标志 三位只有两位有意义 x 中间位DF=1, 禁止分片; DF=0, 允许分片最低位MF=1, 表示之后还有分片; MF=0, 代表为最后一片/没有分片 片偏移 指出较长分组分片后, 某片在原分组中的相对位置, 以8B为单位 注意单位 : 总长度的单位是 1B 片偏移的单位是 8B 首部长度的单位是 4B 记忆大师 : 一种八片的首饰 ( 1总8片の首4 ) 协议 最大传送单元MTU MTU : 链路层数据帧可封装数据的上限 以太网的MTU是1500字节 如果一个IP数据包过长, 则需要对其进行分片 IP数据报分片 IP数据报分片例题 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.04 IP地址.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.04 IP地址.html","title":"3.04 IP地址","keywords":"","body":"3.4 IP地址分类的IP地址特殊的IP地址私有ip地址3.4 IP地址 IP地址 : 全世界唯一的32位/4字节标识符, 标识路由器主机的接口 ip地址的发展 分类的IP地址 分类的ip地址 类型 范围 每个网络最大主机数 A类 (0) 1-126 224−22^{24}-22​24​​−2 Ｂ类 (10) 128-191 216−22^{16}-22​16​​−2 Ｃ类 (110) 192-223 28−22^{8}-22​8​​−2 Ｄ类 (1110) 224-239 Ｅ类 (1111) 240-255 特殊的IP地址 特殊的ip地址 私有ip地址 私有ip地址, 局域网内部使用 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.05 网络地址转换NAT.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.05 网络地址转换NAT.html","title":"3.05 网络地址转换NAT","keywords":"","body":"3.5 网络地址转换NAT3.5 网络地址转换NAT 路由器对目的地址是私有IP地址的数据报一律不进行转发 网络地址转换NAT ( Network Address Translation ) : 在专用网连接到因特网的路由器上安装NAT软件, 安装了NAT软件的路由器叫NAT路由器, 它至少有一个有效的外部全球IP地址 NAT通过NAT转换表进行地址转换 NAT转换表 本质就是LAN和WAN的互相映射 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.06 子网.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.06 子网.html","title":"3.06 子网","keywords":"","body":"3.6 子网子网掩码使用子网时的分组转发3.6 子网 子网划分 子网划分就是在两级IP地址( 网络号 + 主机号 ) 的基础上在某个网络内部再将主机号的字段分为 ( 子网号 + 主机号 ), 从而实现对主机的进一步划分 子网 子网掩码 就是将网络号+子网号的各个位全部设置为1组成的一串比特串, 用于提取IP地址中的网络号 ( 相与 ) 子网掩码 使用子网时的分组转发 使用子网时的分组转发 检测路由表中有无路径 --- 目的地址与路由表中的每一行子网掩码依次相与, 判断目的网络是否存在下一跳地址 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.07 无分类编址CIDR.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.07 无分类编址CIDR.html","title":"3.07 无分类编址CIDR","keywords":"","body":"3.7 无分类编制CIDRCIDR的特点构成超网最长前缀匹配3.7 无分类编制CIDR CIDR的特点 消除了传统的A类, B类和C类地址以及划分子网的概念, 采用「网络前缀」代替 CIDR和网络前缀 融合子网地址与子网掩码, 方便子网划分, CIDR把网络前缀都相同的连续IP地址组成一个「CIDR地址块」 CIDR地址块 构成超网 将多个子网聚合成一个大子网, 叫做构成超网, 或者路由聚合 构成超网的方式 ：缩短网络前缀即可 最长前缀匹配 在采用CIDR时, 查找路由表有可能会得到几个匹配结果, 这时候应该选择具有最长网络前缀的路由, 前缀越长表示地址块越小, 也就是路由越具体 例题 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.08 ARP协议.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.08 ARP协议.html","title":"3.08 ARP协议","keywords":"","body":"3.8 ARP协议3.8 ARP协议 地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。 核心 : 完成IP地址到mac地址的映射 arp协议的使用过程 例题 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.09 DHCP协议.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.09 DHCP协议.html","title":"3.09 DHCP协议","keywords":"","body":"3.9 DHCP协议3.9 DHCP协议 DHCP（动态主机配置协议 Dynamic Host Configuration Protocol）是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。 特点 : 应用层协议 基于UDP 工作过程 : 主机广播DHCP发现报文 --- 发现网络中的DHCP服务器 DHCP服务器广播DHCP提供报文 --- 服务器拟分配给主机一个IP地址 主机广播DHCP请求报文 --- 主机向服务器请求提供IP地址 DHCP服务器广播DHCP确认报文 --- 正式将IP地址分配给主机 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.10 ICMP协议.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.10 ICMP协议.html","title":"3.10 ICMP协议","keywords":"","body":"3.10 ICMP协议ICMP差错报告报文不发送ICMP差错报告报文的情况ICMP询问报文ICMP的应用3.10 ICMP协议 ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。 ICMP报文 ICMP差错报告报文 终点不可达 源点抑制 时间超过 ( TTL=0 / 终点在规定时间内没收到所有的数据报片 ) 参数问题 ( 首部字段有问题 ) 改变路由 ( 重定向 ) 不发送ICMP差错报告报文的情况 对ICMP差错报告报文不再发送ICMP差错报告报文 对一个分片数据报的后续数据报片不发送ICMP差错报告报文 对具有组播地址的数据报都不发送ICMP差错报告报文 对具有特殊地址 ( 127.0.0.0, 0.0.0.0等) 的数据报不发送ICMP差错报告报文 ICMP询问报文 ICMP询问报文 应用 : ping ICMP的应用 应用 : ping, traceroute Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.11 IPv6.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.11 IPv6.html","title":"3.11 IPv6","keywords":"","body":"3.11 IPv6数据报格式与Ipv4的对比地址表示形式 ( 一般形式, 压缩形式 )3.11 IPv6 数据报格式 IPv6数据报格式 与Ipv4的对比 地址表示形式 ( 一般形式, 压缩形式 ) 地址表示形式 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.13 IP组播.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.13 IP组播.html","title":"3.13 IP组播","keywords":"","body":"3.13 IP组播单播, 广播和组播IP组播地址硬件组播IGMP协议和组播路由选择协议IGMP工作的两个阶段组播路由选择协议3.13 IP组播 单播, 广播和组播 单播 广播 组播 单播 组播(多播) IP组播地址 IP组播地址让原设备能够将分组发送给一组设备. 属于多播组的设备将被分配一个组播组IP地址 组播地址的范围是224.0.0.0 - 239.255.255.255 ( D类 ), 一个D类地址表示一个组播组. 只能用作分组的目标地址, 源地址总是为单播地址 组播数据报 \" 尽最大努力交付 \" , 应用于UDP 对组播数据报不会产生ICMP差错报文 并非所有的D类地址都可以作为组播地址 硬件组播 硬件组播 IGMP协议和组播路由选择协议 IGMP(Internet Group Management Protocol)互联网组管理协议是TCP/IP 协议族中负责IP组播成员管理的协议，用来在IP主机和与其直接相邻的组播路由器之间建立、维护组播组成员关系。 IGMP协议让路由器知道本局域网上是否有主机 ( 的进程 )参加或退出了某个组播组 IGMP协议 IGMP和ICMP都使用IP数据报传递报文 IGMP工作的两个阶段 IGMP工作的两个阶段 组播路由选择协议 组播路由选择协议的目的是找出以源主机为根节点的组播转发树 构造树可以避免在路由器之间兜圈子 对不同的多播组对应于不同的多播转发树, 同一个多播组, 对不同的源点也会有不同的多播转发树 组播路由选择协议常使用的三种算法: 基于链路状态的路由选择 基于距离-向量的路由选择 协议无关的组播 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.14 网络层设备.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.14 网络层设备.html","title":"3.14 网络层设备","keywords":"","body":"3.14 网络层设备1. 路由器3.14 网络层设备 1. 路由器 三个设备的区别 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/4. 传输层/":{"url":"roccoshi_note/01-计算机网络笔记/4. 传输层/","title":"4. 传输层","keywords":"","body":"4. 传输层传输层的功能传输层的两种协议端口套接字4. 传输层 传输层的功能 传输层提供进程与进程之间的逻辑通信 复用与分用 传输层对收到的报文进行差错检测 传输层的两种协议 UDP , TCP 端口 端口用于标识主机中的应用进程, 长度为16bit, 可以表示65536个不同的端口号, 端口号只有本地意义, 因特网不同计算机的相同端口之间没有联系 端口号的分类 : 熟知端口号 : 0-1023, 给一些重要的应用程序使用, 让所有用户都知道 登记端口号 : 1024-49151 客户端使用 : 29152-65535 ( 动态选择 ) 套接字 在网络中采用发送方和接收方的套接字组合来识别端点, 套接字唯一标识了网络中的一个主机和它上面的一个进程. socket = ( 主机IP地址, 端口号 ) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/":{"url":"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/","title":"4.2 TCP协议","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/4.2.1 TCP特点和报文段格式.html":{"url":"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/4.2.1 TCP特点和报文段格式.html","title":"4.2.1 TCP特点和报文段格式","keywords":"","body":"4.2.1 TCP特点和报文段格式1. TCP协议的特点2. TCP的报文段首部格式4.2.1 TCP特点和报文段格式 1. TCP协议的特点 面向连接 点对点 可靠交付 全双工 面向字节流 2. TCP的报文段首部格式 TCP报文段首部 解释 : 序号 : 在一个TCP连接中传送的字节流中的每一个字节都按顺序编号, 本字段表示本报文段所发送数据的第一个字节的序号 确认号 : 期望收到对望下一个报文段的第一个数据字节的序号, 若确认号为N, 则证明到序号N-1为止的所有数据都已经正确收到 数据偏移 ( 首部长度 ) : TCP报文段的数据起始处距离TCP报文段的起始处有多远, 以4B位为单位, 即一个数值是4B 六个控制位 : 紧急位URG : URG = 1时, 标明此报文段中有紧急数据, 是高优先级的数据, 应尽快传送, 不用在缓存里排队, 配合紧急指针字段使用 确认位ACK : ACK = 1时确认号有效, 在连接建立后所有传送的报文段都必须把ACK置为1 推送位PSH : PSH = 1时, 接收方尽快交付接受应用进程, 不用等到缓存填满再向上交付 复位RST : RST = 1时, 表明TCP连接中出现严重差错, 必须释放连接, 然后再重新建立传输连接 同步位SYN : SYN = 1时, 表明是一个连接请求 / 连接接受报文 终止位FIN : FIN = 1时, 表明此报文段发送方数据已发完, 要求释放连接 窗口 : 指的是发送本报文段的一方的接收窗口, 即现在允许对方发送的数据量 校验和 : 检验首部 + 数据, 检验时要加上12B伪首部, 第四个字段为6 紧急指针 : URG = 1时才有意义, 指出本报文段中紧急数据的字节数 选项 : ... 填充 : 使得首部为4B的整数倍 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/4.2.2 TCP连接管理.html":{"url":"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/4.2.2 TCP连接管理.html","title":"4.2.2 TCP连接管理","keywords":"","body":"4.2.2 TCP连接管理TCP连接的建立---三次握手SYN洪泛攻击TCP连接的释放---四次挥手4.2.2 TCP连接管理 TCP连接的建立---三次握手 三次握手过程 SYN洪泛攻击 攻击者发送SYN，也就是TCP三次握手的第一次握手的数据包，当服务器返回ACK后，该攻击者不再对其进行确认，那么这个TCP连接将处于挂起状态，也就是半连接状态，服务器收不到再确认的话将重复发送ACK给攻击者，这样更加浪费服务器的资源，攻击者就对服务器发送非常大量的TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务。 TCP连接的释放---四次挥手 四次挥手过程 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/4.2.3 TCP可靠传输.html":{"url":"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/4.2.3 TCP可靠传输.html","title":"4.2.3 TCP可靠传输","keywords":"","body":"4.2.3 TCP可靠传输4.2.3 TCP可靠传输 可靠传输 : 保证接收方进程从缓冲区读出的字节流和发送方发出的字节流是完全一样的 TCP实现可靠传输的机制 : 校验 : 与udp校验一样, 增加伪首部 序号 确认 重传 协议见链路层 --- 停等, GBN, SR协议 快速重传 : 快速重传 冗余ACK Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/4.2.4 TCP流量控制.html":{"url":"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/4.2.4 TCP流量控制.html","title":"4.2.4 TCP流量控制","keywords":"","body":"4.2.4 TCP流量控制4.2.4 TCP流量控制 流量控制就是让发送方控制发送的速度, 使接收方有时间接收数据 TCP利用滑动窗口机制实现流量控制 发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值 流量控制滑动窗口的过程 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/4.2.5 TCP拥塞控制.html":{"url":"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/4.2.5 TCP拥塞控制.html","title":"4.2.5 TCP拥塞控制","keywords":"","body":"4.2.5 TCP拥塞控制拥塞控制的四种算法慢开始和拥塞避免快重传和快恢复4.2.5 TCP拥塞控制 拥塞控制的四种算法 慢开始 拥塞避免 快重传 快恢复 慢开始和拥塞避免 慢开始和拥塞避免 快重传和快恢复 快重传和快恢复 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/4. 传输层/4.1 UDP协议.html":{"url":"roccoshi_note/01-计算机网络笔记/4. 传输层/4.1 UDP协议.html","title":"4.1 UDP协议","keywords":"","body":"4.1 UDP协议1. UDP协议的主要特点2. UDP的首部格式3. UDP的校验4.1 UDP协议 UDP只在IP数据报的服务之上增加了很少的功能, 即复用分用和差错检测功能 1. UDP协议的主要特点 UDP是无连接的, 减少开销和发送数据之前的时延 UDP使用「最大努力交付」, 不保证可靠交付 UDP是「面向报文」的, 适合一次性传输少量数据的网络应用 UDP无拥塞控制, 适合很多「实时应用」 UDP首部开销小, 为8B ( TCP首部20B ) 2. UDP的首部格式 UDP的首部格式 3. UDP的校验 udp的校验 伪首部 : 伪首部只在计算校验和时才出现, 既不向下传送也不向上提交 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/5. 应用层/":{"url":"roccoshi_note/01-计算机网络笔记/5. 应用层/","title":"5. 应用层","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/5. 应用层/5.1 网络应用模型.html":{"url":"roccoshi_note/01-计算机网络笔记/5. 应用层/5.1 网络应用模型.html","title":"5.1 网络应用模型","keywords":"","body":"5.1 网络应用模型1. 客户/服务器模型2. p2p模型 ( peer to peer )5.1 网络应用模型 1. 客户/服务器模型 客户-服务器模型 2. p2p模型 ( peer to peer ) p2p模型 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/5. 应用层/5.2 DNS系统.html":{"url":"roccoshi_note/01-计算机网络笔记/5. 应用层/5.2 DNS系统.html","title":"5.2 DNS系统","keywords":"","body":"5.2 DNS系统5.2 DNS系统 域名 域名解析过程 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/5. 应用层/5.3 FTP.html":{"url":"roccoshi_note/01-计算机网络笔记/5. 应用层/5.3 FTP.html","title":"5.3 FTP","keywords":"","body":"5.3 FTP5.3 FTP FTP Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/5. 应用层/5.4 电子邮件.html":{"url":"roccoshi_note/01-计算机网络笔记/5. 应用层/5.4 电子邮件.html","title":"5.4 电子邮件","keywords":"","body":"5.4 电子邮件5.4 电子邮件 电子邮件 发送 : SMTP 接收 : POP3 ; IMAP 通用因特网邮件扩充 : MIME ( 提供了一种可以在邮件中附加多种不同编码文件的方法) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/5. 应用层/5.5 HTTP.html":{"url":"roccoshi_note/01-计算机网络笔记/5. 应用层/5.5 HTTP.html","title":"5.5 HTTP","keywords":"","body":"5.5 HTTP5.5 HTTP 超文本传输协议HTTP HTTP报文结构 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/01-计算机网络笔记/6. 考纲.html":{"url":"roccoshi_note/01-计算机网络笔记/6. 考纲.html","title":"6. 考纲","keywords":"","body":"计网计网 题型 : 选择题 应用题 60% 期末 25% 实验 15% 作业 2/5 - 同轴电缆 T - 双绞线 F - 光纤 信道利用率的计算分析 ( 信贷滑窗协议是啥 ?? ) 24章不做要求 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/":{"url":"roccoshi_note/02-计算机组成原理/","title":"02-计算机组成原理","keywords":"","body":"复习要点和考纲复习要点和考纲 1 2章 3 4章 5-9章 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/2. 数据表示--编码/":{"url":"roccoshi_note/02-计算机组成原理/2. 数据表示--编码/","title":"2. 数据表示--编码","keywords":"","body":"2. 数据表示--编码2. 数据表示--编码 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/2. 数据表示--编码/2.1 原码 补码 反码.html":{"url":"roccoshi_note/02-计算机组成原理/2. 数据表示--编码/2.1 原码 补码 反码.html","title":"2.1 原码 补码 反码","keywords":"","body":"2.1 原码, 补码, 反码2.1.1 原码原码的优缺点2.1.2 补码 变形补码无模运算和有模运算补码的定义补码的表示补码的性质变形补码2.1.3 反码2.1 原码, 补码, 反码 2.1.1 原码 表示方法 : 符号 + 数值, 即一位符号位 + 绝对值真值 原码的定义 例如 : 35 = (100011)2{(100011)}_2(100011)​2​​ 如果用8位原码表示 +35 = (00100011)2{(00100011)}_2(00100011)​2​​ -35 = (10100011)2{(10100011)}_2(10100011)​2​​ +0.8125 = (0.1101000)2{(0.1101000)}_2(0.1101000)​2​​ -0.8125 = 1 - ( - 0.8125 ) = (1.0000000)2{(1.0000000)}_2(1.0000000)​2​​ + (0.1101000)2{(0.1101000)}_2(0.1101000)​2​​= (1.1101000)2{(1.1101000)}_2(1.1101000)​2​​ 原码的优缺点 优点 : 简单, 直观, 转换容易 实现乘除法规则简单 缺点 : 实现加减法规则复杂 2.1.2 补码 变形补码 无模运算和有模运算 无模运算 : 实数范围内的运算 有模运算 : 一定数值范围内的运算, 类似「时钟」 有模运算 「补码」就是利用了「有模运算」的原理 补码的定义 补码的定义 补码的表示 符号位 : 1为负, 0为正 0的表示 = 0, 是唯一的 ( 原码不是唯一的 ) 补码的表示范围 补码的表示范围 补码转换成原码 : 符号位为0 : 原码=补码 符号位为1 : 符号位不变, 数值位按位取反末位加一 原码转换成补码 : 符号位为0, 补码=原码 符号位为1, 补码=原码符号位不变, 数值位按位取反末位加一 补码的性质 将n位纯小数的补码变成2n位, 在末尾添加n个0 将整数补码扩大2n2^n2​n​​倍, 只需将X的符号位向左复制n位即可 符号位扩展 算数右移 : 符号位不变, 按位右移 算术左移 : 按位左移, 末尾补0 变形补码 变形补码采用双符号位, 左边是真正符号位, 右边用于判断是否溢出 : 两个符号位相同, 则不发生溢出 两个符号位相异, 则发生溢出 ( 此时最高位为符号; 次高位为溢出的数值而不是符号 ) 2.1.3 反码 反码与原码和真值之间的转换 : 反码与原码和真值之间的转换 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/2. 数据表示--编码/2.2 移码 浮点数 IEEE754.html":{"url":"roccoshi_note/02-计算机组成原理/2. 数据表示--编码/2.2 移码 浮点数 IEEE754.html","title":"2.2 移码 浮点数 IEEE754","keywords":"","body":"2.2 移码 浮点数 IEEE754移码浮点数的表示方法规格化的浮点数浮点数的精度问题浮点数的溢出浮点数的表示范围例题IEEE754标准规定单精度IEEE754 ( 32位 )2.2 移码 浮点数 IEEE754 移码 计算机常用移码来表示浮点数的阶码 0的移码 : 1000....0 ( n-1个0 ) 移码的表示范围 : −2n−1=X2n−1-2^{n-1} −2​n−1​​=X2​n−1​​ 移码与补码的关系 : 移码和补码关系为符号位取反 例题 浮点数的表示方法 浮点数的表示方法 规格化的浮点数 定义 : 如果阶码的底为2, 则规格化的尾数应满足条件1/2=∣M∣11/2 1/2=∣M∣1 当尾数用「补码」表示时, 若位尾数大于等于0, 则尾数格式应为 : M=0.1xxxxx , 即 若位尾数小于0, 则尾数格式应为 : M=1.0xxxxx , 即 ------「异或逻辑」 左规和右规 左规 : 若采用变形补码表示尾数, 则当结果的尾数出现11.1xxxx或者00.0xxxx形式时, 需要将尾数左移1位, 阶码减一, 知道尾数为规格化形式为止 右规 : 当浮点运算的结果出现01.xxxx或者10.xxxx时, 并不一定溢出, 应该先将尾数右移1位, 阶码 + 1, 然后判断阶码是否溢出 浮点数的精度问题 由于尾数长度固定, 所以当阶码不断增大的时候, 精度会变小 阶码数轴的分布 浮点数的溢出 溢出的原因 : 指数部分太大, 无法用有限的指数字段表示 下溢 : 阶码小于机器能表示的最小阶码, 一般当作机器0处理, 机器继续运行 上溢 : 阶码大于机器能表示的最大阶码, 机器必须转入溢出故障的中断处理程序进行相应的处理 解决溢出的办法 : 使用双精度格式 单精度和双精度 浮点数的表示范围 浮点数的表示范围 例题 注意将指数转化成阶码得方式 : 十进制--二进制--补码--阶码 例题1 例题2 注意尾数位数有一位在数符上, 所以真正的尾数位数应当-1 IEEE754标准 IEEE754标准是关于浮点数的一种表示标准 规定 尾数用原码表示, 小数点前隐含一个1 基值隐含为2 阶码用移码表示, n位移码的偏移值为2n−1−12^{n-1}-12​n−1​​−1 ( 比如8位阶码, 0 = (01111111)2(01111111)_2(01111111)​2​​ = 27−1=1272^7-1=1272​7​​−1=127) 指数 ( 阶码 )的最大值, 最小值作为特殊标记预留, 用来标记异常事件和机器零 分类 : 单精度, 双精度, 单精度扩展, 双精度扩展 单精度IEEE754 ( 32位 ) 组成 : S符号位 (1b) + E阶码 ( 8b ) + f尾数 (23b) 注意尾数小数点前隐含的0 单精度 例题1 二进制->十进制 单精度 例题2 十进制->二进制 关于十进制小数转二进制小数的问题 : 采用乘2取整，顺序排列的方法 做法 : 用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止 比如上面一题的0.78125 -> 0.11001 : 十进制0.78125 -> 二进制0.11001 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/2. 数据表示--编码/2.3 检错和纠错码.html":{"url":"roccoshi_note/02-计算机组成原理/2. 数据表示--编码/2.3 检错和纠错码.html","title":"2.3 检错和纠错码","keywords":"","body":"2.3 检错和纠错码奇偶校验码循环冗余校验码CRC海明码2.3 检错和纠错码 奇偶校验码 循环冗余校验码CRC 海明码 奇偶校验码 奇校验 : 加上校验位保证比特串具有奇数个1 偶校验 : 加上校验位保证比特串具有偶数个1 奇偶校验 例题 循环冗余校验码CRC 与计网相同 略 海明码 与计网相同 略 海明码及其用途 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/":{"url":"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/","title":"3. 运算方法与运算器","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.1 定点数运算/":{"url":"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.1 定点数运算/","title":"3.1 定点数运算","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.1 定点数运算/3.1.1 加减运算.html":{"url":"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.1 定点数运算/3.1.1 加减运算.html","title":"3.1.1 加减运算","keywords":"","body":"3.1.1 加减运算补码加减法1. 规则 :2. 溢出判断加法器和全加器1.一位全加器2. 行波进位加法器3. 先行进位加法器3.1.1 加减运算 补码加减法 1. 规则 : 参加运算的操作数用补码表示 补码的符号位和数值位同时进行加运算 加 : 两数补码直接相加 减 : 减数补码连同符号位一起取反, 末位+1, 再与被减数的补码相加 运算结果即为和/差的补码 2. 溢出判断 当两个同符号的数相加, 运算结果可能发生溢出 判断溢出的办法 : 双符号位判决法 进位判决法 根据运算结果的符号位和进位标志判别 根据运算前后的符号位进行判别 2.1 双符号位判决法 双符号位判决法 2.2 进位判决法 进位判决法 加法器和全加器 1.一位全加器 一位全加器 2. 行波进位加法器 行波进位加法器 特点 : 结构较简单, 且可以很方便的扩展 运算速度慢 3. 先行进位加法器 行波进位加法器的主要问题是进位信号的传递太慢 先行进位加法器通过逻辑表达式的推导, 将进位表达式都转换成最底层的输入相关, 通过加大逻辑电路的复杂度减少时间消耗 逻辑表达式推导 先行进位加法器 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.1 定点数运算/3.1.2 乘法运算.html":{"url":"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.1 定点数运算/3.1.2 乘法运算.html","title":"3.1.2 乘法运算","keywords":"","body":"3.1.2 乘法运算1. 原码一位乘法2. 补码一位乘法 (Booth法) (必考)运算规律过程3.1.2 乘法运算 1. 原码一位乘法 原码一位乘的运算过程 总结 : 先计算符号位 第一行左边写全0 ( D部分 ), 右边写乘数 ( A部分 ), 被乘数写在全0的下面 ( D左边的一位是进位部分 ) 判断乘数的最后一位, 如果是0, D部分不加向下移, 如果是1, D部分加上被乘数 右移一位 重复上述步骤直到A部分全部移走 将得到的值和符号位拼接得到最后结果 2. 补码一位乘法 (Booth法) (必考) 运算规律 booth法运算规律 过程 booth法过程 booth法步骤 : 写出[X]补 [-X]补 [Y]补 A部分写上Y补, 带1位符号位, 且A−1A_{-1}A​−1​​部分填上一个0 D部分和符号位全0 按上表规则判断A的最后一位与A−1A_{-1}A​−1​​的关系, 并执行相应算法, 不断右移 到符号位移至A的最后一位时退出, 记得最后还要执行一次加/减 前2n位即为所求 : [X×Y]补 [{X \\times Y}]_\\text{补} [X×Y]​补​​ Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.1 定点数运算/3.1.3 除法运算.html":{"url":"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.1 定点数运算/3.1.3 除法运算.html","title":"3.1.3 除法运算","keywords":"","body":"3.1.3 除法运算原码加减交替法「例」3.1.3 除法运算 原码加减交替法 加减交替法的运算法则 : 若余数R≥0, 则商上1, 余数左移一次, 减除数 若余数R＜0, 则商上0, 余数左移一次, 加除数 「例」 X=−0.10001011 \\text{X}=-0.10001011 X=−0.10001011 Y=0.1110 \\text{Y}=0.1110 Y=0.1110 利用原码加减交替法求商及余数 : 1 过程 结果--(注意余数要乘2的-4次方) 余数的符号和被除数保持一致 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.2 浮点数运算/":{"url":"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.2 浮点数运算/","title":"3.2 浮点数运算","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.2 浮点数运算/3.1.1 浮点数加减法.html":{"url":"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.2 浮点数运算/3.1.1 浮点数加减法.html","title":"3.1.1 浮点数加减法","keywords":"","body":"3.1.1 浮点数加减法步骤总结 :「例」解题步骤3.1.1 浮点数加减法 浮点数运算法则 步骤总结 : 对阶 小阶对大阶 : 小阶码+1, 尾数右移1位, 直到增大到与大阶码相同 尾数加减运算 加法直接加, 减法减数符号取反 ( 求补 )再与被减数相加 规格化 左规 11.1xxxx或者00.0xxxx时需要左规 尾数每左移一位, 阶码减一, 直到使尾数成为规格化数为止 阶码减1的同时判断是否发生下溢, 如果发生下溢, 可以认为结果为0 右规 若结果发生溢出, 即10.xxxx或01.xxxx时需要右规 尾数右移一位, 阶码加一, 右规最多有一次 阶码加一的同时判断是否发生上溢, 如果发生上溢, 可以认为结果是∞ 舍入处理 对阶, 规格化时, 在右移操作后需要进行舍入处理 截断法 --- 丢弃尾数低位 末位置1法 --- 使要保留的尾数的最低位永远为1 0舍1入法 --- 当尾数右移丢弃的是1时, 要保留的尾数最末位加1, 当尾数右移丢弃的是0时, 要保留的尾数最末位不变 「例」 例题 解题步骤 对阶 对阶 尾数求和/差 规格化 舍入处理 注意阶码的加减直接采用补码相加的方式比较简便 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.2 浮点数运算/3.1.2 浮点数乘除法.html":{"url":"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.2 浮点数运算/3.1.2 浮点数乘除法.html","title":"3.1.2 浮点数乘除法","keywords":"","body":"3.1.2 浮点数乘除法关于左规和右规的次数原码表示补码表示3.1.2 浮点数乘除法 考点好像没有...懒得看了 关于左规和右规的次数 原码表示 关于左规和右规的次数 解答 : 浮点数求和/差, 右规次数最多一次, 左规次数无法确定, 最多不会超过n-1次 浮点数相乘, 14⩽∣积的尾数∣⩽1\\frac{1}{4}\\leqslant |\\text{积的尾数}|\\leqslant 1​4​​1​​⩽∣积的尾数∣⩽1, 不需右规, 若需左规, 只需要一次 浮点数相除, 12∣商的尾数∣2\\frac{1}{2}​2​​1​​∣商的尾数∣2, 不需左规, 若需右规, 只需要一次 补码表示 当尾数用补码表示时, 乘除法均为 左规右规最多一次 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/4. 存储系统/":{"url":"roccoshi_note/02-计算机组成原理/4. 存储系统/","title":"4. 存储系统","keywords":"","body":"4. 存储系统存储系统的层次结构4. 存储系统 存储系统的层次结构 存储系统的层次结构 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/4. 存储系统/4.1 存储系统概述.html":{"url":"roccoshi_note/02-计算机组成原理/4. 存储系统/4.1 存储系统概述.html","title":"4.1 存储系统概述","keywords":"","body":"4.1 主存储器容量计算字扩展和位扩展4.1 主存储器 容量计算 例题1 字扩展和位扩展 字扩展 : 扩展存储单元的个数 比如原来有一个8k x 8bit的存储器, 用4片, 构成一个32k x 8bit的存储器, 这就是字扩展, 每个存储单元的大小没有变化, 只是存储单元的个数变多了 位扩展 : 扩展存储单元的大小 比如原来有一个8k x 8bit的存储器, 用4片, 构成一个8k x 32bit的存储器, 这就是位扩展, 存储单元的个数没有变化, 只是存储单元的大小变大了 「例题」 按字节编址, 说明4000H--5FFFH一共2132^{13}2​13​​个地址, 每个地址是8bit的空间 ( 一个字节 ), 则RAM区还剩余64-8 = 56KB的空间, 需要56/4 = 14个8K x 4位的SRAM芯片 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/4. 存储系统/4.2 Cache全相联组相联.html":{"url":"roccoshi_note/02-计算机组成原理/4. 存储系统/4.2 Cache全相联组相联.html","title":"4.2 Cache全相联组相联","keywords":"","body":"4.2 Cache 全相联 组相联 (重点必考)1. Cache的作用和工作原理2. Cache的地址映射和地址变换2.1 全相联2.2 直接映射2.3 组相联3. 例题4.2 Cache 全相联 组相联 (重点必考) 1. Cache的作用和工作原理 局部性原理 : 时间的局部性 : 内存某个单元的内容可能会在一段时间内反复使用 ( 循环变量 ) 空间的局部性 : 一个数组类的空间这次访问一个元素, 下一次可能会访问到下一个元素 ( 遍历数组 ) Cache : Cache 2. Cache的地址映射和地址变换 2.1 全相联 随便存 : 主存的任意一块可以映射到Cache中的任意一块 特点 : 优点 : 块冲突概率低, Cache空间利用率高 缺点 : 相联目录表容量大 -- 成本高, 查找速度慢 全相联 2.2 直接映射 规则 : 主存的每一块只能映射到Cache的一个特定的块中 整个Cache地址与主存地址的低位部分完全相同 优点 : 硬件简单, 不需要相联存储器, 只要 容量较小的按地址访问的区号标志表存储器 少量外比较电路 访问速度快 ( 无需地址变换 ) 缺点 : Cache块冲突概率高 Cache空间利用率很低 直接映射 2.3 组相联 将主存分区再分组,组间直接映射, 组内全相联 优点 : 块的冲突概率较低 块的利用率大幅度提高 块的失效率明显降低 缺点 : 实现难度和造价比直接映射的方式高 组相联 3. 例题 例题1 例题2 例题二中注意 : 组号和Cache组内块号可能不会给出, 因为就是目录表的序号 例题3 Cache中需要存储的其他信息 : 有效位 修改位 计数器 ( 替换策略 ) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/4. 存储系统/4.3 Cache替换算法 性能计算.html":{"url":"roccoshi_note/02-计算机组成原理/4. 存储系统/4.3 Cache替换算法 性能计算.html","title":"4.3 Cache替换算法 性能计算","keywords":"","body":"4.3 Cache替换算法 性能计算1. 几种Cache替换算法2. Cache一致性问题3. Cache性能分析加速比4.3 Cache替换算法 性能计算 1. 几种Cache替换算法 随机替换算法 RAND 先进先出替换算法 FIFO 最不经常使用替换算法 LFU 近期最少使用 ( 最久未用 )替换算法 LRU 最佳替换算法 OPT 2. Cache一致性问题 当从Cache读取并修改了数据后要想办法更新主存 写回法 全写法 两种写回方法 3. Cache性能分析 加速比 Cache-主存系统的平均访问周期 Cache-主存系统的加速比 : Sp = TM / TA ( 主存访问周期 / Cache-主存系统的平均访问周期 ) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/4. 存储系统/4.4 虚拟存储器.html":{"url":"roccoshi_note/02-计算机组成原理/4. 存储系统/4.4 虚拟存储器.html","title":"4.4 虚拟存储器","keywords":"","body":"4.4 虚拟存储器1. 段式虚拟存储器2. 页式虚拟存储器3. 段页式虚拟存储器虚拟存储器地址变换带来的速度问题例题4.4 虚拟存储器 虚拟存储器的组成 : 主存储器 + 联机工作的外部存储器 + 辅助硬件 + 系统软件 三种虚拟存储器 : 段式虚拟存储器 页式虚拟存储器 段页式虚拟存储器 1. 段式虚拟存储器 管理方式 : 将程序按逻辑意义分成段, 按段进行调入, 调出和管理 地址映像方法 : 每个程序段都从0地址开始编址, 长度可长可短, 可以在程序执行过程中动态改变程序段的长度 段式存储器的地址映像方法 地址变换方式 : 段式存储器的地址变换方式 段式存储器的特点 : 优点 : 程序的模块化性能好 便于共享主存中的某些段 程序的动态链接和调度容易 便于按逻辑意义实现存储器的访问方式保护 缺点 : 地址变换所花费的时间长 ( 两次加法 ) 段映像表大, 地址, 段长字段太长 主存储器的利用率往往比较低, 存在段间零头 ( 外部碎片 ) 对辅存的管理比较困难 2. 页式虚拟存储器 管理方式 : 将主存空间和程序空间都机械地分成相同大小的页面, 按照页顺序编号, 让程序的起点必须处在主存中某一个页面位置的起点上 任一主存单元的地址由页号和页内偏移两个字段组成 地址映像方法 : 页式存储的地址映像方法 地址变换方式 : 地址变换方式 页式存储器的特点 : 优点 : 主存储器的利用率比较高 页表相对简单, 使用硬件少 地址变换速度比较快 对磁盘管理较简单 缺点 : 程序的模块化性能不好 页表很长, 需要占用很大的存储空间 --- 采用多级页表的方式解决 3. 段页式虚拟存储器 管理方式 : 将程序按逻辑意义先分成段, 再让各段和实主存都机械等分成相同大小的页面, 每道程序通过一个段表和相应的一组页表来进行程序在主存空间中的定位 地址映像方法 : 每个程序段在段表中占一行, 在段表中给出页表长度和页表的起始地址, 页表中给出每一页在主存储器中的实页号 段页式存储器的地址映像 地址变换方法 : 先查段表, 得到页表起始地址和页表长度 再查页表找到要访问的主存实页号 把实页号p与页内偏移d拼接得到主存实地址 段页式地址变换 虚拟存储器地址变换带来的速度问题 虚拟存储器地址变换带来的速度问题 例题 关于主存和磁盘间交换信息的单位 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/4. 存储系统/4.5 磁盘.html":{"url":"roccoshi_note/02-计算机组成原理/4. 存储系统/4.5 磁盘.html","title":"4.5 磁盘","keywords":"","body":"4.5 磁盘1. 磁盘记录原理2. 磁记录方式3. 磁盘的主要技术指标4. 磁盘性能指标的计算5. 磁盘阵列RAID4.5 磁盘 1. 磁盘记录原理 「巨磁电阻效应」 水平记录 水平记录 垂直记录 垂直记录 2. 磁记录方式 几种垂直记录方式 编码效率 = 位密度 / 最大磁化反转次数 上述有自同步能力且编码效率为100%的是改进调频制MFM 3. 磁盘的主要技术指标 道密度 : 道/mm, 道/英寸 位密度 : bit/mm, bit/英寸, ( ☞最里圈磁道 ) 存储容量 : 非格式化容量 = 位密度 X 内圈磁道周长 X 每个记录面的磁道数 X 记录面数 格式化容量 = 每个扇区的字节数 X 每道的扇区数 X 每个记录面的磁道数 X 记录面数 平均访问时间 = 平均寻道时间 + 平均等待时间 + 数据传输时间 寻道时间 : 磁头移动到目标此磁道 ( 或柱面 )所需要的时间 等待事件 : 待读写的扇区旋转到磁头下方所用的时间, 一般用磁头旋转一周所用时间的一半作为平均等待时间 转速 : RPM ( 转/分钟)] 数据传输率 : 磁头找到数据的地址后, 单位时间内写入或读出的字节数 = 每个扇区的字节数 X 每道扇区数 X 磁盘的转速 磁盘的平均寻道时间, 平均等待时间通常为毫秒级 4. 磁盘性能指标的计算 例题 这里要注意内径与外径的带入, 很容易出错 内径, 外径 5. 磁盘阵列RAID RAID : 独立冗余磁盘阵列---由独立的硬盘组成的具有冗余特性的阵列 RAID0 : 无冗余, 把数据打散了存在多个磁盘里 RAID0 RAID1 : 把数据复制一份, 磁盘数量翻倍 raid1和raid0混合 : RAID1 RAID2 : 采用海明码校验数据, 校验盘数量太多, 实现起来很难 RAID3 : 采用奇偶校验码 RAID4 : 块级奇偶校验, 支持并发IO, 存在校验盘争用问题 RAID5 : ( 目前最多, 最流行的方式 ) 块分布式奇偶校验, 把校验盘的数据也分散在各个盘里了 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/5. 指令系统/":{"url":"roccoshi_note/02-计算机组成原理/5. 指令系统/","title":"5. 指令系统","keywords":"","body":"pc永远指向正在执行的指令的下一条指令的地址 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/5. 指令系统/5.1 存储模式与指令的分类.html":{"url":"roccoshi_note/02-计算机组成原理/5. 指令系统/5.1 存储模式与指令的分类.html","title":"5.1 存储模式与指令的分类","keywords":"","body":"5.1 存储模式1. 大端存储和小端存储2. 边界对齐3. 冯诺依曼结构和哈佛结构5.1 存储模式 1. 大端存储和小端存储 大端存储和小端存储 例子 2. 边界对齐 比如64位机器, 也就是8字节, 最好数据的开头都存在8的整数倍的位置上, 这就是边界对齐 边界对齐与边界未对齐 例题 : 例题 short类型是16bit也就是2字节, 也就是说要边界对齐应该存放在2的整数倍位置上 3. 冯诺依曼结构和哈佛结构 冯诺依曼结构 : 只有一个主存, 程序区和数据区在一起 哈佛结构 : 有两个主存, 程序区和数据区不在一起 冯诺依曼结构和哈佛结构 哈佛结构的优点 : 指令存储器只读, 设计和控制简单 避免了数据对程序可能造成的破坏 利用n位地址可以获得2×2n2 \\times 2^n2×2​n​​大小的地址空间 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/5. 指令系统/5.2 指令设计.html":{"url":"roccoshi_note/02-计算机组成原理/5. 指令系统/5.2 指令设计.html","title":"5.2 指令设计","keywords":"","body":"5.2 指令设计1. 指令的基本格式2. 操作码的设计3. 根据地址码数量设计扩展操作码5.2 指令设计 1. 指令的基本格式 指令的基本格式 2. 操作码的设计 举例 : 操作码的设计例题 定长编码 : 两种码长的扩展操作码 : huffman编码(最优) : 3. 根据地址码数量设计扩展操作码 可变长操作码的设计原则 : 短码不能是长码的前缀 例题1 例题2 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/6. CPU/":{"url":"roccoshi_note/02-计算机组成原理/6. CPU/","title":"6. CPU","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/6. CPU/6.1 CPU的功能与结构.html":{"url":"roccoshi_note/02-计算机组成原理/6. CPU/6.1 CPU的功能与结构.html","title":"6.1 CPU的功能与结构","keywords":"","body":"6.1 CPU的功能与结构1. 单总线CPU结构图6.1 CPU的功能与结构 1. 单总线CPU结构图 单总线CPU结构图 PSW : 程序状态字 ( 标志寄存器 ) R0 - Rn-1 : 通用寄存器 SP : 堆栈指针寄存器 DR : 数据寄存器 AR : 地址寄存器 ( 单向 ) PC : 程序计数器 ( 指向下一条指令地址 ) IR : 指令寄存器 ( 存正在执行的指令 ) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/6. CPU/6.2 微操作与微命令.html":{"url":"roccoshi_note/02-计算机组成原理/6. CPU/6.2 微操作与微命令.html","title":"6.2 微操作与微命令","keywords":"","body":"6.2 微操作与微命令1. 指令周期2. 时序信号的产生6.2 微操作与微命令 微操作 : CPU的基本/原子操作 每一个微操作是通过控制器将控制信号发送到相关部件上引起部件动作而完成的, 这些控制微操作完成的控制信号称为微命令, 微命令是由控制器产生的 微操作与微命令 1. 指令周期 在处理一条指令的过程中, 由CPU完成的操作序列构成一个指令周期 一个指令周期分为若干个CPU周期 指令周期 程序执行示意图 2. 时序信号的产生 微操作的流程 : 时序信号产生 取指周期 中断周期 执行周期 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/6. CPU/6.3 硬布线控制器设计.html":{"url":"roccoshi_note/02-计算机组成原理/6. CPU/6.3 硬布线控制器设计.html","title":"6.3 硬布线控制器设计","keywords":"","body":"6.3 硬布线控制器设计1. 控制器的输出信号2. 微操作序列和微命令序列的设计3. 写出信号的逻辑表达式6.3 硬布线控制器设计 1. 控制器的输出信号 控制器的输出信号 2. 微操作序列和微命令序列的设计 组合微操作的规则 : 遵守操作发生的顺序 避免冲突 ( 总线竞争, 资源冲突 ) 例子: 注意, 节拍T2时候, 为读主存命令, 先传入地址, 主存读入地址后输出数据到系统总线, 再由DR读入 ( Mread就是输出主存对应地址的数据, 主存不需要额外的读入地址的命令 ) MOV R0,X MOV R1,X ADD R1, R0 SUB R0,(X) IN R0,P OUT P,R0 JUMP JZ PUSH POP CALL RET 3. 写出信号的逻辑表达式 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/6. CPU/6.4 微程序控制器设计.html":{"url":"roccoshi_note/02-计算机组成原理/6. CPU/6.4 微程序控制器设计.html","title":"6.4 微程序控制器设计","keywords":"","body":"6.4 微程序控制器设计1. 微指令, 微程序微指令周期和一般格式2. 微程序控制原理3. 微程序与硬布线的比较6.4 微程序控制器设计 思想 : 用软件方法组织和控制数据处理系统的信息传送, 并最终用硬件实现 依据微程序顺序产生一条指令执行时所需的全部控制信号 1. 微指令, 微程序 一个微指令包括几个微操作及其所包含的微命令, 通过一组微指令产生的控制信号, 使一条指令中的所有微操作得以实现, 从而实现一条指令的功能 一个微指令序列称为微程序 微指令周期和一般格式 2. 微程序控制原理 微程序控制器的组成 : 微程序控制器在一个时钟周期的工作流 : 微指令地址的生成 : 微指令的分类 : 水平型微指令 : 控制域的编码 : 水平编码 垂直编码 字段编码 3. 微程序与硬布线的比较 微程序与硬布线的比较 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/6. CPU/6.5 CPU性能测量.html":{"url":"roccoshi_note/02-计算机组成原理/6. CPU/6.5 CPU性能测量.html","title":"6.5 CPU性能测量","keywords":"","body":"6.5 CPU性能测量1. CPU时间2. CPI3. MIPS4. FLOPS6.5 CPU性能测量 1. CPU时间 CPU时间 : CPU在运行某程序上所花费的时间 例题 : 例题 2. CPI CPI : ( Clock cycles per Instruction ) 每条指令执行所用的时钟数 有三个方面的因素使得程序的CPI可能会不同于CPU执行的CPI : Cache行为发生变化 指令混合发生变化 分支预测发生变化 影响CPU性能的三个关键因素 : CPI 时钟频率 指令数 例题 : 3. MIPS MIPS : ( million instructions per second ) --- CPU每秒钟执行的百万指令数 MIPS参数的局限 : 不能对指令集不同的计算机使用MIPS进行比较, MIPS只说明了指令执行速率, 而没有考虑指令的能力 计算对所有程序没有单一的MIPS值, 对于同一个计算机上的不同程序, MIPS是变化的 MIPS会与性能反向变化 4. FLOPS FLOPS : ( Floating point operations per second ) FLOPS = 浮点运算次数M / 执行时间T Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/7. 流水线/":{"url":"roccoshi_note/02-计算机组成原理/7. 流水线/","title":"7. 流水线","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/7. 流水线/7.1 流水线时空图和吞吐率.html":{"url":"roccoshi_note/02-计算机组成原理/7. 流水线/7.1 流水线时空图和吞吐率.html","title":"7.1 流水线时空图和吞吐率","keywords":"","body":"7.1 流水线时空图和吞吐率吞吐率7.1 流水线时空图和吞吐率 吞吐率 吞吐率 : 单位时间内流水线所完成的任务数或输出结果的数量 最大吞吐率TPmax : 流水线在达到稳定状态后所得到的吞吐率 最大吞吐率 瓶颈段 : 含有瓶颈段的流水线结构 细分瓶颈段 : 细分瓶颈段 重复设置瓶颈段 : 重复设置瓶颈段 实际吞吐率 : 实际吞吐率 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/7. 流水线/7.2 加速比和效率.html":{"url":"roccoshi_note/02-计算机组成原理/7. 流水线/7.2 加速比和效率.html","title":"7.2 加速比和效率","keywords":"","body":"7.2 加速比和效率加速比效率吞吐率, 加速比和效率的关系例题流水线的相关7.2 加速比和效率 加速比 定义 : 若流水线为m段, 加速比S定义为等功能的非流水线执行时间T(1)和流水线执行时间T(m)之比 加速比 当n->∞时 S = m, 当m->∞时 S = n, 由此可见增大指令流水线的级数和送入流水线的指令数均可以加速流水线的运行速度 效率 效率 吞吐率, 加速比和效率的关系 吞吐率, 加速比和效率的关系 例题 流水线的相关 实际流水中会出现三种相关也就是使流水线很难充分实现的三个冲突：资源相关、数据相关、控制相关 资源相关：指当指令在重叠执行过程中，不同指令争用同一功能部件产生资源冲突时产生的。 数据相关：指令在流水线中重叠执行时，当后继指令需要用到前面的指令产生的结果时发生的。 控制相关：当流水线遇到转移指令引起的。统计表明，转移指令约占总指令的四分之一左右，比起数据相关，它会使流水线丧失更多的功能。 数据相关 : 写后读相关，读后写相关，写后写相关 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/1. 绪论--冯诺依曼和Amdahl.html":{"url":"roccoshi_note/02-计算机组成原理/1. 绪论--冯诺依曼和Amdahl.html","title":"1. 绪论--冯诺依曼和Amdahl","keywords":"","body":"1. 绪论--冯诺依曼和Amdahl冯诺依曼计算机1. 冯诺依曼计算机的硬件组成2. 冯诺依曼机的特点参考例题和习题Amdahl定律加速比Amdahl定律参考例题和习题1. 绪论--冯诺依曼和Amdahl 要点 : 冯诺依曼计算机结构, 工作原理及特点 Amdahl定律的应用 ( 应能从题目中找到加速比和可加速部分比例关系等, 并应用定律求解) 冯诺依曼计算机 1. 冯诺依曼计算机的硬件组成 运算器 控制器 存储器 输入设备 输出设备 硬件组成 2. 冯诺依曼机的特点 将计算机要处理的问题用指令编成程序 指令和数据以同等地位存放在存储器中, 并可按地址访问 以二进制形式表示指令和数据 在控制器的控制下, 指令被逐条从存储器中取出来执行, 产生控制流, 在控制流的驱动下完成指令的功能 早期的冯诺依曼机以运算器为中心, 输入/输出设备通过运算器与存储器传送数据 参考例题和习题 1.2 1.3 Amdahl定律 加速比 加速比 计算机系统的加速比取决于下面两个因素 : 可改进部分在原系统总执行时间中所占的比例, 称为「可改进比例」, 用fef_ef​e​​表示 例如，程序的总执行时间为100s，可改进的部分是其中的20s，则fe＝0.2。可见， fe总是小于或等1的。 可改进部分改进后性能提高的程度, 称为「部件加速比」, 用rer_er​e​​表示 例如，某部件改进后，(该部件)执行时间由原来的20s减少到5s，则部件加速比re＝20/5＝4。可见， re一般是大于1的。 Amdahl定律 Amdahl定律 参考例题和习题 例题1 例题2 -- 多部件情况 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/8. 总线-IO-DMA.html":{"url":"roccoshi_note/02-计算机组成原理/8. 总线-IO-DMA.html","title":"8. 总线-IO-DMA","keywords":"","body":"8. 总线-IO-DMA1. 总线的概念和性能指标2. 总线仲裁3. 典型的总线4. IO接口5. 总线输入输出技术6. 直接存储器存取方式---DMADMAC与CPU总线控制权的交换方式 :8. 总线-IO-DMA 1. 总线的概念和性能指标 总线 : 是计算机系统的互连结构 是连接两个或多个总线设备的公共通信线路 是一组有定义的, 可共享的, 可传递0, 1逻辑信号的连接线 通常分为地址总线, 数据总线, 控制总线 总线的性能指标 : 总线带宽 总线宽度 总线负载 几个题 : 1 2 2. 总线仲裁 总线仲裁 : 用来决定哪个主设备可以使用总线的选择机制 按照总线仲裁电路位置不同, 仲裁方式可分为 : 集中式仲裁 链式查询方式 --- ( 使用总线的优先次序完全由「总线可用」线所连接部件的物理位置来决定, 离总线控制器越近的部件其优先级越高 ) 计数器定时查询方式 --- ( 轮询计数 ) 独立请求方式 --- ( 独立请求 ) 分布式仲裁 例题 答案是B 3. 典型的总线 PCI总线 ( 内总线, 并行总线 ) USB总线 ( 外总线, 串行总线 ) ( PCIE, SATA总线都是串行总线 ) 4. IO接口 I/O接口的作用 : I/O接口的作用 IO接口的编址方式 : ( 是否与主存使用同一个地址空间 ) 统一编址方式 独立编址方式 5. 总线输入输出技术 分类 : 程序查询方式 中断方式 直接存储器存取 ( DMA ) 方式 I/O通道方式 操作系统 的支持 例题1 例题2 中断屏蔽的屏蔽字设计 例题 6. 直接存储器存取方式---DMA DMA断点在CPU周期间, 中断断点在指令周期间 DMA与中断的比较 : DMA与中断的比较 DMAC与CPU总线控制权的交换方式 : 周期挪用 ( 窃取 )方式 存储器分时方式 停止CPU方式 扩展时钟周期方式 例题 : 题目 第一题 第二题 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/9. 通道 并行性.html":{"url":"roccoshi_note/02-计算机组成原理/9. 通道 并行性.html","title":"9. 通道 并行性","keywords":"","body":"9. 通道 并行性1. 三种通道类型2. 通道的最大流量3. 并行体系结构3.1 计算机体系结构的并行性3.2 计算机体系结构的分类 --- Flynn分类法9. 通道 并行性 1. 三种通道类型 三种通道类型 2. 通道的最大流量 字节多路通道的最大流量是求和关系, 选择通道和数组多路通道的最大流量是求最大值关系 例题 3. 并行体系结构 3.1 计算机体系结构的并行性 并行性 并行机制的层次 3.2 计算机体系结构的分类 --- Flynn分类法 Flynn分类法 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/02-计算机组成原理/车老师雨课堂习题.html":{"url":"roccoshi_note/02-计算机组成原理/车老师雨课堂习题.html","title":"车老师雨课堂习题","keywords":"","body":"雨课堂习题chapter 1Amdahl定律chapter 2定点小数的范围IEEE754标准CRC海明码chapter 3BCD码booth法计算乘法原码加减交替法浮点数加减法chapter 4字扩展和位扩展 芯片容量Cache 4-2LRU替换算法 4-3磁盘chapter 5寻址方式chapter 6微程序和微指令总时间 CPI MIPS雨课堂习题 chapter 1 Amdahl定律 chapter 2 定点小数的范围 IEEE754标准 CRC 海明码 从右向左, 从1开始 ( 和计网笔记上的不同 ) 偶校验 chapter 3 BCD码 运算中某位BCD数(四位二进制数)相加的结果 大于9或有向更高位的进位，则结果加6； booth法计算乘法 原码加减交替法 浮点数加减法 对阶 -- 求和差 --- 规格化 --- 舍入处理 chapter 4 字扩展和位扩展 芯片容量 Cache 4-2 目录表的前面表示的是cache内的组内块号, 内容是主存的「区号 + 组内块号」, 因为组间全相联, 没有必要显示 LRU替换算法 4-3 磁盘 chapter 5 寻址方式 chapter 6 微程序和微指令 总时间 CPI MIPS Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/03-Java学习/":{"url":"roccoshi_note/03-Java学习/","title":"03-Java学习","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/03-Java学习/01. JAVA的基本程序设计结构.html":{"url":"roccoshi_note/03-Java学习/01. JAVA的基本程序设计结构.html","title":"01. JAVA的基本程序设计结构","keywords":"","body":"1. JAVA的基本程序设计结构1. JAVA的基本程序设计结构 由于主要是一些基本的概念如分支, 循环, 数据类型这些, 这里只记录一些点而不做系统的笔记 main方法必须声明为public int 4字节; short 2字节; long 8字节; byte 1字节 ( 注意, java这些数据类型的字节数都是确定的, 而C/C++并不是, 比如C++的int类型可能是2或4字节, 和操作系统甚至编译器都有关, 给跨平台带来了很大的难度, 这也就是Java的\" 可移植性 \"好的原因之一) Java没有任何无符号形式 ( unnsigned) 的int, long, short 或者 byte类型 Java中的boolean类型不能由数值代替, 否则无法通过编译 ( C++中数值甚至指针类型都可以表示bool值 ) 不要使用 '==' 判断两个字符串是否相等, 应该用equals方法 String为不可变字符串, 不能修改单个字符 Java不允许嵌套的快中重定义一个变量 public class coreFormat { public static void main(String[] args) { int x = 3; if( x == 3) { int x = 4; x++; } System.out.println(x); } } /* Error:(10, 17) java: 已在方法 main(java.lang.String[])中定义了变量 x */ Java提供带标签的break语句, 用于跳出多重嵌套循环, 注意标签必须放在希望跳出的最外层循环之前并带上一个冒号 public class coreFormat { public static void main(String[] args) { int n; Imtab: while (true) { while (true) { while (true) { while (true) { break Imtab; } } } } System.out.println(\"I'm out\"); } } /* I'm out */ java.math包中两个大数的类 : BigInteger 和 BigDecimal, 前者实现任意精度的整数运算, 后者实现任意精度的浮点数运算 ( 不能用$+$ 或者 $\\times$ , $\\div$ ...来处理大数, 而需要使用大数类中的add和multiply, divide ...方法 public class coreFormat { public static void main(String[] args) { BigInteger a = BigInteger.valueOf(100); BigInteger reallyBig = new BigInteger(\"1209830129839012830918294798127398123123912848\"); BigInteger reallyBig1 = new BigInteger(\"1290831208309218309128309218038102341\"); BigInteger ans = reallyBig.multiply(reallyBig1); System.out.println(ans); ans = reallyBig.add(reallyBig1); System.out.println(ans); /* 1561686488348991405143064571291343054195716538900929041411407291357060176588777168 1209830131129844039227513107255707341162015189 */ } } 与C++不同, java不提供运算符重载的功能 java提供foreach循环, 格式如 for ( int x : a) public class coreFormat { public static void main(String[] args) { int[] a = {1,2,3,4,5,6,7,}; for(int i:a) System.out.print(i); } } // 1234567 可以用Arrays.toString快速输出一整个数组 public static void main(String[] args) { int[] a = {1,2,3,4,5,6,7,}; System.out.println(Arrays.toString(a)); } // [1, 2, 3, 4, 5, 6, 7] Arrays.copyOf拷贝数组 Arrays.sort数组排序 二维数组的声明 int[][] a = new int[8][8]; for (int i = 0; i Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/03-Java学习/02. JAVA的类与对象.html":{"url":"roccoshi_note/03-Java学习/02. JAVA的类与对象.html","title":"02. JAVA的类与对象","keywords":"","body":"2. JAVA的类与对象2. JAVA的类与对象 同样还是采用记录点的方式做一些简单的笔记 UML ( Unified Modeling Language , 统一建模语言) : 绘制类图, 表述类间关系 所有java对象都存储在堆中 Date deadline定义了一个对象变量deadline, 它可以引用Date类型的对象. 但是变量deadline本身不是一个对象, 可以初始化这个变量让他引用一个新构造的对象deadline = new Date() 或者引用一个已有的对象deadline = birthday 实例字段最好用private修饰, 如果用public修饰, 任何类的任何方法都可以修改这个字段 不能对一个已经存在的对象调用构造器来达到重新设置实例字段的目的 不要编写返回可变对象引用的访问器方法, 如果需要返回一个可变对象的引用, 首先应该对它进行clone 方法可以访问所属类的任何对象的私有特性 final实例字段必须在构造对象时初始化 static字段 : 属于类, 不属于任何一个单个的对象 静态方法 : 静态方法是不在对象上执行的方法, 比如Math类的pow方法, 建议使用类名而不是对象名来调用静态方法 java的参数传递机制是按值调用, 方法不能修改传递给它的任何基本数据类型参数变量的内容, 但是可以改变对象参数的状态 重载( overloading ) : 多个方法有相同的名字和不同的参数, 便出现了重载 Java允许重载任何方法, 而不只是构造器方法 如果类中没有编写构造器, 就会为你提供一个无参数的构造器. 如果类中至少有一个构造器, 那么构造对象时如果不提供参数就是不合法的 构造器必须与类同名, 且不能有返回值( void 也不可 ), 普通方法也可以和类名相同但是必须要有返回值或者void, 构造函数可以重载 构造器的两种写法举例 参数前加前缀 public constructorTest(String aname, int ayear) { this.name = aname; this.year = ayear; } 利用关键词this ( this指示隐式参数, 也就是所构造的对象 public constructorTest(String name, int year) { this.name = name; this.year = year; } 初始化块---一般放在字段定义以后, 一个类的对象被构造时, 这些块就会执行 比如 class xx{ private static int nextId; private int id; private String name; { //初始化块 id = nextId; nextId ++; } } 可以用静态的初始化块来初始化静态字段 e.g. static { var generator = new Random(); nextId = generator.nextInt(1000); } 包 : Java允许使用包将类组织在一个集合中, 借助包可以方便地组织自己的代码, 并将自己的代码与别人提供的代码库分开管理 使用包名的主要原因是确保类名的唯一性, 不同包中相同的类名不会产生冲突 用因特网域名以逆序的方式作为包名 要将类放入包中, 就必须将包的名字放在源文件的开头, 即放在定义这个包的各个类的代码之前 e.g. package com.horseman.corejava public class Employee { ... } 如果没有在源文件中放置package语句, 那么这个源文件的类就属于无名包 , 标记public的部分可以由任意类使用; 标记为private的部分只能由定义它们的类使用; 如果没有标记public或者private, 则这个部分可以被同一个包中的所有方法访问 JAR文件 : Java归档文件, 可以包含类文件, 也可以包含其他类型的文件, JAR文件是压缩的, 它使用ZIP压缩格式. Javadoc : Javadoc是Sun公司提供的一个技术，它从程序源代码中抽取类、方法、成员等注释形成一个和源代码配套的API帮助文档。也就是说，只要在编写程序时以一套特定的标签作注释，在程序编写完成后，通过Javadoc就可以同时形成程序的开发文档, 比如JDK API. 可以参考这里 文档注释 : 类注释 : 放在import 语句之后, 类定义之前 /** *注释 * */ public class xx { ... } 方法注释 字段注释 通用注释 包注释 具体不再赘述 类设计技巧 : 一定要保证数据私有 ( 不破坏封装性 ) 一定要对数据进行初始化 不要再类中用过多的基本类型 不是所有的字段都需要单独的字段访问器和字段修改器 分解有过多职责的类 类名和方法名要能够体现它们的职责 优先使用不可变的类 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/03-Java学习/03. JAVA的继承---多态_抽象.html":{"url":"roccoshi_note/03-Java学习/03. JAVA的继承---多态_抽象.html","title":"03. JAVA的继承---多态_抽象","keywords":"","body":"3. JAVA的继承---多态_抽象多态关于多态中的成员变量关于多态中的成员方法使用多态的好处super关键字抽象类3. JAVA的继承---多态_抽象 关键字 : extends extends表明正在构造的新类派生于一个已经存在的类, 这个已经存在的类称为 超类 基类 或 父类 ; 新类称为子类 或孩子类 从某个特定的类到其祖先的路径称为该类的继承链 在java中, 继承有三个特征 : JAVA是单继承的, 一个类的直接父类只能有一个 class A extends B{} // 正确 class A extends B,C{} // 错误 JAVA语言可以多级继承 ( java.lang.Object类是继承链的顶端 ) class A extends B{} // 正确 class B extends C{} // 正确 一个子类的直接父类是唯一的, 但是一个父类可以拥有很多个子类 多态 在java中, 对象变量是多态的, 子类的每个对象也是超类的对象 e.g. 一个Employee类型的变量既可以引用一个Employee类型的对象, 也可以引用Employee类的任何一个子类的对象 ( 例如, Manager, Executive, Secretary等 ) 关于多态中的成员变量 直接访问成员变量 : 看等号左边是谁, 则优先用谁, 如果没有就向上查找, 不会向下查找 : e.g. public class Father { // 父类 int x = 10; } public class Son extends Father { // 子类 int x = 20; } public class MainFunc { public static void main(String[] args) { Father obj = new Son(); // 多态 System.out.println(obj.x); } } 输出为10, 也就是父类的x属性 \" 编译看左边, 运行也看左边 \" 如果用成员方法间接访问成员变量, 则方法属于谁就优先用谁, 如果没有就向上查找. 关于多态中的成员方法 成员方法的访问原则 : 看new的是谁, 就优先用谁, 如果没有就向上查找 Father obj = new Son(); obj.method; // 父类子类都有, 优先使用子类的 obj.method_of_father; // 子类没有, 向上查找使用父类 obj.method_of_son; // 父类没有, 报错 ! (编译不通过) \" 编译看左边, 运行看右边 \" 使用多态的好处 比如一个学校里有很多不同的工种 教授, 副教授, 导员, 讲师, 助教.... 他们都是为学校工作 他们在学校都是工作, 那么不使用多态的写法为 : teacher a = new teacher(); assistant b = new assistant(); professor c = new professor(); a.work(); b.work(); c.work(); .... 使用多态则为 : Employee a = new teacher(); Employee b = new assistant(); Employee c = new professor(); ... 无论右边是什么, 左边对于学校来说都是Employee的身份... 关于强制类型转换 ( 向下转型 ) : 只能在继承层次内进行强制类型转换 在将超类强制转换成子类之前, 应该用instanceof进行检查 if ( a instanceof b) { c = (b) a; } super关键字 在子类的成员方法中, 访问父类的成员变量 在子类的成员方法中, 访问父类的成员方法 在子类的构造方法中, 访问父类的构造方法 public son extends father{ int num = 20; public son() { super(); // 父类的构造方法 } public void methodson() { sout(super.num); // 父类的num } public void method() { super.method(); // 父类的method } } 抽象类 如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类 抽象类和抽象方法用abstract关键字表示 public abstract class Animal { // 抽象方法 public abstract void eat(); // 普通的成员方法 public void normalMethod() { } } 子类必须覆盖重写抽象类的所有抽象方法 : ( idea中在子类 alt + enter -- implement -- @Override) 一个继承的案例 : 发红包 User父类 : package Red_Beg; public class USer { private String name; private int money; // alt + insert自动生成 public USer() { } public USer(String name, int money) { this.name = name; this.money = money; } public void show() { System.out.println(\"我叫, \" + name + \", 我有多少钱? : \" + money); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getMoney() { return money; } public void setMoney(int money) { this.money = money; } } Manager发红包 : package Red_Beg; import java.util.ArrayList; public class Manager extends USer { public Manager() { } public Manager(String name, int money) { super(name, money); } public ArrayList send(int totalMoney, int count) { // 集合, 存储若干个红包的金额 ArrayList redList = new ArrayList<>(); int leftMoney = super.getMoney(); if (totalMoney > leftMoney) { System.out.println(\"余额不足\"); return redList; } else // 扣钱 { super.setMoney(leftMoney - totalMoney); // 发红包平均拆分成count段 int avg = totalMoney / count; int mod = totalMoney % count; // 放进集合 for (int i = 0; i Member收红包 : package Red_Beg; import java.util.ArrayList; import java.util.Random; public class Member extends USer { public Member() { } public Member(String name, int money) { super(name, money); } public void receive(ArrayList list) { // 随机抽取一个红包 int index = new Random().nextInt(list.size()); // 以上为生成一个0-list.size()的随机int // 根据索引从集合中删除 int delta = list.remove(index); int money = super.getMoney(); super.setMoney(money + delta); } } Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/03-Java学习/04. ArrayList.html":{"url":"roccoshi_note/03-Java学习/04. ArrayList.html","title":"04. ArrayList","keywords":"","body":"4. ArrayListArrayList常用方法向ArrayList中存储基本类型的数据4. ArrayList 数组有一个缺点, 一旦创建, 程序运行期间长度是不可以改变的 Java中的可变数组 --- ArrayList ArrayList ArrayList , 代表泛型 只能是引用类型, 不能是基本类型 用几个例子好理解 : ArrayList list = new ArrayList<>(); list.add(\"rock\"); list.add(\"rock you\"); System.out.println(list); ------------------- // 输出 : [rock, rock you] 常用方法 add 向集合当中添加元素 get get(int index); 从集合中获取元素, 返回值是对应位置元素 remove remove(int index); 删除对应位置元素 size 返回集合大小 向ArrayList中存储基本类型的数据 如果希望向集合ArrayList当中存储基本类型的数据, 必须使用基本类型对应的 \" 包装类 \" ; 由于JDK1.5+开始支持自动装箱和自动拆箱, 可以直接用基本类型进行存取操作. e.g. ArrayList list = new ArrayList<>(); list.add(100); int x = 30; list.add(x); int y = list.get(0); System.out.println(y); ---------- 输出 : 100 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/03-Java学习/05. String.html":{"url":"roccoshi_note/03-Java学习/05. String.html","title":"05. String","keywords":"","body":"5. String创建字符串的常见方式字符串常量池常用方法内容比较获取截取转换分割5. String java.lang.String类 程序当中所有的双引号字符串, 都是String类的对象 字符串是常量 , 内容是永不可变的 由于字符串不可改变, 所以字符串是可以共享使用的 创建字符串的常见方式 public String(); 创建一个空白字符串, 不含有任何内容 public String(char[] array) ; 根据字符数组的内容来创建对应的字符串 public String(byte[] array) ; 根据字节数组的呢欸容来创建对应的字符串 e.g. 字符串常量池 常用方法 内容比较 equal方法 : 根据内容进行比较 ( ==是根据地址 ) equalsIgnoreCase : 忽略大小写进行内容比较 获取 public int length() public String concat(String str) public char charAt(int index) : 获取指定索引位置的单个字符 public int indexOf(String str) : 查找参数字符串在本字符串当中首次出现的索引位置, 如果没有则返回-1值 截取 public String substring (int index) : 截取从index处一直到字符串末尾的字符串 public String substring (int begin, int end) : 左闭右开截取新字符串 转换 public char[] toCharArray() : 将当前字符串拆分为字符串数组作为返回值 public byte[] getBytes() : 获得当前字符串底层的字节数组 public String replace (CharSequence oldString, CharSequence newString) : 将所有出现的老字符串替换成为新字符串 分割 public String[] split (String regex) : 按照参数的规则( 正则表达式 ), 将字符串切分为若干部分; Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/03-Java学习/06. 接口.html":{"url":"roccoshi_note/03-Java学习/06. 接口.html","title":"06. 接口","keywords":"","body":"6. Interface接口的定义和介绍接口的实现与使用默认方法静态方法私有方法常量几个注意事项6. Interface 接口的定义和介绍 接口 (interface) 就是多个类的公共规范 接口是一种引用数据类型, 最重要的内容就是其中的 : 抽象方法 定义一个接口的格式 : public interface 接口名称 { } 接口中可以包含的内容有 : 常量 抽象方法 Java8后可以额外包含 : 默认方法 静态方法 Java9后可以包含 : 私有方法 接口中的抽象方法的修饰符必须是 : public abstarct public interface MyInterface01 { public abstract void method01(); public abstract void method02(); } 也可以省略不写 ( 默认就是public abstract ) : public interface MyInterface01 { void method01(); void method02(); } 接口的实现与使用 接口不能直接使用, 必须有一个\"实现类\"来实现该接口 格式 : public class 类名 implements 接口名 { } 接口的实现类必须覆盖重写 ( 实现 ) 接口中所有的抽象方法, 除非实现类就是抽象类 接口 : public interface MyInterface01 { void method01(); void method02(); int method03(); } 实现类 : public class demo01 implements MyInterface01 { @Override public void method01() { System.out.println(\"method01\"); } @Override public void method02() { System.out.println(\"method02\"); } @Override public int method03() { return 0; } } 使用 : public static void main(String[] args) { demo01 demo = new demo01(); demo.method01(); demo.method02(); demo.method03(); } 默认方法 可以直接在接口中定义, 实现类不需要覆盖重写 ( 也可以覆盖重写, 在使用时如果没有重写, 就会向上查找 ) public interface MyInterface01 { void method01(); void method02(); public default void methodDefault() { // 默认方法 ... } } 静态方法 public interface MyInterface01 { void method01(); void method02(); public static void methodStatic() { // 默认方法 ... } } 注意 : 静态方法不可以通过接口实现类的对象来调用, 而应该通过接口名称, 直接调用其中的静态方法 正确的调用 : MyInterface01.methodStatic() 私有方法 普通私有方法 静态私有方法 解决接口内部重复代码的问题 常量 接口当中的常量, 定义必须使用 public static final 进行修饰( 可省略 ), 必须赋值 常量的推荐命名方式 : 使用完全大写, 并且使用下划线进行分隔 几个注意事项 接口是没有静态代码块或者构造方法的 一个类的直接父类是唯一的, 但是一个类可以同时实现多个接口 public class XX implements interfaceA, interfaceB { } 如果实现类所实现的多个接口当中, 存在重复的抽象方法, 那么只需要覆盖重写一次 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/03-Java学习/07. Date,_DateFormat,_Calendar类.html":{"url":"roccoshi_note/03-Java学习/07. Date,_DateFormat,_Calendar类.html","title":"07. Date,_DateFormat,_Calendar类","keywords":"","body":"7. Date类构造方法成员方法DateFormat类构造和成员方法Calendar类Calendar类的常用成员方法7. Date类 java.util.Date Date表示特定的时间, 精确到毫秒 时间原点 ( 0m ) : 1970年1月1日 00:00 构造方法 空参构造方法 : 获取当前系统的日期和时间 Date date = new Date(); 带参数构造方法 : Date ( long date ) : 传递毫秒值, 把毫秒值转换为日期 Date date = new Date(0); System.out.println(date); // 输出Thu Jan 01 08:00:00 CST 1970 成员方法 getTime() 把日期转换为毫秒 DateFormat类 java.text.DateFormat类是日期/时间格式化子类的抽象类 可以完成日期和文本之间的转换 构造和成员方法 String format(Date date) : 按照指定的模式把Date日期格式化为符合模式的字符串 Date parse(String source) : 把符合模式的字符串解析为Date日期 DateFormat类是一个抽象类, 无法直接创建对象使用, 可以使用DateFormat的子类 : java.text.SimpleDateFormat SimpleDateFormat的构造方法 : SimpleDateFormat(String pattern) : 用指定的模式和默认语言环境的日期格式符号构造SimpleDateFormat 常用的格式规则 : 字母 含义 y 年 M 月 d 日 H 时 m 分 s 秒 SimpleDateFormat的format和parse方法 format : 创建SimpleDateFormat对象并在构造方法中传递指定的模式 使用format方法把Date转换为符合模式的字符串 e.g. Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String format = sdf.format(date); System.out.println(format); // 输出 : 2020-06-25 08:34:48 parse : 创建SimpleDateFormat对象并在构造方法中传递指定的模式 使用parse方法把符合模式的字符串解析为Date日期 注意 : parse方法声明了一ParseException解析异常, 如果字符串和构造方法中的模式不一样程序就会抛出此异常 e.g. String text = \"2020-06-25 08:34:48\"; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); Date date = sdf.parse(text); System.out.println(date); System.out.println(date.getTime()); /* 输出 : Thu Jun 25 08:34:48 CST 2020 1593045288000 */ Calendar类 Java.util.Calendar Calendar类是一个抽象类, 里面提供了很多操作日历字段的方法 ( YEAR, MONTH, DAY_OF_MONTH. HOUR ...) Calendar类无法直接创建对象使用, 里面有一个静态方法getInstance(), 该方法返回了Calendar类的子类对象 Calendar类的常用成员方法 public int get(int field) : 返回给定日历字段的值 public void set(int field, int value) : 将给定日历字段设置为给定值 public abstract void add(int field, int amount) : 根据日历的规则, 为给定的日历字段添加或减去指定的时间量 public Date getTime() : 返回一个表示此Calendar时间值的Date对象 其中的int field 是日历字段如YEAR, MONTH...可直接用Calendar.YEAR....获取 get的使用 : e.g. Calendar c = Calendar.getInstance(); System.out.println(c.get(Calendar.YEAR)); // 2020 System.out.println(c.get(Calendar.DATE)); // 25 set和getTime的使用 : e.g. Calendar c = Calendar.getInstance(); c.set(2000,8,7); Date date = c.getTime(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); System.out.println(sdf.format(date)); // 2000-09-07 add的使用 : e.g. Calendar c = Calendar.getInstance(); c.set(2000,8,7); c.add(Calendar.YEAR,-1); //2000 -- 1999 Date date = c.getTime(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); System.out.println(sdf.format(date)); // 1999-09-07 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/03-Java学习/08. System类_StringBuilder.html":{"url":"roccoshi_note/03-Java学习/08. System类_StringBuilder.html","title":"08. System类_StringBuilder","keywords":"","body":"8. System类几个常用方法 :StringBuilder类两种构造方法 :几个常用方法 :8. System类 几个常用方法 : arraycopy方法 int[] src = {1,2,3,4,5}; int[] dest = {6,7,8,9,10}; System.out.println(Arrays.toString(dest)); System.arraycopy(src, 0, dest, 0, 3); System.out.println(Arrays.toString((dest))); /* out : [6, 7, 8, 9, 10] [1, 2, 3, 9, 10] */ System.currentTimeMillis() 获取当前的毫秒值 ( = new Date().getTime() ) System.getProperty 获取路径 System.out.println(System.getProperty(\"user.dir\")); System.out.println(System.getProperty(\"user.home\")); System.out.println(System.getProperty(\"java.home\")); /* out : E:\\projects\\JavaSE C:\\Users\\roccoshi C:\\Program Files\\Java\\jdk-11.0.2 */ StringBuilder类 StringBuilder类 : 字符串缓冲区, 可以提高字符串的操作效率 底层也是一个数组, 但是没有被final修饰, 可以改变长度 两种构造方法 : StringBuilder bu1 = new StringBuilder(); StringBuilder bu2 = new StringBuilder(\"abc\"); 几个常用方法 : append 可以添加许多基本类型, 返回值为调用方法的对象本身 e.g. StringBuilder bu1 = new StringBuilder(); bu1.append(\"abc\"); bu1.append(123123); bu1.append(11.123); System.out.println(\"bu1 : \" + bu1); // out : bu1 : abc12312311.123 toString 可以把一个StringBuilder类变成一个字符串 e.g. String s1 = bu1.toString(); Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/03-Java学习/09. 包装类.html":{"url":"roccoshi_note/03-Java学习/09. 包装类.html","title":"09. 包装类","keywords":"","body":"9. 包装类装箱与拆箱装箱拆箱自动装箱和自动拆箱基本类型与字符串之间的转换9. 包装类 包装类的作用 : 将基本引用类型像对象一样操作 基本类型 对应的包装类 byte Byte short Short int Integer long Long double Double char Character boolean Boolean 装箱与拆箱 装箱 : 从基本类型转换为对应的包装类对象 拆箱 : 从包装类对象转换为对应的基本类型 装箱 构造方法 : Integer(int value) 构造一个新分配的Integer对象, 它表示指定的int值 Integer (String s) 构造一个新分配的Integer对象, 它表示String参数所指示的int值 有横线, 说明方法过时了 静态方法 : static Integer valueOf(int i) static Integer valueOf(String s) 拆箱 成员方法 : int intValue() 以 int 类型返回该Integer值 Integer n1 = Integer.valueOf(\"111\"); int m = n1.intValue(); // 拆箱 ( Integer -> int ) 自动装箱和自动拆箱 JDK1.5之后基本类型数据和包装类之间可以自动的相互转换 e.g. Integer n = 123; // 自动装箱 等价于 Integer n = Integer.valueOf(123) 注意 : 包装类无法直接参与运算 , 可以自动转换为基本类型的数据再参与计算 --- 自动拆箱 e.g. Integer n = 123; int x = n + 1; sout(x); // 124 基本类型与字符串之间的转换 基本类型 --> 字符串 直接基本类型 + \"\" , 比如 34 + \"\" --- 最简单方式 static String toString(int i ) static String valueOf(int i) 字符串-->基本类型 使用包装类的静态方法parseXXX e.g. String s1 = \"100000\"; int s2 = Integer.parseInt(s1); System.out.println(s2); // s2 = 100000 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/03-Java学习/10. Collection集合框架_iterator迭代器_增强for循环foreach.html":{"url":"roccoshi_note/03-Java学习/10. Collection集合框架_iterator迭代器_增强for循环foreach.html","title":"10. Collection集合框架iterator迭代器增强for循环foreach","keywords":"","body":"10. 集合Collection iterator迭代器 foreachCollection(单列集合)的框架Collection下的方法Iterator迭代器增强for循环 --- for each10. 集合Collection iterator迭代器 foreach 集合和数组的区别 : 数组的长度固定, 集合的长度可变 数组中存储的是同一类型的元素, 集合存储的都是对象 Collection(单列集合)的框架 Collection下的方法 最顶层, 所有实现类都可以使用 : 方法 作用 boolean add(E e) 向集合中添加元素 boolean remove(E e) 删除集合中某个元素 void clear() 清空集合中所有元素 boolean isEmpty() 判断集合是否为空 int size() 获取集合的长度 Object[] toArray() 将集合转换成一个数组 Iterator迭代器 Iterator迭代器是一个接口, 无法直接使用, 需要获取实现类, 获取实现类的方式 : Collectioni.iterator()返回在collection的元素上进行迭代的迭代器 使用步骤 : 获取迭代器的实现类对象 使用iterator接口中的方法hasNext判断有没有下一个元素 使用iterator接口中的放啊next取出下一个元素 e.g. Collection col = new ArrayList<>(); col.add(\"jack\"); col.add(\"mike\"); col.add(\"amy\"); Iterator it = col.iterator(); while (it.hasNext()) { System.out.println(it.next()); } //out : jack mike amy ( 迭代器的实现就像一个指针, 初始指在下标为-1的位置, 然后通过不断地next移动到集合末尾 ) 增强for循环 --- for each 格式 : for (集合/数组的数据类型 变量名 : 集合名/数组名) {} e.g. public static void main(String[] args) { // 遍历数组 int[] arr = {1,2,3,4,5}; for (int i : arr) { System.out.println(i); } // 遍历集合 Collection col = new ArrayList<>(); col.add(\"jack\"); col.add(\"mike\"); col.add(\"amy\"); for (String a: col) { System.out.println(a); } } Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/03-Java学习/11. 泛型.html":{"url":"roccoshi_note/03-Java学习/11. 泛型.html","title":"11. 泛型","keywords":"","body":"11. 泛型定义含有泛型的类定义含有泛型的方法定义含有泛型的接口泛型通配符泛型的上下限限定11. 泛型 泛型是一种未知的数据类型, 当我们不知道使用什么类型的时候, 可以使用泛型 泛型也可以看成一个变量, 用来接收数据类型 在创建集合对象的时候, 就会确定泛型的数据类型 使用泛型的好处 : 避免了类型转换的麻烦, 存储的是什么类型, 取出的就是什么类型 缺点 : 泛型是什么类型, 只能存储什么类型的数据 定义含有泛型的类 类定义如下, 所有类型均用E代替 : public class genericDemo { private E name; public E getName() { return name; } public void setName(E name) { this.name = name; } } 实例化 : public class demo02 { public static void main(String[] args) { // 不写泛型默认为object类型 genericDemo gc = new genericDemo(); gc.setName(\"string\"); Object name = gc.getName(); System.out.println(name); // 泛型使用Integer类型 genericDemo gc2 = new genericDemo<>(); gc2.setName(1); // 泛型使用String类型 genericDemo gc3 = new genericDemo<>(); gc3.setName(\"hello world\"); } } 定义含有泛型的方法 普通方法 : // 泛型方法定义在方法的修饰符和返回类型之间 public class genericMethodDemo { public void method01(M m) { System.out.println(m); } } 测试 : public class dmeo03 { public static void main(String[] args) { genericMethodDemo gm = new genericMethodDemo(); gm.method01(123); gm.method01(\"hello world\"); gm.method01(1231.123); } } /* out : 123 hello world 1231.123 */ 静态方法 : public static void method02(S s) { System.out.println(s); } 定义含有泛型的接口 定义 : public interface genericInterface { public abstract void method(I i); } 实现类 : 方式1 : ( 实现类指定类型 ) public class genericInterfaceImpl implements genericInterface{ @Override public void method(String s) { System.out.println(s); } } 方式2 : ( 创建对象时指定类型 ) public class genericInterfaceImpl implements genericInterface{ @Override public void method(E e) { System.out.println(e); } } 泛型通配符 ? --- 代表任意的数据类型 使用方式 : 不能创建对象使用 只能作为方法的参数使用 e.g. 定义一个方法遍历一个ArrayList, 由于不知道ArrayList存的是什么数据类型, 就在参数中使用 ? 由于泛型没有继承概念, 参数不可以使用Object public class demo05 { public static void main(String[] args) { ArrayList l1 = new ArrayList<>(); l1.add(1); l1.add(2); ArrayList l2 = new ArrayList<>(); l2.add(\"hahaha\"); l2.add(\"hehehe\"); printArray(l1); printArray(l2); } public static void printArray(ArrayList list) { // 不能用object Iterator it = list.iterator(); while(it.hasNext()) { Object o = it.next(); System.out.println(o); } } } /* out : 1 2 hahaha hehehe */ 泛型的上下限限定 ? extends x : 限定上限, 必须是x类型或者是x类型的子类 ? super x : 限定下限, 必须是x类型或者是x类型的父类 栗子 : public static void getElement1(Collection coll) {} // 必须是Number类型或者其子类 public static void getElement2(Collection coll) {} // 必须是Number类型或者其父类 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/04-linux学习/":{"url":"roccoshi_note/04-linux学习/","title":"04-linux学习","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/04-linux学习/常用的linux命令/":{"url":"roccoshi_note/04-linux学习/常用的linux命令/","title":"常用的linux命令","keywords":"","body":"1. cd2. ls3. grep4. find5. cp6. mv7. rm8. ps (process) 查看进程9. kill10. killall11. file12. tar 压缩13. cat14. chgrp 改变用户组15. chmod 改变文件权限16. time 参考 1. cd cd /root/Docements # 切换到目录/root/Docements cd ./path # 切换到当前目录下的path目录中，“.”表示当前目录 cd ../path # 切换到上层目录中的path目录中，“..”表示上一层目录 2. ls -l ：列出长数据串，包含文件的属性与权限数据等 -a ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用） -d ：仅列出目录本身，而不是列出目录的文件数据 -h ：将文件容量以较易读的方式（GB，kB等）列出来 -R ：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来 ls -l列出的含义 : 3. grep grep [-acinv] [--color=auto] '查找字符串' filename -a ：将binary文件以text文件的方式查找数据 -c ：计算找到‘查找字符串’的次数 -i ：忽略大小写的区别，即把大小写视为相同 -v ：反向选择，即显示出没有‘查找字符串’内容的那一行 grep命令常与管道结合使用, 如 : ls -l | grep -i file 4. find find [PATH] [option] [action] # 与时间有关的参数： -mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件； -mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名； -mtime -n : 列出在n天之内（含n天本身）被更改过的文件名； -newer file : 列出比file还要新的文件名 # 例如： find /root -mtime 0 # 在当前目录下查找今天之内有改动的文件 # 与用户或用户组名有关的参数： -user name : 列出文件所有者为name的文件 -group name : 列出文件所属用户组为name的文件 -uid n : 列出文件所有者为用户ID为n的文件 -gid n : 列出文件所属用户组为用户组ID为n的文件 # 例如： find /home/ljianhui -user ljianhui # 在目录/home/ljianhui中找出所有者为ljianhui的文件 # 与文件权限及名称有关的参数： -name filename ：找出文件名为filename的文件 -size [+-]SIZE ：找出比SIZE还要大（+）或小（-）的文件 -tpye TYPE ：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f)、设备文件（b、c）、 目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）； -perm mode ：查找文件权限刚好等于mode的文件，mode用数字表示，如0755； -perm -mode ：查找文件权限必须要全部包括mode权限的文件，mode用数字表示 -perm +mode ：查找文件权限包含任一mode的权限的文件，mode用数字表示 # 例如： find / -name passwd # 查找文件名为passwd的文件 find . -perm 0755 # 查找当前目录中文件权限的0755的文件 find . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte 5. cp -a ：将文件的特性一起复制 -p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份 -i ：若目标文件已经存在时，在覆盖时会先询问操作的进行 -r ：递归持续复制，用于目录的复制行为 -u ：目标文件与源文件有差异时才会复制 e.g. cp -a file1 file2 #连同文件的所有特性把文件file1复制成文件file2 cp file1 file2 file3 dir #把文件file1、file2、file3复制到目录dir中 6. mv -f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖 -i ：若目标文件已经存在，就会询问是否覆盖 -u ：若目标文件已经存在，且比目标文件新，才会更新 7. rm -f ：就是force的意思，忽略不存在的文件，不会出现警告消息 -i ：互动模式，在删除前会询问用户是否操作 -r ：递归删除，最常用于目录删除，它是一个非常危险的参数 8. ps (process) 查看进程 -A ：所有的进程均显示出来 -a ：不与terminal有关的所有进程 -u ：有效用户的相关进程 -x ：一般与a参数一起使用，可列出较完整的信息 -l ：较长，较详细地将PID的信息列出 常用搭配 : ps aux # 查看系统所有的进程数据 ps ax # 查看不与terminal有关的所有进程 ps -lA # 查看系统所有的进程数据 ps axjf # 查看连同一部分进程树状态 9. kill 向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用 kill -signal PID #常用参数 (代号) 1：SIGHUP，启动被终止的进程 2：SIGINT，相当于输入ctrl+c，中断一个程序的进行 9：SIGKILL，强制中断一个进程的进行 15：SIGTERM，以正常的结束进程方式来终止进程 17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行 10. killall 向一个命令启动的进程发送一个信号 killall [-iIe] [command name] -i ：交互式的意思，若需要删除时，会询问用户 -e ：表示后面接的command name要一致，但command name不能超过15个字符 -I ：命令名称忽略大小写 # 例如： killall -SIGHUP syslogd # 重新启动syslogd 11. file file filename # 查看文件属性 用法如下 : 12. tar 压缩 -c ：新建打包文件 -t ：查看打包文件的内容含有哪些文件名 -x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中 -j ：通过bzip2的支持进行压缩/解压缩 -z ：通过gzip的支持进行压缩/解压缩 -v ：在压缩/解压缩过程中，将正在处理的文件名显示出来 -f filename ：filename为要处理的文件 -C dir ：指定压缩/解压缩的目录dir 压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称 查询：tar -jtv -f filename.tar.bz2 解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录 13. cat 查看文件 查看文件的其他命令 : tac : 从最后一行开始 nl : 显示行号 more : 一页一页显示 less : 与more类似, 可以往前翻页 head : 只看头几行 ( -n控制行号 ) tail : 只看尾几行 ( -n控制行号 ) 14. chgrp 改变用户组 chgrp [-R] dirname/filename -R ：进行递归的持续对所有文件和子目录更改 # 例如： chgrp users -R ./dir # 递归地把dir目录下中的所有文件和子目录下所有文件的用户组修改为users 15. chmod 改变文件权限 参考 : https://www.runoob.com/linux/linux-comm-chmod.html 例子 : 将文件 file1.txt 设为所有人皆可读取 : chmod ugo+r file1.txt 将文件 file1.txt 设为所有人皆可读取 : chmod a+r file1.txt 将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 : chmod ug+w,o-w file1.txt file2.txt 将 ex1.py 设定为只有该文件拥有者可以执行 : chmod u+x ex1.py 将目前目录下的所有文件与子目录皆设为任何人可读取 : chmod -R a+r * 此外chmod也可以用数字来表示权限如 : chmod 777 file 语法为： chmod abc file ---------------------- chmod a=rwx file 和 chmod 777 file 效果相同 chmod ug=rwx,o=x file 和 chmod 771 file 效果相同 16. time 测算一个命令（即程序）的执行时间 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/05-github操作/":{"url":"roccoshi_note/05-github操作/","title":"05-github操作","keywords":"","body":"GITHUB高级搜索常用git命令1 | 增删文件2 | 代码提交3 | 分支4 | 标签5 | 查看信息6 | 远程同步7 | 撤销解决每次提交都要输入用户密码GITHUB 高级搜索 descirption code 在仓库名中搜索 in:name projectx 在描述中搜索 in:descripton peojectx 寻找star>100的projectx stars:>100 projectx 寻找fork>100的projecty forks:>100 projecty 寻找仓库大小>5MB的projectx size:>5000 projectx 寻找某日期之后更新的项目 pushed:>2020-01-03 projectx 明确仓库语言 language:java projectx 明确作者 user:rocco projectx 明确组织 org:webgroup projectx 「综合使用」 空格分隔即可 常用git命令 # 名词 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 1 | 增删文件 # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] # 生成一个可供发布的压缩包 $ git archive 2 | 代码提交 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 3 | 分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 4 | 标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 5 | 查看信息 # 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat \"@{0 day ago}\" # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog 6 | 远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 7 | 撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop ref : 阮一峰 解决每次提交都要输入用户密码 git remote -v查看是否使用的https 修改成ssh方式 git remote rm origin git remote add origin [ssh地址] git push -u origin master 如果没添加 ssh-key : 生成rsa ssh-key : ssh-keygen -t rsa -C \"your_email@example.com\" # -t 指定密钥类型，默认是 rsa ，可以省略。 # -C 设置注释文字，比如邮箱。 # -f 指定密钥文件存储文件名。 进入~/.ssh目录 复制id_rsa.pub文件 ( 公钥 ) 登录github账号，进入Account Settings，然后点击菜单栏的 SSH key 进入页面添加 SSH key。 测试一下是否成功, git bash输入$ ssh -T git@github.com如果出现Hi xxx! You've successfully authenticated, but GitHub does not provide shell access.说明配置成功 重复之前操作, 修改remote address为ssh方式即可 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/06-模电/":{"url":"roccoshi_note/06-模电/","title":"06-模电","keywords":"","body":"模电复习要点第一章 PN结 二极管 三极管第二章 放大电路分析基础第三章 频率特性第四章 场效应管放大电路第五章 负反馈放大电路第六章 集成运算放大器第七章 集成运放第九章 低频功率放大电路第十章 直流稳压电路--- layout: post title: analogue slug: analogue date: 2020-08-07 9:08 status: publish author: roccoshi categories: - Study tags: - Study - Course --- 模电复习要点 课件pdf地址 : https://cutt.ly/1dFyUaq 题型 : 填空 : 30空 30分 简答 : A卷 5个25分 B卷 4个24分 计算 : 4个计算题 —— 15分, 10分, 10分, 10分 第一章 PN结 二极管 三极管 1.1 | 什么是杂质半导体, 分了哪2类, 本征半导体...掺杂几价元素, 多数载流子, 少数载流子 本征半导体 ( 纯净 ) : 本征掺杂+5价元素 —— N型半导体 —— 多数载流子是自由电子 本征掺杂+3价元素 —— P型半导体 —— 多数载流子是空穴 1.2 | PN结单向导电性如何体现, 加正向电压外电场和内电场方向, 耗尽层变宽还是变窄 PN结加正向电压 —— 削弱自建场作用，扩散运动 > 漂流运动，耗尽层变窄 PN结加反向电压 —— 漂移＞扩散，耗尽层变宽 1.3 | PN结的击穿 : 雪崩击穿，齐纳击穿如何区分 1.4 | PN结的电容效应 : 势垒电容, 扩散电容 正偏：扩散电容 反偏：势垒电容 1.5 | 二极管的应用 : 双向限幅电路 每一个二极管什么情况下导通 什么情况下截止, 输入一个正弦波, 画出输出波形 「第一章课后习题16题」 答案 : 1.6 | 特殊的二极管 : 正常工作的工作状态 ( PN结正向导通or反向导通or截止or击穿 ) 如稳压二极管, 光敏二极管是咋样的 稳压二极管 : 原理 : PN结的反向击穿特性 发光二极管LED : 工作条件 : 正偏 光敏二极管 : 工作条件 : 反偏 ( 反向电流强度与光照度成正比 ) 1.7 | 三极管 : PNP, NPN的类型, 特性曲线 ( 输入特性曲线, 输出特性曲线 ) | 放大区, 饱和区, 截止区 | 三极管实现放大的内部条件 | 各个区的发射结和集电结的工作状态 ( 正偏反偏 ) 给出三极管上三个级的电压, 判断NPN or PNP , 硅 or 锗 , CBE级判定 | 三极管实现放大的内部条件 : ( 发射区重参杂, 基区非常薄, 集电区面积大 ) 三极管的输入特性曲线 : Uce不变时Ube和Ib之间的关系就是输入曲线 三极管的输出特性曲线 : Ib不变时Ic和Uce之间的关系 温度升高, 输入特性曲线左移, 输出特性曲线上移 判断问题 : 2入1出NPN, 2出1入PNP, 放大区Ie永远最大 第二章 放大电路分析基础 2.1 | 放大电路的直流通路和交流通路 直流通路 : 断路Ui交流电源, 电容开路 交流通路 : Ucc接地, 短路电容 2.2 | 放大电路的直流工作状态 ( 静态工作点 ) 静态工作点 : IBQICQUBEQUCEQ \\text{I}_{\\text{BQ}}\\,\\, \\text{I}_{\\text{CQ}}\\,\\, \\text{U}_{\\text{BEQ}}\\,\\, \\text{U}_{\\text{CEQ}} I​BQ​​I​CQ​​U​BEQ​​U​CEQ​​ 首先Ube可以直接由硅/锗管确定 ( 0.7 0.3) 然后由电压关系计算Ibq -- Icq 最后计算Uceq 2.3 | 微变等效电路的画法 ( 交流通路---三个级---等效电路---用微变模型替换 ) 注意rbe的计算 : rbe=rbb+(1+β)26IEQ(Ω)(IEQ 取 mA)r_{b e}=r_{b b}+(1+\\beta) \\frac{26}{I_{E Q}}(\\Omega) \\quad\\left(I_{E Q} \\text { 取 } m A\\right)r​be​​=r​bb​​+(1+β)​I​EQ​​​​26​​(Ω)(I​EQ​​ 取 mA) 2.4 | 表2-2 三种基本组态放大电路的分析 共基 共射 共集 以及各自的特点 表2-2 共集电极 : 没有电压放大能力 ( Au≈1 ), 输入输出同相, 「电压跟随器」 共射极 : Au较大, 输入输出反相, 应用广泛 共基极 : Au = 共射极, 但是输入输出同相, 通频带宽 没有放大能力的是哪个 ( 共集 ), 输入电流和输出电流反向的是什么 ( 共射 )等等 2.5 | 工作点稳定电路 当温度升高时, 除了Ube减小, 其他的 ( β, Icbo, Iceo )均增大 偏置电路, 此时Ub被认为恒定不变 2.6| 多级放大电路 耦合方式---直接耦合,变压器耦合,阻容耦合, 每一类耦合方式的特点和缺点 ( 了解 ) 多级放大电路的放大倍数是每一级放大倍数的乘积 ( 分贝如何表示 ) 输入电阻是第一级的输入电阻 输出电阻是最后一级的输出电阻 放大倍数 = 各级放大倍数之积 增益 = 分贝之和 ( 电压放大倍数的分贝 = 20lg(Au) ) 会出这个种题(说漏嘴啦) : 前面是一个三极管基本放大 + 第二级是集成运放 问 : 组态, 输入输出关系, 再问输入电压和输出电压的关系 第三章 频率特性 3.1 | 本章作了解 课后习题了解1,2题 注意3分贝和0.707 0.707Um对应的两个频率分别为上限频率和下限频率 课后习题1, 2 第四章 场效应管放大电路 要求 : 夹断电压, 漏极饱和电流 对应在转移特性和输入特性图上是什么 场效应管的符号和特性分析 每一类场效应管的符号 —— 是结型or绝缘栅型 增强型or耗尽型 是N沟道orP沟道 ... Ugs怎么求... 如何根据图确定类型 根据转移特性和输出特性确定类型 4.1 | 结构, 类型, 输入输出关系 ( 了解, 不要求计算 ) 漏极D ( 对应C ) 栅极G ( 对应B ) 源极S ( 对应E ) 分类 : 结型 绝缘栅型 增强型 耗尽型 结型 : ( N沟道为例, P沟道完全相反即可 ) 特点 : $V{GS}$反向增加到夹断电压$V_P$时产生夹断, 当$V{GD} = V{GS}-V{DS} = V_P$时产生预夹断 结型场效应管 | 类型 | 符号 | 转移特性 | 输出特性 绝缘栅型 : 结型 绝缘栅型 转移特性 输出特性 第五章 负反馈放大电路 5.1 | 反馈的基本概念 电压反馈, 电流反馈 | 直流反馈, 交流反馈 | 串联反馈, 并联反馈 | 局部反馈, 级间反馈 5.2 | 负反馈对放大电路性能的影响 降低放大倍数， 提高放大倍数的稳定性 改变输入电阻和输出电阻 稳定输出信号 ( 输出电压, 输出电流 ) 展宽通频带 减小非线性失真 5.3 | 1 + AF倍——增大就是乘( 1+AF ), 减小就是除( 1+AF ) ( 一个填空/简答 电压or电流or串联or并联负 反馈增大还是减小了输入还是输出电阻啊? ) 并联负反馈使输入电阻减小，串联负反馈使输入电阻增大 电压负反馈使输出电阻减小，电流负反馈使输出电阻增大 5.4 | 指标计算不要求 第六章 集成运算放大器 6.1 | 什么是零点漂移 当输入为0时，输出信号不为零。一般由温度引起 6.2 | 差模放大倍数$Ad$ 共模放大倍数$A_c$ 共模抑制比$K{CMR}$ KCMR=∣AdAc∣ K_{CMR} = \\left| \\frac{A_{d}}{A_{c}}\\right| K​CMR​​=​∣​∣​∣​∣​​​A​c​​​​A​d​​​​​∣​∣​∣​∣​​ 在参数理想对称的情况下$K_{CMR}$ = ∞ 长尾抑制共模信号 放大差模信号 6.3| 题目 : 给出差动放大电路和两端输入信号u1和u2 ( 一般输入情况 ), 利用差动放大电路, 由u1和u2求最后的输出电压 | 6.2.6 「一般输入情况」例题, PPT差动放大电路的4种解法 一般输入信号情况 注意差模输入电压 ( 分量 )为两者之差没有除以二, 共模输入电压除以二 6.2.6题目 6.2.6 一般输入信号情况 | 例题 差模放大倍数为负 ( 双端输入 ) 差模输入为u1 - u2 ( 而不是u2 - u1, 不一样 ) 要把dB化为比例的值 之后内容不要求 第七章 集成运放 比例, 求和电路和电路设计都是重点 7.1 | 理解理想集成运放的具体参数, 开环差模放大倍数, 共模抑制比啥啥啥什么是无穷大什么是0 | 什么是虚短和什么是虚断 | 根据电路的结构列出输入和输出的关系 关于理想化参数指标 : 开环差模电压放大倍数 : $A_{od}=∞$ 输入电阻ri : ∞ 输出电阻ro : 0 输入偏置电阻 : 0 共模抑制比$K_{CMR}$ : ∞ 关于虚短和虚断, 虚地 : 虚短 : $U+\\approx U-$ 虚断 : $I+\\approx I-\\approx 0$ 虚地 : 运放在反相输入状态下 ( 同相接地, 此时$U+\\approx U-\\approx 0$ 同相输入和反相输入 同相输入和反相输入 加减运算电路 同相求和和反相求和 加减运算电路 7.2 | 题 : 给U = xxU1 + xxU2, 首推「两级运放」构成的求和电路 例题 : 设计一个加减运算电路, $R{F}=240 \\mathrm{k} \\Omega$ , 使得满足 : $\\boldsymbol{u}{o}=\\mathbf{1 0} \\boldsymbol{u}{i 1}+\\boldsymbol{8} \\boldsymbol{u}{i 2}-\\mathbf{2 0} \\boldsymbol{u}_{i 3}$ 方法一 | 单级运放电路 单级运放答案 问题 : 计算并联关系不方便 方法二 | 两级运放电路 常用形式 Uo1=−Rf(1R3Ui3+1R4Ui4)Uo=−Rf(1RfUo1+1R1Ui1+1R2Ui2)=Rf(1R3Ui3+1R4Ui4−1R1Ui1−1R2Ui2) \\begin{aligned} \tU_{o_1}&=-R_f\\left( \\frac{1}{R_3}U_{i_3}+\\frac{1}{R_4}U_{i_4} \\right)\\\\ \tU_o&=-R_f\\left( \\frac{1}{R_f}U_{o_1}+\\frac{1}{R_1}U_{i_1}+\\frac{1}{R_2}U_{i_2} \\right)\\\\ \t&=R_f\\left( \\frac{1}{R_3}U_{i_3}+\\frac{1}{R_4}U_{i_4}-\\frac{1}{R_1}U_{i_1}-\\frac{1}{R_2}U_{i_2} \\right)\\\\ \\end{aligned} ​U​o​1​​​​​U​o​​​​​​​=−R​f​​(​R​3​​​​1​​U​i​3​​​​+​R​4​​​​1​​U​i​4​​​​)​=−R​f​​(​R​f​​​​1​​U​o​1​​​​+​R​1​​​​1​​U​i​1​​​​+​R​2​​​​1​​U​i​2​​​​)​=R​f​​(​R​3​​​​1​​U​i​3​​​​+​R​4​​​​1​​U​i​4​​​​−​R​1​​​​1​​U​i​1​​​​−​R​2​​​​1​​U​i​2​​​​)​​ 7.3 | 滤波电路不要求 7.4 | 电压比较器清楚7.4.1 会根据比较器电路画出传输特性图, 给你一个比较器电路和输入波形画出输出波形 双向限幅比较器 9, 10章不要看书了, 就看ppt 第九章 低频功率放大电路 了解 : 三类放大电路, 甲类乙类甲乙类 清楚三类电路的特点, 哪一类电路的转化效率最高啊, 哪种电路的失真最小啊 交越失真是什么, 如何消除呢? 甲类, 乙类, 甲乙类的特点 : 功率放大器分类 : 甲类 乙类 甲乙类 甲类工作状态失真小, 静态电流大, 管耗大, 效率低 乙类工作状态失真大, 静态电流为0, 管耗小, 效率高 甲乙类工作状态失真大, 静态电流小, 管耗小, 效率较高 交越失真 : 交越失真的解释 为解决交越失真，可给三极管稍稍加一点偏置，使之工作在甲乙类。 第十章 直流稳压电路 直流稳压电源包括哪些部分, 每一个部分的功能是什么 集成稳压电路的命名规则, 输出的值, 最大输出电压, 最大输出电流是多少 CW79M05输出电压是多少呢, 输出电流是多少呢 5V还是-5V 1.5A还是... 78系列, 79系列构成放大电路, 推输出和输入的关系, 求解输出电压的表达式 10.1 | 直流稳压电源包括哪些部分, 每一个部分的功能是什么 组成部分 交流电网 --- 变压器 --- 整流电路 --- 滤波电路 --- 稳压电路 --- 直流 --- 负载 整流电路 : 利用二极管的单向导电性, 将正负交替的交流电压变换成单方向的直流脉动电压 滤波电路 : 消除电压的脉动成分 滤波电路 稳压电路 : 使得输出电压基本上不随交流电网的电压波动或负载而变化 10.2 | 集成稳压电路的命名规则, 78, 79系列 命名规则 : 78 79系列型号命名 如CW78L05CW78 : 正 --- L : 输出电流100mA --- 05 : 输出电压5V Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/":{"url":"roccoshi_note/07-前端学习/","title":"07-前端学习","keywords":"","body":" 这将是一个大杂烩式的记录 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/01.Javascript/":{"url":"roccoshi_note/07-前端学习/01.Javascript/","title":"01.Javascript","keywords":"","body":"本笔记大部分内容完全copy自 : 廖雪峰的JavaScript教程 可能有部分有所删减 主要用于本人的复习, 如果有同学无意看到了这里, 请移步廖雪峰的JavaScript教程获取更全面的教学 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/01.Javascript/04.浏览器/":{"url":"roccoshi_note/07-前端学习/01.Javascript/04.浏览器/","title":"04.浏览器","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/01.Javascript/04.浏览器/4.1 浏览器对象.html":{"url":"roccoshi_note/07-前端学习/01.Javascript/04.浏览器/4.1 浏览器对象.html","title":"4.1 浏览器对象","keywords":"","body":"4.1 浏览器对象windownavigatorscreenlocationdocumenthistory4.1 浏览器对象 window window对象不但充当全局作用域，而且表示浏览器窗口。 window对象有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。 对应的，还有一个outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高。 navigator navigator对象表示浏览器的信息，最常用的属性包括： navigator.appName：浏览器名称； navigator.appVersion：浏览器版本； navigator.language：浏览器设置的语言； navigator.platform：操作系统类型； navigator.userAgent：浏览器设定的User-Agent字符串。 注意，navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。很多初学者为了针对不同浏览器编写不同的代码，喜欢用if判断浏览器版本，例如： var width; if (getIEVersion(navigator.userAgent) 但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回undefined的特性，直接用短路运算符||计算： var width = window.innerWidth || document.body.clientWidth; screen screen对象表示屏幕的信息，常用的属性有： screen.width：屏幕宽度，以像素为单位； screen.height：屏幕高度，以像素为单位； screen.colorDepth：返回颜色位数，如8、16、24。 location location对象表示当前页面的URL信息。例如，一个完整的URL： http://www.example.com:8080/path/index.html?a=1&b=2#TOP 可以用location.href获取。要获得URL各个部分的值，可以这么写： location.protocol; // 'http' - 协议 location.host; // 'www.example.com' - 域名 location.port; // '8080' - 端口 location.pathname; // '/path/index.html' - 路径 location.search; // '?a=1&b=2' - get请求 location.hash; // 'TOP' - 不知道是什么 要加载一个新页面，可以调用location.assign()。如果要重新加载当前页面，调用location.reload()方法 document document对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。 document的title属性是从HTML文档中的xxx读取的，但是可以动态改变 用document对象提供的getElementById()和getElementsByTagName()可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点： 可以通过document.cookie读取到当前页面的Cookie 安全问题 由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，这是因为在HTML页面中引入第三方的JavaScript代码是允许的： ... 如果引入的第三方的JavaScript中存在恶意代码，则www.foo.com网站将直接获取到www.example.com网站的用户登录信息。 为了解决这个问题，服务器在设置Cookie时可以使用httpOnly，设定了httpOnly的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持httpOnly选项，IE从IE6 SP1开始支持。 为了确保安全，服务器端在设置Cookie时，应该始终坚持使用httpOnly。 history history对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。 这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用history.back()可能会让用户感到非常愤怒。 新手开始设计Web页面时喜欢在登录页登录成功时调用history.back()，试图回到登录前的页面。这是一种错误的方法。 任何情况，你都不应该使用history这个对象了。 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/01.Javascript/04.浏览器/4.2 操作DOM.html":{"url":"roccoshi_note/07-前端学习/01.Javascript/04.浏览器/4.2 操作DOM.html","title":"4.2 操作DOM","keywords":"","body":"4.2 操作DOM拿到dom节点的两种方式document.getElementById()querySelector()举例更新DOM修改css插入DOMinsertBefore 插入到特定位置练习删除DOM练习4.2 操作DOM 由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。 始终记住DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作： 更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容； 遍历：遍历该DOM节点下的子节点，以便进行进一步操作； 添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点； 删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。 拿到dom节点的两种方式 document.getElementById() 在操作一个DOM节点前，我们需要通过各种方式先拿到这个DOM节点。最常用的方法是document.getElementById()和document.getElementsByTagName()，以及CSS选择器document.getElementsByClassName()。 由于ID在HTML文档中是唯一的，所以document.getElementById()可以直接定位唯一的一个DOM节点。document.getElementsByTagName()和document.getElementsByClassName()总是返回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。 例如： // 返回ID为'test'的节点： var test = document.getElementById('test'); // 先定位ID为'test-table'的节点，再返回其内部所有tr节点： var trs = document.getElementById('test-table').getElementsByTagName('tr'); // 先定位ID为'test-div'的节点，再返回其内部所有class包含red的节点： var reds = document.getElementById('test-div').getElementsByClassName('red'); // 获取节点test下的所有直属子节点: var cs = test.children; // 获取节点test下第一个、最后一个子节点： var first = test.firstElementChild; var last = test.lastElementChild; querySelector() 第二种方法是使用querySelector()和querySelectorAll()，需要了解selector语法，然后使用条件来获取节点，更加方便： // 通过querySelector获取ID为q1的节点： var q1 = document.querySelector('#q1'); // 通过querySelectorAll获取q1节点内的符合条件的所有节点： var ps = q1.querySelectorAll('div.highlighted > p'); 举例 JavaScript Java Python Ruby Swift Scheme Haskell // 选择JavaScript: var js = document.getElementById('test-p'); // 方法1 var js = document.querySelector('#test-p'); // 方法2 // 选择Python,Ruby,Swift: var arr = document.getElementsByClassName('c-red')[1].getElementsByTagName('p'); // 1 var arr = document.getElementsByClassName('c-red')[1].children; // 2 var arr = document.querySelectorAll('div.c-red.c-green > p'); // 3 var arr = document.querySelectorAll('.c-red.c-green > p'); //4 var arr = document.querySelectorAll('div[class=\"c-red c-green\"] > p'); //5 // 选择Haskell: var haskell = document.getElementsByClassName('c-green')[1].getElementsByTagName('p')[1]; //1 var haskell = document.getElementsByClassName('c-green')[1].lastElementChild; //2 var haskell = document.querySelectorAll('div[class=\"c-green\"] > p')[1]; //3 var haskell = document.querySelectorAll('.c-green > p')[4]; //4 更新DOM 到一个DOM节点后，我们可以对它进行更新。 可以直接修改节点的文本，方法有两种： 一种是修改innerHTML属性，这个方式非常强大，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树： // 获取... var p = document.getElementById('p-id'); // 设置文本为abc: p.innerHTML = 'ABC'; // ABC // 设置HTML: p.innerHTML = 'ABC RED XYZ'; // ...的内部结构已修改 用innerHTML时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免XSS攻击。 XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。 这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。 第二种是修改innerText或textContent属性，这样可以自动对字符串进行HTML编码，保证无法设置任何HTML标签： // 获取... var p = document.getElementById('p-id'); // 设置文本: p.innerText = 'alert(\"Hi\")'; // HTML被自动编码，无法设置一个节点: // &lt;script&gt;alert(\"Hi\")&lt;/script&gt; 修改css 修改CSS也是经常需要的操作。DOM节点的style属性对应所有的CSS，可以直接获取或设置。因为CSS允许font-size这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名fontSize： // 获取... var p = document.getElementById('p-id'); // 设置CSS: p.style.color = '#ff0000'; p.style.fontSize = '20px'; p.style.paddingTop = '2em'; 插入DOM 当我们获得了某个DOM节点，想在这个DOM节点内插入新的DOM，应该如何做？ 如果这个DOM节点是空的，例如，，那么，直接使用innerHTML = 'child'就可以修改DOM节点的内容，相当于“插入”了新的DOM节点。 如果这个DOM节点不是空的，那就不能这么做，因为innerHTML会直接替换掉原来的所有子节点。 有两个办法可以插入新的节点。一个是使用appendChild，把一个子节点添加到父节点的最后一个子节点。例如： JavaScript Java Python Scheme 把JavaScript添加到的最后一项： var js = document.getElementById('js'), list = document.getElementById('list'); list.appendChild(js); 现在，HTML结构变成了这样： Java Python Scheme JavaScript 因为我们插入的js节点已经存在于当前的文档树，因此这个节点首先会从原先的位置删除，再插入到新的位置。 更多的时候我们会从零创建一个新的节点，然后插入到指定位置： var list = document.getElementById('list'), haskell = document.createElement('p'); haskell.id = 'haskell'; haskell.innerText = 'Haskell'; list.appendChild(haskell); 这样我们就动态添加了一个新的节点： Java Python Scheme Haskell 动态创建一个节点然后添加到DOM树中，可以实现很多功能。举个例子，下面的代码动态创建了一个节点，然后把它添加到节点的末尾，这样就动态地给文档添加了新的CSS定义： var d = document.createElement('style'); d.setAttribute('type', 'text/css'); d.innerHTML = 'p { color: red }'; document.getElementsByTagName('head')[0].appendChild(d); insertBefore 插入到特定位置 如果我们要把子节点插入到指定的位置怎么办？可以使用parentElement.insertBefore(newElement, referenceElement);，子节点会插入到referenceElement之前。 还是以上面的HTML为例，假定我们要把Haskell插入到Python之前： Java Python Scheme 可以这么写： var list = document.getElementById('list'), ref = document.getElementById('python'), haskell = document.createElement('p'); haskell.id = 'haskell'; haskell.innerText = 'Haskell'; list.insertBefore(haskell, ref); 新的HTML结构如下： Java Haskell Python Scheme 可见，使用insertBefore重点是要拿到一个“参考子节点”的引用。很多时候，需要循环一个父节点的所有子节点，可以通过迭代children属性实现： var i, c, list = document.getElementById('list'); for (i = 0; i 练习 对于一个已有的HTML结构： Haskell JavaScript Python Ruby Scheme Scheme JavaScript Python Ruby Haskell 按字符串顺序重新排序DOM节点： 我的方法: // sort list: var list = document.getElementsByClassName(\"lang\"); var arrList = Array.from(list); arrList.sort((x,y) => { return x.innerText.toLowerCase()>y.innerText.toLowerCase() ? 1:-1; } ); arrList.forEach(x => console.log(x.innerText)); var afList = document.getElementById(\"test-list\"); afList.innerHTML = \"\"; arrList.forEach(x => afList.appendChild(x)); 大佬的: var arr_list=Array.from(document.getElementById('test-list').children); var arr_lang=Array.from(document.getElementsByClassName(\"lang\"),item=>item.innerText); arr_lang.sort(); arr_list.map((x,i)=>{x.innerText=arr_lang[i]}); //Array.from可以用扩展运算符[...]代替 //如Array.from(document.getElementById('test-list').children); //可以写成 : [...document.getElementById('test-list').children]; Array.from把document get到的对象转换成数组了, 且在得到的数组里修改innerHTML可以直接修改到对象 ( 个人总结, 不准确 ) 删除DOM 删除一个DOM节点就比插入要容易得多。 要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉： // 拿到待删除节点: var self = document.getElementById('to-be-removed'); // 拿到父节点: var parent = self.parentElement; // 删除: var removed = parent.removeChild(self); removed === self; // true 注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。 当你遍历一个父节点的子节点并进行删除操作时，要注意，children属性是一个只读属性，并且它在子节点变化时会实时更新。 例如，对于如下HTML结构： First Second 当我们用如下代码删除子节点时： var parent = document.getElementById('parent'); parent.removeChild(parent.children[0]); parent.removeChild(parent.children[1]); // 浏览器报错：parent.children[1]不是一个有效的节点。原因就在于，当First节点被删除后，parent.children的节点数量已经从2变为了1，索引[1]已经不存在了。 因此，删除多个节点时，要注意children属性时刻都在变化。 练习 JavaScript Swift HTML ANSI C CSS DirectX 把与Web开发技术不相关的节点删掉： 'use strict'; var tar = document.querySelectorAll('li'); // 或var tar = [...document.getElementById(\"test-list\").getElementsByTagName('li')]; tar.forEach(x => { let l = x.innerHTML.length; if(l!=3 && l!=4 &&l!=10) // HTML，CSS，JavaScript保留 x.parentElement.removeChild(x); }); Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/01.Javascript/04.浏览器/4.3 操作表单.html":{"url":"roccoshi_note/07-前端学习/01.Javascript/04.浏览器/4.3 操作表单.html","title":"4.3 操作表单","keywords":"","body":"4.3 操作表单获取值设置值HTML5控件提交表单4.3 操作表单 HTML表单的输入控件主要有以下几种： 文本框，对应的，用于输入文本； 口令框，对应的，用于输入口令； 单选框，对应的，用于选择一项； 复选框，对应的，用于选择多项； 下拉框，对应的，用于选择一项； 隐藏文本，对应的，用户不可见，但表单提交时会把隐藏文本发送到服务器。 获取值 如果我们获得了一个节点的引用，就可以直接调用value获得对应的用户输入值： // var input = document.getElementById('email'); input.value; // '用户输入的值' 这种方式可以应用于text、password、hidden以及select。但是，对于单选框和复选框，value属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用checked判断： // Monday // Tuesday var mon = document.getElementById('monday'); var tue = document.getElementById('tuesday'); mon.value; // '1' tue.value; // '2' mon.checked; // true或者false tue.checked; // true或者false 设置值 设置值和获取值类似，对于text、password、hidden以及select，直接设置value就可以： // var input = document.getElementById('email'); input.value = 'test@example.com'; // 文本框的内容已更新 对于单选框和复选框，设置checked为true或false即可。 HTML5控件 HTML5新增了大量标准控件，常用的包括date、datetime、datetime-local、color等，它们都使用标签： HTML5控件 提交表单 最后，JavaScript可以以两种方式来处理表单的提交（AJAX方式在后面章节介绍）。 方式一是通过元素的submit()方法提交一个表单，例如，响应一个的click事件，在JavaScript代码中提交表单： Submit function doSubmitForm() { var form = document.getElementById('test-form'); // 可以在此修改form的input... // 提交form: form.submit(); } 这种方式的缺点是扰乱了浏览器对form的正常提交。浏览器默认点击时提交表单，或者用户在最后一个输入框按回车键。因此，第二种方式是响应本身的onsubmit事件，在提交form时作修改： Submit function checkForm() { var form = document.getElementById('test-form'); // 可以在此修改form的input... // 继续下一步: return true; } 注意要return true来告诉浏览器继续提交，如果return false，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。 在检查和修改时，要充分利用来传递数据。 例如，很多登录表单希望用户输入用户名和口令，但是，安全考虑，提交表单时不传输明文口令，而是口令的MD5。普通JavaScript开发人员会直接修改： Submit function checkForm() { var pwd = document.getElementById('password'); // 把用户输入的明文变为MD5: pwd.value = toMD5(pwd.value); // 继续下一步: return true; } 这个做法看上去没啥问题，但用户输入了口令提交时，口令框的显示会突然从几个*变成32个*（因为MD5有32个字符）。 要想不改变用户的输入，可以利用实现： Submit function checkForm() { var input_pwd = document.getElementById('input-password'); var md5_pwd = document.getElementById('md5-password'); // 把用户输入的明文变为MD5: md5_pwd.value = toMD5(input_pwd.value); // 继续下一步: return true; } 注意到id为md5-password的标记了name=\"password\"，而用户输入的id为input-password的没有name属性。没有name属性的的数据不会被提交。 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/01.Javascript/04.浏览器/4.4 操作文件.html":{"url":"roccoshi_note/07-前端学习/01.Javascript/04.浏览器/4.4 操作文件.html","title":"4.4 操作文件","keywords":"","body":"4.4 操作文件File API回调4.4 操作文件 在HTML表单中，可以上传文件的唯一控件就是。 注意：当一个表单包含时，表单的enctype必须指定为multipart/form-data，method必须指定为post，浏览器才能正确编码并以multipart/form-data格式发送表单的数据。 出于安全考虑，浏览器只允许用户点击来选择本地文件，用JavaScript对的value赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径 通常，上传的文件都由后台服务器处理，JavaScript可以在提交表单时对文件扩展名做检查，以便防止用户上传无效格式的文件： var f = document.getElementById('test-file-upload'); var filename = f.value; // 'C:\\fakepath\\test.png' if (!filename || !(filename.endsWith('.jpg') || filename.endsWith('.png') || filename.endsWith('.gif'))) { alert('Can only upload image file.'); return false; } File API 由于JavaScript对用户上传的文件操作非常有限，尤其是无法读取文件内容，使得很多需要操作文件的网页不得不用Flash这样的第三方插件来实现。 随着HTML5的普及，新增的File API允许JavaScript读取文件内容，获得更多的文件信息。 HTML5的File API提供了File和FileReader两个主要对象，可以获得文件信息并读取文件。 下面的例子演示了如何读取用户选取的图片文件，并在一个中预览图像： var fileInput = document.getElementById('test-image-file'), info = document.getElementById('test-file-info'), preview = document.getElementById('test-image-preview'); // 监听change事件: fileInput.addEventListener('change', function () { // 清除背景图片: preview.style.backgroundImage = ''; // 检查文件是否选择: if (!fileInput.value) { info.innerHTML = '没有选择文件'; return; } // 获取File引用: var file = fileInput.files[0]; // 获取File信息: info.innerHTML = '文件: ' + file.name + '' + '大小: ' + file.size + '' + '修改: ' + file.lastModifiedDate; if (file.type !== 'image/jpeg' && file.type !== 'image/png' && file.type !== 'image/gif') { alert('不是有效的图片文件!'); return; } // 读取文件: var reader = new FileReader(); reader.onload = function(e) { var data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...' preview.style.backgroundImage = 'url(' + data + ')'; }; // 以DataURL的形式读取文件: reader.readAsDataURL(file); }); 上面的代码演示了如何通过HTML5的File API读取文件内容。以DataURL的形式读取到的文件是一个字符串，类似于data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...，常用于设置图像。如果需要服务器端处理，把字符串base64,后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。 回调 上面的代码还演示了JavaScript的一个重要的特性就是单线程执行模式。在JavaScript中，浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行。 你可能会问，单线程模式执行的JavaScript，如何处理多任务？ 在JavaScript中，执行多任务实际上都是异步调用，比如上面的代码： reader.readAsDataURL(file); 就会发起一个异步操作来读取文件内容。因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，因此需要先设置一个回调函数： reader.onload = function(e) { // 当文件读取完成后，自动调用此函数: }; 当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数。执行回调函数时，文件已经读取完毕，所以我们可以在回调函数内部安全地获得文件内容。 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/01.Javascript/04.浏览器/4.5 AJAX.html":{"url":"roccoshi_note/07-前端学习/01.Javascript/04.浏览器/4.5 AJAX.html","title":"4.5 AJAX","keywords":"","body":"4.5 AJAX4.5 AJAX Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/01.Javascript/05.jQuery/":{"url":"roccoshi_note/07-前端学习/01.Javascript/05.jQuery/","title":"05.jQuery","keywords":"","body":"jQuery版本使用jQuery$符号江湖传言，全世界大约有80~90%的网站直接或间接地使用了jQuery。鉴于它如此流行，又如此好用，所以每一个入门JavaScript的前端工程师都应该了解和学习它。 jQuery这么流行，肯定是因为它解决了一些很重要的问题。实际上，jQuery能帮我们干这些事情： 消除浏览器差异：你不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写AJAX等代码； 简洁的操作DOM的方法：写$('#test')肯定比document.getElementById('test')来得简洁； 轻松实现动画、修改CSS等各种操作。 jQuery的理念“Write Less, Do More“，让你写更少的代码，完成更多的工作！ jQuery版本 目前jQuery有1.x和2.x两个主要版本，区别在于2.x移除了对古老的IE 6、7、8的支持，因此2.x的代码更精简。选择哪个版本主要取决于你是否想支持IE 6~8。 从jQuery官网可以下载最新版本。jQuery只是一个jquery-xxx.js文件，但你会看到有compressed（已压缩）和uncompressed（未压缩）两种版本，使用时完全一样，但如果你想深入研究jQuery源码，那就用uncompressed版本。 使用jQuery 使用jQuery只需要在页面的引入jQuery文件即可： ... ... $符号 $是著名的jQuery符号。实际上，jQuery把所有功能全部封装在一个全局变量jQuery中，而$也是一个合法的变量名，它是变量jQuery的别名： window.jQuery; // jQuery(selector, context) window.$; // jQuery(selector, context) $ === jQuery; // true typeof($); // 'function' $本质上就是一个函数，但是函数也是对象，于是$除了可以直接调用外，也可以有很多其他属性。 注意，你看到的$函数名可能不是jQuery(selector, context)，因为很多JavaScript压缩工具可以对函数名和参数改名，所以压缩过的jQuery源码$函数可能变成a(b, c)。 绝大多数时候，我们都直接用$（因为写起来更简单嘛）。但是，如果$这个变量不幸地被占用了，而且还不能改，那我们就只能让jQuery把$变量交出来，然后就只能使用jQuery这个变量： $; // jQuery(selector, context) jQuery.noConflict(); $; // undefined jQuery; // jQuery(selector, context) 这种黑魔法的原理是jQuery在占用$之前，先在内部保存了原来的$,调用jQuery.noConflict()时会把原来保存的变量还原。 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/01.Javascript/05.jQuery/5.1 选择器.html":{"url":"roccoshi_note/07-前端学习/01.Javascript/05.jQuery/5.1 选择器.html","title":"5.1 选择器","keywords":"","body":"5.1 选择器按ID查找按tag查找按class查找按属性查找组合查找多项选择器练习5.1 选择器 选择器是jQuery的核心。一个选择器写出来类似$('#dom-id')。 为什么jQuery要发明选择器？回顾一下DOM操作中我们经常使用的代码： // 按ID查找： var a = document.getElementById('dom-id'); // 按tag查找： var divs = document.getElementsByTagName('div'); // 查找： var ps = document.getElementsByTagName('p'); // 过滤出class=\"red\": // TODO: // 查找里面的所有： var table = ... for (var i=0; i } 这些代码实在太繁琐了，并且，在层级关系中，例如，查找里面的所有，一层循环实际上是错的，因为的标准写法是： ... ... 很多时候，需要递归查找所有子节点。 jQuery的选择器就是帮助我们快速定位到一个或多个DOM节点。 按ID查找 如果某个DOM节点有id属性，利用jQuery查找如下： // 查找: var div = $('#abc'); 注意，#abc以#开头。返回的对象是jQuery对象。 什么是jQuery对象？jQuery对象类似数组，它的每个元素都是一个引用了DOM节点的对象。 以上面的查找为例，如果id为abc的存在，返回的jQuery对象如下： [...] 如果id为abc的不存在，返回的jQuery对象如下： [] 总之jQuery的选择器不会返回undefined或者null，这样的好处是你不必在下一行判断if (div === undefined)。 jQuery对象和DOM对象之间可以互相转化： var div = $('#abc'); // jQuery对象 var divDom = div.get(0); // 假设存在div，获取第1个DOM元素 var another = $(divDom); // 重新把DOM包装为jQuery对象 通常情况下你不需要获取DOM对象，直接使用jQuery对象更加方便。如果你拿到了一个DOM对象，那可以简单地调用$(aDomObject)把它变成jQuery对象，这样就可以方便地使用jQuery的API了。 按tag查找 按tag查找只需要写上tag名称就可以了： var ps = $('p'); // 返回所有节点 ps.length; // 数一数页面有多少个节点 按class查找 按class查找注意在class名称前加一个.： var a = $('.red'); // 所有节点包含`class=\"red\"`都将返回 // 例如: // ... // ... 通常很多节点有多个class，我们可以查找同时包含red和green的节点： var a = $('.red.green'); // 注意没有空格！ // 符合条件的节点： // ... // ... 按属性查找 一个DOM节点除了id和class外还可以有很多属性，很多时候按属性查找会非常方便，比如在一个表单中按属性来查找： var email = $('[name=email]'); // 找出 var passwordInput = $('[type=password]'); // 找出 var a = $('[items=\"A B\"]'); // 找出 当属性的值包含空格等特殊字符时，需要用双引号括起来。 按属性查找还可以使用前缀查找或者后缀查找： var icons = $('[name^=icon]'); // 找出所有name属性值以icon开头的DOM // 例如: name=\"icon-1\", name=\"icon-2\" var names = $('[name$=with]'); // 找出所有name属性值以with结尾的DOM // 例如: name=\"startswith\", name=\"endswith\" 这个方法尤其适合通过class属性查找，且不受class包含多个名称的影响： var icons = $('[class^=\"icon-\"]'); // 找出所有class包含至少一个以`icon-`开头的DOM // 例如: class=\"icon-clock\", class=\"abc icon-home\" 组合查找 组合查找就是把上述简单选择器组合起来使用。如果我们查找$('[name=email]')，很可能把表单外的也找出来，但我们只希望查找，就可以这么写： var emailInput = $('input[name=email]'); // 不会找出 同样的，根据tag和class来组合查找也很常见： var tr = $('tr.red'); // 找出... 多项选择器 多项选择器就是把多个选择器用,组合起来一块选： $('p,div'); // 把和都选出来 $('p.red,p.green'); // 把和都选出来 要注意的是，选出来的元素是按照它们在HTML中出现的顺序排列的，而且不会有重复元素。例如，不会被上面的$('p.red,p.green')选择两次。 练习 JavaScript Haskell Erlang Python 注册新用户 名字: 邮件: 口令: 注册 //selected = $('#para-1'); //仅选择JavaScript //selected = $('.color-red.color-green'); //仅选择Erlang //selected = $('#para-1,.color-red.color-green') //选择JavaScript和Erlang //selected = $('[class^=\"color-\"]'); //选择所有编程语言 //selected = $('input[name=name]'); //选择名字input selected = $('input[name=name],input[name=email]'); //选择邮件和名字input Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/01.Javascript/05.jQuery/5.2 层级选择器.html":{"url":"roccoshi_note/07-前端学习/01.Javascript/05.jQuery/5.2 层级选择器.html","title":"5.2 层级选择器","keywords":"","body":"5.2 层级选择器层级选择器（Descendant Selector）子选择器（Child Selector）过滤器（Filter）表单相关练习5.2 层级选择器 层级选择器（Descendant Selector） 如果两个DOM元素具有层级关系，就可以用$('ancestor descendant')来选择，层级之间用空格隔开。例如： JavaScript Python Lua 要选出JavaScript，可以用层级选择器： $('ul.lang li.lang-javascript'); // [JavaScript] $('div.testing li.lang-javascript'); // [JavaScript] 因为和都是的祖先节点，所以上面两种方式都可以选出相应的节点。 要选择所有的节点，用： $('ul.lang li'); 这种层级选择器相比单个的选择器好处在于，它缩小了选择范围，因为首先要定位父节点，才能选择相应的子节点，这样避免了页面其他不相关的元素。 例如： $('form[name=upload] input'); 就把选择范围限定在name属性为upload的表单里。如果页面有很多表单，其他表单的不会被选择。 多层选择也是允许的： $('form.test p input'); // 在form表单选择被包含的 子选择器（Child Selector） 子选择器$('parent>child')类似层级选择器，但是限定了层级关系必须是父子关系，就是节点必须是节点的直属子节点。还是以上面的例子： $('ul.lang>li.lang-javascript'); // 可以选出[JavaScript] $('div.testing>li.lang-javascript'); // [], 无法选出，因为和不构成父子关系 过滤器（Filter） 过滤器一般不单独使用，它通常附加在选择器上，帮助我们更精确地定位元素。观察过滤器的效果： $('ul.lang li'); // 选出JavaScript、Python和Lua 3个节点 $('ul.lang li:first-child'); // 仅选出JavaScript $('ul.lang li:last-child'); // 仅选出Lua $('ul.lang li:nth-child(2)'); // 选出第N个元素，N从1开始 $('ul.lang li:nth-child(even)'); // 选出序号为偶数的元素 $('ul.lang li:nth-child(odd)'); // 选出序号为奇数的元素 表单相关 针对表单元素，jQuery还有一组特殊的选择器： :input：可以选择，，和； :file：可以选择，和input[type=file]一样； :checkbox：可以选择复选框，和input[type=checkbox]一样； :radio：可以选择单选框，和input[type=radio]一样； :focus：可以选择当前输入焦点的元素，例如把光标放到一个上，用$('input:focus')就可以选出； :checked：选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如$('input[type=radio]:checked')； :enabled：可以选择可以正常输入的、 等，也就是没有灰掉的输入； :disabled：和:enabled正好相反，选择那些不能输入的。 此外，jQuery还有很多有用的选择器，例如，选出可见的或隐藏的元素： $('div:visible'); // 所有可见的div $('div:hidden'); // 所有隐藏的div 练习 JavaScript Python Lua Swift Java C // 分别选择所有语言，所有动态语言，所有静态语言，JavaScript，Lua，C等: selected = $('ul.test-lang>li') selected = $('ol.test-lang>li') selected = $('ul.test-lang>li:nth-child(odd), ol.test-lang>li:last-child') Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/01.Javascript/05.jQuery/5.3 查找与过滤.html":{"url":"roccoshi_note/07-前端学习/01.Javascript/05.jQuery/5.3 查找与过滤.html","title":"5.3 查找与过滤","keywords":"","body":"5.3 查找与过滤过滤5.3 查找与过滤 常情况下选择器可以直接定位到我们想要的元素，但是，当我们拿到一个jQuery对象后，还可以以这个对象为基准，进行查找和过滤。 最常见的查找是在某个节点的所有子节点中查找，使用find()方法，它本身又接收一个任意的选择器。例如如下的HTML结构： JavaScript Python Swift Scheme Haskell JavaScript Python Swift Scheme Haskell 用find()查找： var ul = $('ul.lang'); // 获得 var dy = ul.find('.dy'); // 获得JavaScript, Python, Scheme var swf = ul.find('#swift'); // 获得Swift var hsk = ul.find('[name=haskell]'); // 获得Haskell 如果要从当前节点开始向上查找，使用parent()方法： var swf = $('#swift'); // 获得Swift var parent = swf.parent(); // 获得Swift的上层节点 var a = swf.parent('.red'); // 获得Swift的上层节点，同时传入过滤条件。如果ul不符合条件，返回空jQuery对象 对于位于同一层级的节点，可以通过next()和prev()方法，例如： 当我们已经拿到Swift节点后： var swift = $('#swift'); swift.next(); // Scheme swift.next('[name=haskell]'); // 空的jQuery对象，因为Swift的下一个元素Scheme不符合条件[name=haskell] swift.prev(); // Python swift.prev('.dy'); // Python，因为Python同时符合过滤器条件.dy 过滤 和函数式编程的map、filter类似，jQuery对象也有类似的方法。 filter()方法可以过滤掉不符合选择器条件的节点： var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell var a = langs.filter('.dy'); // 拿到JavaScript, Python, Scheme 或者传入一个函数，要特别注意函数内部的this被绑定为DOM对象，不是jQuery对象： var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell langs.filter(function () { return this.innerHTML.indexOf('S') === 0; // 返回S开头的节点 }); // 拿到Swift, Scheme map()方法把一个jQuery对象包含的若干DOM节点转化为其他对象： var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell var arr = langs.map(function () { return this.innerHTML; }).get(); // 用get()拿到包含string的Array：['JavaScript', 'Python', 'Swift', 'Scheme', 'Haskell'] 此外，一个jQuery对象如果包含了不止一个DOM节点，first()、last()和slice()方法可以返回一个新的jQuery对象，把不需要的DOM节点去掉： var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell var js = langs.first(); // JavaScript，相当于$('ul.lang li:first-child') var haskell = langs.last(); // Haskell, 相当于$('ul.lang li:last-child') var sub = langs.slice(2, 4); // Swift, Scheme, 参数和数组的slice()方法一致 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/01.Javascript/05.jQuery/5.4 操作DOM.html":{"url":"roccoshi_note/07-前端学习/01.Javascript/05.jQuery/5.4 操作DOM.html","title":"5.4 操作DOM","keywords":"","body":"5.4 操作DOM修改Text和HTML修改CSS显示和隐藏DOM获取DOM信息操作表单5.4 操作DOM 修改Text和HTML jQuery对象的text()和html()方法分别获取节点的文本和原始HTML文本，例如，如下的HTML结构： JavaScript Java &amp; JavaScript 分别获取文本和HTML： $('#test-ul li[name=book]').text(); // 'Java & JavaScript' $('#test-ul li[name=book]').html(); // 'Java &amp; JavaScript' 如何设置文本或HTML？jQuery的API设计非常巧妙：无参数调用text()是获取文本，传入参数就变成设置文本 一个jQuery对象可以包含0个或任意个DOM对象，它的方法实际上会作用在对应的每个DOM节点上。在上面的例子中试试： $('#test-ul li').text('JS'); // 是不是两个节点都变成了JS？ 所以jQuery对象的另一个好处是我们可以执行一个操作，作用在对应的一组DOM节点上。即使选择器没有返回任何DOM节点，调用jQuery对象的方法仍然不会报错： // 如果不存在id为not-exist的节点： $('#not-exist').text('Hello'); // 代码不报错，没有节点被设置为'Hello' 这意味着jQuery帮你免去了许多if语句。 修改CSS jQuery对象有“批量操作”的特点，这用于修改CSS实在是太方便了。考虑下面的HTML结构： JavaScript Java Python Swift Scheme 要高亮显示动态语言，调用jQuery对象的css('name', 'value')方法，我们用一行语句实现： $('#test-css li.dy>span').css('background-color', '#ffd351').css('color', 'red'); 注意，jQuery对象的所有方法都返回一个jQuery对象（可能是新的也可能是自身），这样我们可以进行链式调用，非常方便。 jQuery对象的css()方法可以这么用： var div = $('#test-div'); div.css('color'); // '#000033', 获取CSS属性 div.css('color', '#336699'); // 设置CSS属性 div.css('color', ''); // 清除CSS属性 为了和JavaScript保持一致，CSS属性可以用'background-color'和'backgroundColor'两种格式。 css()方法将作用于DOM节点的style属性，具有最高优先级。如果要修改class属性，可以用jQuery提供的下列方法： var div = $('#test-div'); div.hasClass('highlight'); // false， class是否包含highlight div.addClass('highlight'); // 添加highlight这个class div.removeClass('highlight'); // 删除highlight这个class 显示和隐藏DOM 要隐藏一个DOM，我们可以设置CSS的display属性为none，利用css()方法就可以实现。不过，要显示这个DOM就需要恢复原有的display属性，这就得先记下来原有的display属性到底是block还是inline还是别的值。 考虑到显示和隐藏DOM元素使用非常普遍，jQuery直接提供show()和hide()方法，我们不用关心它是如何修改display属性的，总之它能正常工作： var a = $('a[target=_blank]'); a.hide(); // 隐藏 a.show(); // 显示 注意，隐藏DOM节点并未改变DOM树的结构，它只影响DOM节点的显示。这和删除DOM节点是不同的。 获取DOM信息 利用jQuery对象的若干方法，我们直接可以获取DOM的高宽等信息，而无需针对不同浏览器编写特定代码： // 浏览器可视窗口大小: $(window).width(); // 800 $(window).height(); // 600 // HTML文档大小: $(document).width(); // 800 $(document).height(); // 3500 // 某个div的大小: var div = $('#test-div'); div.width(); // 600 div.height(); // 300 div.width(400); // 设置CSS属性 width: 400px，是否生效要看CSS是否有效 div.height('200px'); // 设置CSS属性 height: 200px，是否生效要看CSS是否有效 attr()和removeAttr()方法用于操作DOM节点的属性： // ... var div = $('#test-div'); div.attr('data'); // undefined, 属性不存在 div.attr('name'); // 'Test' div.attr('name', 'Hello'); // div的name属性变为'Hello' div.removeAttr('name'); // 删除name属性 div.attr('name'); // undefined prop()方法和attr()类似，但是HTML5规定有一种属性在DOM节点中可以没有值，只有出现与不出现两种，例如： 等价于： attr()和prop()对于属性checked处理有所不同： var radio = $('#test-radio'); radio.attr('checked'); // 'checked' radio.prop('checked'); // true prop()返回值更合理一些。不过，用is()方法判断更好： var radio = $('#test-radio'); radio.is(':checked'); // true 类似的属性还有selected，处理时最好用is(':selected')。 操作表单 对于表单元素，jQuery对象统一提供val()方法获取和设置对应的value属性： /* Beijing Shanghai Shenzhen Hello */ var input = $('#test-input'), select = $('#test-select'), textarea = $('#test-textarea'); input.val(); // 'test' input.val('abc@example.com'); // 文本框的内容已变为abc@example.com select.val(); // 'BJ' select.val('SH'); // 选择框已变为Shanghai textarea.val(); // 'Hello' textarea.val('Hi'); // 文本区域已更新为'Hi' 可见，一个val()就统一了各种输入框的取值和赋值的问题。 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/01.Javascript/05.jQuery/5.5 修改DOM结构.html":{"url":"roccoshi_note/07-前端学习/01.Javascript/05.jQuery/5.5 修改DOM结构.html","title":"5.5 修改DOM结构","keywords":"","body":"5.5 修改DOM结构添加DOM删除节点5.5 修改DOM结构 添加DOM 要添加新的DOM节点，除了通过jQuery的html()这种暴力方法外，还可以用append()方法，例如： JavaScript Python Swift 如何向列表新增一个语言？首先要拿到节点： var ul = $('#test-div>ul'); 然后，调用append()传入HTML片段： ul.append('Haskell'); 除了接受字符串，append()还可以传入原始的DOM对象，jQuery对象和函数对象： // 创建DOM对象: var ps = document.createElement('li'); ps.innerHTML = 'Pascal'; // 添加DOM对象: ul.append(ps); // 添加jQuery对象: ul.append($('#scheme')); // 添加函数对象: ul.append(function (index, html) { return 'Language - ' + index + ''; }); 传入函数时，要求返回一个字符串、DOM对象或者jQuery对象。因为jQuery的append()可能作用于一组DOM节点，只有传入函数才能针对每个DOM生成不同的子节点。 append()把DOM添加到最后，prepend()则把DOM添加到最前。 另外注意，如果要添加的DOM节点已经存在于HTML文档中，它会首先从文档移除，然后再添加，也就是说，用append()，你可以移动一个DOM节点。 如果要把新节点插入到指定位置，例如，JavaScript和Python之间，那么，可以先定位到JavaScript，然后用after()方法： var js = $('#test-div>ul>li:first-child'); js.after('Lua'); 也就是说，同级节点可以用after()或者before()方法。 删除节点 要删除DOM节点，拿到jQuery对象后直接调用remove()方法就可以了。如果jQuery对象包含若干DOM节点，实际上可以一次删除多个DOM节点： var li = $('#test-div>ul>li'); li.remove(); // 所有全被删除 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/01.Javascript/05.jQuery/5.6 事件.html":{"url":"roccoshi_note/07-前端学习/01.Javascript/05.jQuery/5.6 事件.html","title":"5.6 事件","keywords":"","body":"5.6 事件鼠标事件键盘事件其他事件事件参数取消绑定事件触发条件浏览器安全限制5.6 事件 因为JavaScript在浏览器中以单线程模式运行，页面加载后，一旦页面上所有的JavaScript代码被执行完后，就只能依赖触发事件来执行JavaScript代码。 浏览器在接收到用户的鼠标或键盘输入后，会自动在对应的DOM节点上触发相应的事件。如果该节点已经绑定了对应的JavaScript处理函数，该函数就会自动调用。 由于不同的浏览器绑定事件的代码都不太一样，所以用jQuery来写代码，就屏蔽了不同浏览器的差异，我们总是编写相同的代码。 举个例子，假设要在用户点击了超链接时弹出提示框，我们用jQuery这样绑定一个click事件： /* HTML: * * 点我试试 * */ // 获取超链接的jQuery对象: var a = $('#test-link'); a.on('click', function () { alert('Hello!'); }); on方法用来绑定一个事件，我们需要传入事件名称和对应的处理函数。 另一种更简化的写法是直接调用click()方法： a.click(function () { alert('Hello!'); }); 两者完全等价。我们通常用后面的写法。 jQuery能够绑定的事件主要包括： 鼠标事件 click: 鼠标单击时触发； dblclick：鼠标双击时触发； mouseenter：鼠标进入时触发； mouseleave：鼠标移出时触发； mousemove：鼠标在DOM内部移动时触发； hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。 键盘事件 键盘事件仅作用在当前焦点的DOM上，通常是和。 keydown：键盘按下时触发； keyup：键盘松开时触发； keypress：按一次键后触发。 其他事件 focus：当DOM获得焦点时触发； blur：当DOM失去焦点时触发； change：当、或的内容改变时触发； submit：当提交时触发； ready：当页面被载入并且DOM树完成初始化后触发。 其中，ready仅作用于document对象。由于ready事件在DOM完成初始化后触发，且只触发一次，所以非常适合用来写其他的初始化代码。假设我们想给一个表单绑定submit事件，下面的代码没有预期的效果： // 代码有误: $('#testForm).on('submit', function () { alert('submit!'); }); ... 因为JavaScript在此执行的时候，尚未载入浏览器，所以$('#testForm)返回[]，并没有绑定事件到任何DOM上。 所以我们自己的初始化代码必须放到document对象的ready事件中，保证DOM已完成初始化： $(document).on('ready', function () { $('#testForm).on('submit', function () { alert('submit!'); }); }); ... 这样写就没有问题了。因为相关代码会在DOM树初始化后再执行。 由于ready事件使用非常普遍，所以可以这样简化： $(document).ready(function () { // on('submit', function)也可以简化: $('#testForm).submit(function () { alert('submit!'); }); }); 甚至还可以再简化为： $(function () { // init... }); 上面的这种写法最为常见。如果你遇到$(function () {...})的形式，牢记这是document对象的ready事件处理函数。 完全可以反复绑定事件处理函数，它们会依次执行： $(function () { console.log('init A...'); }); $(function () { console.log('init B...'); }); $(function () { console.log('init C...'); }); 事件参数 有些事件，如mousemove和keypress，我们需要获取鼠标位置和按键的值，否则监听这些事件就没什么意义了。所有事件都会传入Event对象作为参数，可以从Event对象上获取到更多的信息： $(function () { $('#testMouseMoveDiv').mousemove(function (e) { $('#testMouseMoveSpan').text('pageX = ' + e.pageX + ', pageY = ' + e.pageY); }); }); 取消绑定 一个已被绑定的事件可以解除绑定，通过off('click', function)实现： function hello() { alert('hello!'); } a.click(hello); // 绑定事件 // 10秒钟后解除绑定: setTimeout(function () { a.off('click', hello); }, 10000); 需要特别注意的是，下面这种写法是无效的： // 绑定事件: a.click(function () { alert('hello!'); }); // 解除绑定: a.off('click', function () { alert('hello!'); }); 这是因为两个匿名函数虽然长得一模一样，但是它们是两个不同的函数对象，off('click', function () {...})无法移除已绑定的第一个匿名函数。 为了实现移除效果，可以使用off('click')一次性移除已绑定的click事件的所有处理函数。 同理，无参数调用off()一次性移除已绑定的所有类型的事件处理函数。 事件触发条件 一个需要注意的问题是，事件的触发总是由用户操作引发的。例如，我们监控文本框的内容改动： var input = $('#test-input'); input.change(function () { console.log('changed...'); }); 当用户在文本框中输入时，就会触发change事件。但是，如果用JavaScript代码去改动文本框的值，将不会触发change事件： var input = $('#test-input'); input.val('change it!'); // 无法触发change事件 有些时候，我们希望用代码触发change事件，可以直接调用无参数的change()方法来触发该事件： var input = $('#test-input'); input.val('change it!'); input.change(); // 触发change事件 input.change()相当于input.trigger('change')，它是trigger()方法的简写。 为什么我们希望手动触发一个事件呢？如果不这么做，很多时候，我们就得写两份一模一样的代码。 浏览器安全限制 在浏览器中，有些JavaScript代码只有在用户触发下才能执行，例如，window.open()函数： // 无法弹出新窗口，将被浏览器屏蔽: $(function () { window.open('/'); }); 这些“敏感代码”只能由用户操作来触发： var button1 = $('#testPopupButton1'); var button2 = $('#testPopupButton2'); function popupTestWindow() { window.open('/'); } button1.click(function () { popupTestWindow(); }); button2.click(function () { // 不立刻执行popupTestWindow()，3秒后执行: setTimeout(popupTestWindow, 3000); }); 当用户点击button1时，click事件被触发，由于popupTestWindow()在click事件处理函数内执行，这是浏览器允许的，而button2的click事件并未立刻执行popupTestWindow()，延迟执行的popupTestWindow()将被浏览器拦截。 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/01.Javascript/05.jQuery/5.7 动画.html":{"url":"roccoshi_note/07-前端学习/01.Javascript/05.jQuery/5.7 动画.html","title":"5.7 动画","keywords":"","body":"5.7 动画show / hideslideUp / slideDownfadeIn / fadeOut自定义动画show / hideslideUp / slideDownfadeIn / fadeOut自定义动画串行动画为什么有的动画没有效果5.7 动画 用JavaScript实现动画，原理非常简单：我们只需要以固定的时间间隔（例如，0.1秒），每次把DOM元素的CSS样式修改一点（例如，高宽各增加10%），看起来就像动画了。 但是要用JavaScript手动实现动画效果，需要编写非常复杂的代码。如果想要把动画效果用函数封装起来便于复用，那考虑的事情就更多了。 使用jQuery实现动画，代码已经简单得不能再简化了：只需要一行代码！ 让我们先来看看jQuery内置的几种动画样式： show / hide 直接以无参数形式调用show()和hide()，会显示和隐藏DOM元素。但是，只要传递一个时间参数进去，就变成了动画： var div = $('#test-show-hide'); div.hide(3000); // 在3秒钟内逐渐消失 时间以毫秒为单位，但也可以是'slow'，'fast'这些字符串： var div = $('#test-show-hide'); div.show('slow'); // 在0.6秒钟内逐渐显示 toggle()方法则根据当前状态决定是show()还是hide()。 slideUp / slideDown 你可能已经看出来了，show()和hide()是从左上角逐渐展开或收缩的，而slideUp()和slideDown()则是在垂直方向逐渐展开或收缩的。 slideUp()把一个可见的DOM元素收起来，效果跟拉上窗帘似的，slideDown()相反，而slideToggle()则根据元素是否可见来决定下一步动作： var div = $('#test-slide'); div.slideUp(3000); // 在3秒钟内逐渐向上消失 fadeIn / fadeOut fadeIn()和fadeOut()的动画效果是淡入淡出，也就是通过不断设置DOM元素的opacity属性来实现，而fadeToggle()则根据元素是否可见来决定下一步动作： var div = $('#test-fade'); div.fadeOut('slow'); // 在0.6秒内淡出 自定义动画 如果上述动画效果还不能满足你的要求，那就祭出最后大招：animate()，它可以实现任意动画效果，我们需要传入的参数就是DOM元素最终的CSS状态和时间，jQuery在时间段内不断调整CSS直到达到我们设定的值： var div = $('#test-animate'); div.animate({ opacity: 0.25, width: '256px', height: '256px' }, 3000); // 在3秒钟内CSS过渡到设定值 animate()还可以再传入一个函数，当动画结束时，该函数将被调用： var div = $('#test-animate'); div.animate({ opacity: 0.25, width: '256px', height: '256px' }, 3000, function () { console.log('动画已结束'); // 恢复至初始状态: $(this).css('opacity', '1.0').css('width', '128px').css('height', '128px'); }); 实际上这个回调函数参数对于基本动画也是适用的。 有了animate()，你就可以实现各种自定义动画效果了： 动画 Reads: 805578 用JavaScript实现动画，原理非常简单：我们只需要以固定的时间间隔（例如，0.1秒），每次把DOM元素的CSS样式修改一点（例如，高宽各增加10%），看起来就像动画了。 但是要用JavaScript手动实现动画效果，需要编写非常复杂的代码。如果想要把动画效果用函数封装起来便于复用，那考虑的事情就更多了。 使用jQuery实现动画，代码已经简单得不能再简化了：只需要一行代码！ 让我们先来看看jQuery内置的几种动画样式： show / hide 直接以无参数形式调用show()和hide()，会显示和隐藏DOM元素。但是，只要传递一个时间参数进去，就变成了动画： var div = $('#test-show-hide'); div.hide(3000); // 在3秒钟内逐渐消失 时间以毫秒为单位，但也可以是'slow'，'fast'这些字符串： var div = $('#test-show-hide'); div.show('slow'); // 在0.6秒钟内逐渐显示 toggle()方法则根据当前状态决定是show()还是hide()。 效果实测： hide('slow') show('slow') toggle('slow') slideUp / slideDown 你可能已经看出来了，show()和hide()是从左上角逐渐展开或收缩的，而slideUp()和slideDown()则是在垂直方向逐渐展开或收缩的。 slideUp()把一个可见的DOM元素收起来，效果跟拉上窗帘似的，slideDown()相反，而slideToggle()则根据元素是否可见来决定下一步动作： var div = $('#test-slide'); div.slideUp(3000); // 在3秒钟内逐渐向上消失 效果实测： slideUp('slow') slideDown('slow') slideToggle('slow') fadeIn / fadeOut fadeIn()和fadeOut()的动画效果是淡入淡出，也就是通过不断设置DOM元素的opacity属性来实现，而fadeToggle()则根据元素是否可见来决定下一步动作： var div = $('#test-fade'); div.fadeOut('slow'); // 在0.6秒内淡出 fadeOut('slow') fadeIn('slow') fadeToggle('slow') 自定义动画 如果上述动画效果还不能满足你的要求，那就祭出最后大招：animate()，它可以实现任意动画效果，我们需要传入的参数就是DOM元素最终的CSS状态和时间，jQuery在时间段内不断调整CSS直到达到我们设定的值： var div = $('#test-animate'); div.animate({ opacity: 0.25, width: '256px', height: '256px' }, 3000); // 在3秒钟内CSS过渡到设定值 animate()还可以再传入一个函数，当动画结束时，该函数将被调用： var div = $('#test-animate'); div.animate({ opacity: 0.25, width: '256px', height: '256px' }, 3000, function () { console.log('动画已结束'); // 恢复至初始状态: $(this).css('opacity', '1.0').css('width', '128px').css('height', '128px'); }); 实际上这个回调函数参数对于基本动画也是适用的。 有了animate()，你就可以实现各种自定义动画效果了： animate() 串行动画 jQuery的动画效果还可以串行执行，通过delay()方法还可以实现暂停，这样，我们可以实现更复杂的动画效果，而代码却相当简单： var div = $('#test-animates'); // 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小 div.slideDown(2000) .delay(1000) .animate({ width: '256px', height: '256px' }, 2000) .delay(1000) .animate({ width: '128px', height: '128px' }, 2000); } 因为动画需要执行一段时间，所以jQuery必须不断返回新的Promise对象才能后续执行操作。简单地把动画封装在函数中是不够的。 为什么有的动画没有效果 你可能会遇到，有的动画如slideUp()根本没有效果。这是因为jQuery动画的原理是逐渐改变CSS的值，如height从100px逐渐变为0。但是很多不是block性质的DOM元素，对它们设置height根本就不起作用，所以动画也就没有效果。 此外，jQuery也没有实现对background-color的动画效果，用animate()设置background-color也没有效果。这种情况下可以使用CSS3的transition实现动画效果。 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/01.Javascript/05.jQuery/5.8 AJAX.html":{"url":"roccoshi_note/07-前端学习/01.Javascript/05.jQuery/5.8 AJAX.html","title":"5.8 AJAX","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/01.Javascript/05.jQuery/5.9 扩展.html":{"url":"roccoshi_note/07-前端学习/01.Javascript/05.jQuery/5.9 扩展.html","title":"5.9 扩展","keywords":"","body":"5.9 扩展编写jQuery插件$.fn编写一个jQuery插件的原则：针对特定元素的扩展5.9 扩展 当我们使用jQuery对象的方法时，由于jQuery对象可以操作一组DOM，而且支持链式操作，所以用起来非常方便。 但是jQuery内置的方法永远不可能满足所有的需求。比如，我们想要高亮显示某些DOM元素，用jQuery可以这么实现： $('span.hl').css('backgroundColor', '#fffceb').css('color', '#d85030'); $('p a.hl').css('backgroundColor', '#fffceb').css('color', '#d85030'); 总是写重复代码可不好，万一以后还要修改字体就更麻烦了，能不能统一起来，写个highlight()方法？ $('span.hl').highlight(); $('p a.hl').highlight(); 答案是肯定的。我们可以扩展jQuery来实现自定义方法。将来如果要修改高亮的逻辑，只需修改一处扩展代码。这种方式也称为编写jQuery插件。 编写jQuery插件$.fn 给jQuery对象绑定一个新方法是通过扩展$.fn对象实现的。让我们来编写第一个扩展——highlight1()： $.fn.highlight1 = function () { // this已绑定为当前jQuery对象: this.css('backgroundColor', '#fffceb').css('color', '#d85030'); return this; } 注意到函数内部的this在调用时被绑定为jQuery对象，所以函数内部代码可以正常调用所有jQuery对象的方法。 细心的童鞋可能发现了，为什么最后要return this;？因为jQuery对象支持链式操作，我们自己写的扩展方法也要能继续链式下去： $('span.hl').highlight1().slideDown(); 不然，用户调用的时候，就不得不把上面的代码拆成两行。 但是这个版本并不完美。有的用户希望高亮的颜色能自己来指定，怎么办？ 我们可以给方法加个参数，让用户自己把参数用对象传进去。于是我们有了第二个版本的highlight2()： $.fn.highlight2 = function (options) { // 要考虑到各种情况: // options为undefined // options只有部分key var bgcolor = options && options.backgroundColor || '#fffceb'; var color = options && options.color || '#d85030'; this.css('backgroundColor', bgcolor).css('color', color); return this; } 编写一个jQuery插件的原则： 给$.fn绑定函数，实现插件的代码逻辑； 插件函数最后要return this;以支持链式调用； 插件函数要有默认值，绑定在$.fn..defaults上； 用户在调用时可传入设定值以便覆盖默认值。 针对特定元素的扩展 我们知道jQuery对象的有些方法只能作用在特定DOM元素上，比如submit()方法只能针对form。如果我们编写的扩展只能针对某些类型的DOM元素，应该怎么写？ 还记得jQuery的选择器支持filter()方法来过滤吗？我们可以借助这个方法来实现针对特定元素的扩展。 举个例子，现在我们要给所有指向外链的超链接加上跳转提示，怎么做？ 先写出用户调用的代码： $('#main a').external(); 然后按照上面的方法编写一个external扩展： $.fn.external = function () { // return返回的each()返回结果，支持链式调用: return this.filter('a').each(function () { // 注意: each()内部的回调函数的this绑定为DOM本身! var a = $(this); var url = a.attr('href'); if (url && (url.indexOf('http://')===0 || url.indexOf('https://')===0)) { a.attr('href', '#0') .removeAttr('target') .append(' ') .click(function () { if(confirm('你确定要前往' + url + '？')) { window.open(url); } }); } }); } 对如下的HTML结构： 如何学习jQuery？ 首先，你要学习JavaScript，并了解基本的HTML。 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/01.Javascript/01.基本语法.html":{"url":"roccoshi_note/07-前端学习/01.Javascript/01.基本语法.html","title":"01.基本语法","keywords":"","body":"01.基本语法一、几种基本的数据类型Number布尔值比较运算符null和undefined数组对象变量strict模式二、字符串多行字符串模板字符串操作字符串字符串的操作方法三、数组length和赋值几个方法四、对象五、if条件判断多行条件判断六、循环七、Map和SetMapSet八、iterablefor...of方法forEach方法01.基本语法 一、几种基本的数据类型 Number Javascript不分整数类型和浮点数类型，统一用Number类型表示，下面都是合法的Number类型： 123; // 整数123 0.456; // 浮点数0.456 1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5 -99; // 负数 NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示 Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity ### 字符串 字符串是以双引号“”或者单引号‘’括起来的任意文本 布尔值 false和true 比较运算符 要特别注意相等运算符==。JavaScript在设计时，有两种比较运算符： 第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。 另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己： NaN === NaN; // false 唯一能判断NaN的方法是通过isNaN()函数： isNaN(NaN); // true 最后要注意浮点数的相等比较： 1 / 3 === (1 - 2 / 3); // false 这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值： Math.abs(1 / 3 - (1 - 2 / 3)) null和undefined null表示一个“空”的值，它和0以及空字符串''不同，0是一个数值，''表示长度为0的字符串，而null表示“空”。 在其他语言中，也有类似JavaScript的null的表示，例如Java也用null，Swift用nil，Python用None表示。但是，在JavaScript中，还有一个和null类似的undefined，它表示“未定义”。 JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。 数组 数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如： [1, 2, 3.14, 'Hello', null, true]; // 数组的初始化 var arr = [1, 2, 3.14, 'Hello', null, true]; 对象 JavaScript的对象是一组由键-值组成的无序集合，例如： var person = { name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, zipcode: null }; JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述person对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，person的name属性为'Bob'，zipcode属性为null。 要获取一个对象的属性，我们用对象变量.属性名的方式： person.name; // 'Bob' person.zipcode; // null 变量 变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。申明一个变量用var语句，比如： var a; // 申明了变量a，此时a的值为undefined var $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1 var s_007 = '007'; // s_007是一个字符串 var Answer = true; // Answer是一个布尔值true var t = null; // t的值是null strict模式 JavaScript在设计之初，为了方便初学者学习，并不强制要求用var申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量： i = 10; // i现在是全局变量 在同一个页面的不同的JavaScript文件中，如果都不用var申明，恰好都使用了变量i，将造成变量i互相影响，产生难以调试的错误结果。 使用var申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。 为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误。 启用strict模式的方法是在JavaScript代码的第一行写上： 'use strict'; 这是一个字符串，不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。 二、字符串 多行字符串 由于多行字符串用\\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 `\\ ... *`* 表示： `这是一个 多行 字符串`; 模板字符串 要把多个字符串连接起来，可以用+号连接： var name = '小明'; var age = 20; var message = '你好, ' + name + ', 你今年' + age + '岁了!'; alert(message); 如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量： var name = '小明'; var age = 20; var message = `你好, ${name}, 你今年${age}岁了!`; alert(message); 操作字符串 字符串常见的操作如下： var s = 'Hello, world!'; s.length; // 13 要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始： var s = 'Hello, world!'; s[0]; // 'H' s[6]; // ' ' s[7]; // 'w' s[12]; // '!' s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined 需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果： var s = 'Test'; s[0] = 'X'; alert(s); // s仍然为'Test' 字符串的操作方法 1 -- toUpperCase() 把一个字符串全部变为大写 2 -- toLowerCase() 把一个字符串全部变为小写 3 -- indexOf() 会搜索指定字符串出现的位置 var s = 'hello, world'; s.indexOf('world'); // 返回7 s.indexOf('World'); // 没有找到指定的子串，返回-1 4 -- substring() 返回指定索引区间的子串：( 左闭右开区间 ) var s = 'hello, world' s.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello' s.substring(7); // 从索引7开始到结束，返回'world' 三、数组 length和赋值 JavaScript的Array可以包含任意数据类型，并通过索引来访问每个元素。 要取得Array的长度，直接访问length属性： var arr = [1, 2, 3.14, 'Hello', null, true]; arr.length; // 6 请注意，直接给Array的length赋一个新的值会导致Array大小的变化： var arr = [1, 2, 3]; arr.length; // 3 arr.length = 6; arr; // arr变为[1, 2, 3, undefined, undefined, undefined] arr.length = 2; arr; // arr变为[1, 2] Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array： var arr = ['A', 'B', 'C']; arr[1] = 99; arr; // arr现在变为['A', 99, 'C'] 请注意，如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化： var arr = [1, 2, 3]; arr[5] = 'x'; arr; // arr变为[1, 2, 3, undefined, undefined, 'x'] 大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。 几个方法 1 -- indexOf 与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置： var arr = [10, 20, '30', 'xyz']; arr.indexOf(10); // 元素10的索引为0 arr.indexOf(20); // 元素20的索引为1 arr.indexOf(30); // 元素30没有找到，返回-1 arr.indexOf('30'); // 元素'30'的索引为2 注意了，数字30和字符串'30'是不同的元素。 2 -- slice slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array： var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G']; arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C'] arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G'] 注意到slice()的起止参数包括开始索引，不包括结束索引。 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array： var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G']; var aCopy = arr.slice(); aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G'] aCopy === arr; // false 3 -- push和pop push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉： var arr = [1, 2]; arr.push('A', 'B'); // 返回Array新的长度: 4 arr; // [1, 2, 'A', 'B'] arr.pop(); // pop()返回'B' arr; // [1, 2, 'A'] arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次 arr; // [] arr.pop(); // 空数组继续pop不会报错，而是返回undefined arr; // [] 4 -- shift和unshift 如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉： var arr = [1, 2]; arr.unshift('A', 'B'); // 返回Array新的长度: 4 arr; // ['A', 'B', 1, 2] arr.shift(); // 'A' arr; // ['B', 1, 2] arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次 arr; // [] arr.shift(); // 空数组继续shift不会报错，而是返回undefined arr; // [] 5 -- sort sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序： var arr = ['B', 'C', 'A']; arr.sort(); arr; // ['A', 'B', 'C'] 6 -- reverse reverse()把整个Array的元素给掉个个，也就是反转： var arr = ['one', 'two', 'three']; arr.reverse(); arr; // ['three', 'two', 'one'] 7 -- splice splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素： var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle']; // 从索引2开始删除3个元素,然后再添加两个元素: arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite'] arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] // 只删除,不添加: arr.splice(2, 2); // ['Google', 'Facebook'] arr; // ['Microsoft', 'Apple', 'Oracle'] // 只添加,不删除: arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素 arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] 8 -- concat concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array： var arr = ['A', 'B', 'C']; var added = arr.concat([1, 2, 3]); added; // ['A', 'B', 'C', 1, 2, 3] arr; // ['A', 'B', 'C'] 请注意，concat()方法并没有修改当前Array，而是返回了一个新的Array。 实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里： var arr = ['A', 'B', 'C']; arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4] 9 -- join join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： var arr = ['A', 'B', 'C', 1, 2, 3]; arr.join('-'); // 'A-B-C-1-2-3' 如果Array的元素不是字符串，将自动转换为字符串后再连接。 四、对象 JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成。 JavaScript的对象用于描述现实世界中的某个对象。例如，为了描述“小明”这个淘气的小朋友，我们可以用若干键值对来描述他： var xiaoming = { name: '小明', birth: 1990, school: 'No.1 Middle School', height: 1.70, weight: 65, score: null }; JavaScript用一个{...}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,，如果加了，有的浏览器（如低版本的IE）将报错。 上述对象申明了一个name属性，值是'小明'，birth属性，值是1990，以及其他一些属性。最后，把这个对象赋值给变量xiaoming后，就可以通过变量xiaoming来获取小明的属性了： xiaoming.name; // '小明' xiaoming.birth; // 1990 访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用''括起来： var xiaohong = { name: '小红', 'middle-school': 'No.1 Middle School' }; xiaohong的属性名middle-school不是一个有效的变量，就需要用''括起来。访问这个属性也无法使用.操作符，必须用['xxx']来访问： xiaohong['middle-school']; // 'No.1 Middle School' xiaohong['name']; // '小红' xiaohong.name; // '小红' 也可以用xiaohong['name']来访问xiaohong的name属性，不过xiaohong.name的写法更简洁。我们在编写JavaScript代码的时候，属性名尽量使用标准的变量名，这样就可以直接通过object.prop的形式访问一个属性了。 由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性： var xiaoming = { name: '小明' }; xiaoming.age; // undefined xiaoming.age = 18; // 新增一个age属性 xiaoming.age; // 18 delete xiaoming.age; // 删除age属性 xiaoming.age; // undefined delete xiaoming['name']; // 删除name属性 xiaoming.name; // undefined delete xiaoming.school; // 删除一个不存在的school属性也不会报错 如果我们要检测xiaoming是否拥有某一属性，可以用in操作符： var xiaoming = { name: '小明', birth: 1990, school: 'No.1 Middle School', height: 1.70, weight: 65, score: null }; 'name' in xiaoming; // true 'grade' in xiaoming; // false 不过要小心，如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的： 'toString' in xiaoming; // true 因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性。 要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法： var xiaoming = { name: '小明' }; xiaoming.hasOwnProperty('name'); // true xiaoming.hasOwnProperty('toString'); // false 五、if条件判断 JavaScript使用if () { ... } else { ... }来进行条件判断。例如，根据年龄显示不同内容，可以用if语句实现如下： var age = 20; if (age >= 18) { // 如果age >= 18为true，则执行if语句块 alert('adult'); } else { // 否则执行else语句块 alert('teenager'); } JavaScript把null、undefined、0、NaN和空字符串''视为false，其他值一概视为true，因此上述代码条件判断的结果是true。 多行条件判断 如果还要更细致地判断条件，可以使用多个if...else...的组合： var age = 3; if (age >= 18) { alert('adult'); } else if (age >= 6) { alert('teenager'); } else { alert('kid'); } 六、循环 for循环： var x = 0; var i; for (i=1; i for循环的一个变体是for ... in循环，它可以把一个对象的所有属性依次循环出来： var o = { name: 'Jack', age: 20, city: 'Beijing' }; for (var key in o) { console.log(key); // 'name', 'age', 'city' } while和do while循环 七、Map和Set Map Map是一组键值对的结构，具有极快的查找速度。 举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array： var names = ['Michael', 'Bob', 'Tracy']; var scores = [95, 75, 85]; 给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。 如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下： var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]); m.get('Michael'); // 95 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法: set, has和get var m = new Map(); // 空Map m.set('Adam', 67); // 添加新的key-value m.set('Bob', 59); m.has('Adam'); // 是否存在key 'Adam': true m.get('Adam'); // 67 m.delete('Adam'); // 删除key 'Adam' m.get('Adam'); // undefined 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉： var m = new Map(); m.set('Adam', 67); m.set('Adam', 88); m.get('Adam'); // 88 Set Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set： var s1 = new Set(); // 空Set var s2 = new Set([1, 2, 3]); // 含1, 2, 3 重复元素在Set中自动被过滤： var s = new Set([1, 2, 3, 3, '3']); s; // Set {1, 2, 3, \"3\"} 注意数字3和字符串'3'是不同的元素。 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果： s.add(4); s; // Set {1, 2, 3, 4} s.add(4); s; // 仍然是 Set {1, 2, 3, 4} 通过delete(key)方法可以删除元素： var s = new Set([1, 2, 3]); s; // Set {1, 2, 3} s.delete(3); s; // Set {1, 2} 八、iterable 遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 for...of方法 具有iterable类型的集合可以通过新的for ... of循环来遍历。( ES6 ) 用for ... of循环遍历集合，用法如下： var a = ['A', 'B', 'C']; var s = new Set(['A', 'B', 'C']); var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]); for (var x of a) { // 遍历Array console.log(x); } for (var x of s) { // 遍历Set console.log(x); } for (var x of m) { // 遍历Map console.log(x[0] + '=' + x[1]); } for ... of循环和for ... in循环的区别: for ... in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。 当我们手动给Array对象添加了额外的属性后，for ... in循环将带来意想不到的意外效果： var a = ['A', 'B', 'C']; a.name = 'Hello'; for (var x in a) { console.log(x); // '0', '1', '2', 'name' } for ... in循环将把name包括在内，但Array的length属性却不包括在内。 for ... of循环则完全修复了这些问题，它只循环集合本身的元素： var a = ['A', 'B', 'C']; a.name = 'Hello'; for (var x of a) { console.log(x); // 'A', 'B', 'C' } forEach方法 然而，更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例： 'use strict'; var a = ['A', 'B', 'C']; a.forEach(function (element, index, array) { // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + ', index = ' + index); //A, index = 0 //B, index = 1 //C, index = 2 }); Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身： var s = new Set(['A', 'B', 'C']); s.forEach(function (element, sameElement, set) { console.log(element); }); Map的回调函数参数依次为value、key和map本身： var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]); m.forEach(function (value, key, map) { console.log(value); }); 如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得Array的element： var a = ['A', 'B', 'C']; a.forEach(function (element) { console.log(element); }); Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/01.Javascript/02.函数.html":{"url":"roccoshi_note/07-前端学习/01.Javascript/02.函数.html","title":"02.函数","keywords":"","body":"02.函数一、函数的定义和调用匿名函数调用函数行末自动加分号机制二、变量作用域与解构赋值变量提升全局作用域名字空间局部作用域常量解构赋值三、方法apply装饰器四、高阶函数mapreducefiltersortArray中的高阶函数五、闭包函数作为返回值闭包六、箭头函数 =>this例题--数组排序七、生成器generator02.函数 一、函数的定义和调用 在JavaScript中，定义函数的方式如下： function abs(x) { if (x >= 0) { return x; } else { return -x; } } 上述abs()函数的定义如下： function指出这是一个函数定义； abs是函数的名称； (x)括号内列出函数的参数，多个参数以,分隔； { ... }之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。 匿名函数 var abs = function (x) { if (x >= 0) { return x; } else { return -x; } }; 在这种方式下，function (x) { ... }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。 上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。 调用函数 arguments关键字 arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数, 类似一个array但是不是array 实际上arguments最常用于判断传入参数的个数。你可能会看到这样的写法： // foo(a[, b], c) // 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null： function foo(a, b, c) { if (arguments.length === 2) { // 实际拿到的参数是a和b，c为undefined c = b; // 把b赋给c b = null; // b变为默认值 } // ... } 要把中间的参数b变为“可选”参数，就只能通过arguments判断，然后重新调整参数并赋值。 rest参数 由于JavaScript函数允许接收任意个参数，于是我们就不得不用arguments来获取所有参数： function foo(a, b) { var i, rest = []; if (arguments.length > 2) { for (i = 2; i 为了获取除了已定义参数a、b之外的参数，我们不得不用arguments，并且循环要从索引2开始以便排除前两个参数，这种写法很别扭，只是为了获得额外的rest参数，有没有更好的方法？ ES6标准引入了rest参数，上面的函数可以改写为： function foo(a, b, ...rest) { console.log('a = ' + a); console.log('b = ' + b); console.log(rest); } foo(1, 2, 3, 4, 5); // 结果: // a = 1 // b = 2 // Array [ 3, 4, 5 ] foo(1); // 结果: // a = 1 // b = undefined // Array [] rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。 如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。 行末自动加分号机制 前面我们讲到了JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑： function foo() { return { name: 'foo' }; } foo(); // { name: 'foo' } 如果把return语句拆成两行： function foo() { return { name: 'foo' }; } foo(); // undefined 要小心了，由于JavaScript引擎在行末自动添加分号的机制，上面的代码实际上变成了： function foo() { return; // 自动添加了分号，相当于return undefined; { name: 'foo' }; // 这行语句已经没法执行到了 } 所以正确的多行写法是： function foo() { return { // 这里不会自动加分号，因为{表示语句尚未结束 name: 'foo' }; } 二、变量作用域与解构赋值 在JavaScript中，用var申明的变量实际上是有作用域的。 如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量： 'use strict'; function foo() { var x = 1; x = x + 1; } x = x + 2; // ReferenceError! 无法在函数体外引用变量x 由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行： 'use strict'; function foo() { var x = 1; function bar() { var y = x + 1; // bar可以访问foo的变量x! } var z = y + 1; // ReferenceError! foo不可以访问bar的变量y! } 变量提升 JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部： 'use strict'; function foo() { var x = 'Hello, ' + y; console.log(x); var y = 'Bob'; } foo(); 虽然是strict模式，但语句var x = 'Hello, ' + y;并不报错，原因是变量y在稍后申明了。但是console.log显示Hello, undefined，说明变量y的值为undefined。这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。 对于上述foo()函数，JavaScript引擎看到的代码相当于： function foo() { var y; // 提升变量y的申明，此时y为undefined var x = 'Hello, ' + y; console.log(x); y = 'Bob'; } 由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个var申明函数内部用到的所有变量： function foo() { var x = 1, // x初始化为1 y = x + 1, // y初始化为2 z, i; // z和i为undefined // 其他语句: for (i=0; i 全局作用域 不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性： 'use strict'; var course = 'Learn JavaScript'; alert(course); // 'Learn JavaScript' alert(window.course); // 'Learn JavaScript' 因此，直接访问全局变量course和访问window.course是完全一样的。 你可能猜到了，由于函数定义有两种方式，以变量方式var foo = function () {}定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象 名字空间 全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。 减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如： // 唯一的全局变量MYAPP: var MYAPP = {}; // 其他变量: MYAPP.name = 'myapp'; MYAPP.version = 1.0; // 其他函数: MYAPP.foo = function () { return 'foo'; }; 把自己的代码全部放入唯一的名字空间MYAPP中，会大大减少全局变量冲突的可能。 许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。 局部作用域 由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的： 'use strict'; function foo() { for (var i=0; i 为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量： 'use strict'; function foo() { var sum = 0; for (let i=0; i 常量 由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”： var PI = 3.14; ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域： 'use strict'; const PI = 3.14; PI = 3; // 某些浏览器不报错，但是无效果！ PI; // 3.14 解构赋值 从ES6开始，JavaScript引入了解构赋值，可以同时对一组变量进行赋值。 什么是解构赋值？我们先看看传统的做法，如何把一个数组的元素分别赋值给几个变量： var array = ['hello', 'JavaScript', 'ES6']; var x = array[0]; var y = array[1]; var z = array[2]; 现在，在ES6中，可以使用解构赋值，直接对多个变量同时赋值： 'use strict'; // 如果浏览器支持解构赋值就不会报错: var [x, y, z] = ['hello', 'JavaScript', 'ES6']; 注意，对数组元素进行解构赋值时，多个变量要用[...]括起来。 如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致： let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']]; x; // 'hello' y; // 'JavaScript' z; // 'ES6' 解构赋值还可以忽略某些元素： let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素 z; // 'ES6' 如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性： 'use strict'; var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school' }; var {name, age, passport} = person; 对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的： var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school', address: { city: 'Beijing', street: 'No.1 Road', zipcode: '100001' } }; var {name, address: {city, zip}} = person; name; // '小明' city; // 'Beijing' zip; // undefined, 因为属性名是zipcode而不是zip // 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性: address; // Uncaught ReferenceError: address is not defined 使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为undefined，这和引用一个不存在的属性获得undefined是一致的。如果要使用的变量名和属性名不一致，可以用下面的语法获取： var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school' }; // 把passport属性赋值给变量id: let {name, passport:id} = person; name; // '小明' id; // 'G-12345678' // 注意: passport不是变量，而是为了让变量id获得passport属性: passport; // Uncaught ReferenceError: passport is not defined 解构赋值还可以使用默认值，这样就避免了不存在的属性返回undefined的问题： var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678' }; // 如果person对象没有single属性，默认赋值为true: var {name, single=true} = person; name; // '小明' single; // true 有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误： // 声明变量: var x, y; // 解构赋值: {x, y} = { name: '小明', x: 100, y: 200}; // 语法错误: Uncaught SyntaxError: Unexpected token = 这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来： ({x, y} = { name: '小明', x: 100, y: 200}); 解构赋值的使用场景 解构赋值在很多时候可以大大简化代码。例如，交换两个变量x和y的值，可以这么写，不再需要临时变量： var x=1, y=2; [x, y] = [y, x] 快速获取当前页面的域名和路径： var {hostname:domain, pathname:path} = location; 如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个Date对象： function buildDate({year, month, day, hour=0, minute=0, second=0}) { return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second); } 它的方便之处在于传入的对象只需要year、month和day这三个属性： buildDate({ year: 2017, month: 1, day: 1 }); // Sun Jan 01 2017 00:00:00 GMT+0800 (CST) 也可以传入hour、minute和second属性： buildDate({ year: 2017, month: 1, day: 1, hour: 20, minute: 15 }); // Sun Jan 01 2017 20:15:00 GMT+0800 (CST) 三、方法 在一个对象中绑定函数，称为这个对象的方法。 在JavaScript中，对象的定义是这样的： var xiaoming = { name: '小明', birth: 1990 }; 但是，如果我们给xiaoming绑定一个函数，就可以做更多的事情。比如，写个age()方法，返回xiaoming的年龄： var xiaoming = { name: '小明', birth: 1990, age: function () { var y = new Date().getFullYear(); return y - this.birth; } }; xiaoming.age; // function xiaoming.age() xiaoming.age(); // 今年调用是25,明年调用就变成26了 绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个东东是什么？ 在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。 让我们拆开写： function getAge() { var y = new Date().getFullYear(); return y - this.birth; } var xiaoming = { name: '小明', birth: 1990, age: getAge }; xiaoming.age(); // 25, 正常结果 getAge(); // NaN 单独调用函数getAge()怎么返回了NaN？请注意，我们已经进入到了JavaScript的一个大坑里。 JavaScript的函数内部如果调用了this，那么这个this到底指向谁？ 答案是，视情况而定！ 如果以对象的方法形式调用，比如xiaoming.age()，该函数的this指向被调用的对象，也就是xiaoming，这是符合我们预期的。 如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。 坑爹啊！ 更坑爹的是，如果这么写： var fn = xiaoming.age; // 先拿到xiaoming的age函数 fn(); // NaN 也是不行的！要保证this指向正确，必须用obj.xxx()的形式调用！ 由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在strict模式下让函数的this指向undefined，因此，在strict模式下，你会得到一个错误： 'use strict'; var xiaoming = { name: '小明', birth: 1990, age: function () { var y = new Date().getFullYear(); return y - this.birth; } }; var fn = xiaoming.age; fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined 这个决定只是让错误及时暴露出来，并没有解决this应该指向的正确位置。 有些时候，喜欢重构的你把方法重构了一下： 'use strict'; var xiaoming = { name: '小明', birth: 1990, age: function () { function getAgeFromBirth() { var y = new Date().getFullYear(); return y - this.birth; } return getAgeFromBirth(); } }; xiaoming.age(); // Uncaught TypeError: Cannot read property 'birth' of undefined 结果又报错了！原因是this指针只在age方法的函数内指向xiaoming，在函数内部定义的函数，this又指向undefined了！（在非strict模式下，它重新指向全局对象window！） 修复的办法也不是没有，我们用一个that变量首先捕获this： 'use strict'; var xiaoming = { name: '小明', birth: 1990, age: function () { var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() { var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this } return getAgeFromBirth(); } }; xiaoming.age(); // 25 用var that = this;，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。 apply 虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！ 要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。 用apply修复getAge()调用： function getAge() { var y = new Date().getFullYear(); return y - this.birth; } var xiaoming = { name: '小明', birth: 1990, age: getAge }; xiaoming.age(); // 25 getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空 另一个与apply()类似的方法是call()，唯一区别是： apply()把参数打包成Array再传入； call()把参数按顺序传入。 比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下： Math.max.apply(null, [3, 5, 4]); // 5 Math.max.call(null, 3, 5, 4); // 5 对普通函数调用，我们通常把this绑定为null。 装饰器 利用apply()，我们还可以动态改变函数的行为。 JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。 现在假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count += 1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()： 'use strict'; var count = 0; var oldParseInt = parseInt; // 保存原函数 window.parseInt = function () { count += 1; return oldParseInt.apply(null, arguments); // 调用原函数 }; 四、高阶函数 编写高阶函数，就是让函数的参数能够接收别的函数。 map 举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个数组[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map实现如下： 由于map()方法定义在JavaScript的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果： 'use strict'; function pow(x) { return x * x; } var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81] map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x^2，还可以计算任意复杂的函数，比如，把Array的所有数字转为字符串： var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9'] reduce 再看reduce的用法。Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是： [x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4) 比方说对一个Array求和，就可以用reduce实现： var arr = [1, 3, 5, 7, 9]; arr.reduce(function (x, y) { return x + y; }); // 25 filter filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。 和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。 例如，在一个Array中，删掉偶数，只保留奇数，可以这么写： var arr = [1, 2, 4, 5, 6, 9, 10, 15]; var r = arr.filter(function (x) { return x % 2 !== 0; }); r; // [1, 5, 9, 15] 把一个Array中的空字符串删掉，可以这么写： var arr = ['A', '', 'B', null, undefined, 'C', ' ']; var r = arr.filter(function (s) { return s && s.trim(); // 注意：IE9以下的版本没有trim()方法 }); r; // ['A', 'B', 'C'] 可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。 filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身： var arr = ['A', 'B', 'C']; var r = arr.filter(function (element, index, self) { console.log(element); // 依次打印'A', 'B', 'C' console.log(index); // 依次打印0, 1, 2 console.log(self); // self就是变量arr return true; }); sort avaScript的Array的sort()方法就是用于排序的，但是排序结果可能让你大吃一惊： // 看上去正常的结果: ['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft']; // apple排在了最后: ['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft\", 'apple'] // 无法理解的结果: [10, 20, 1, 2].sort(); // [1, 10, 2, 20] 第二个排序把apple排在了最后，是因为字符串根据ASCII码进行排序，而小写字母a的ASCII码在大写字母之后。 第三个排序结果是什么鬼？简单的数字排序都能错？ 这是因为Array的sort()方法默认把所有元素先转换为String再排序，结果'10'排在了'2'的前面，因为字符'1'比字符'2'的ASCII码小。 如果不知道sort()方法的默认排序规则，直接对数字排序，绝对栽进坑里！ 幸运的是，sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。 要按数字大小排序，我们可以这么写： arr.sort(function (x, y) { if (x y) { return 1; } return 0; }); console.log(arr); // [1, 2, 10, 20] 如果要倒序排序，我们可以把大的数放前面： var arr = [10, 20, 1, 2]; arr.sort(function (x, y) { if (x y) { return -1; } return 0; }); // [20, 10, 2, 1] 默认情况下，对字符串排序，是按照ASCII的大小比较的，现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以： var arr = ['Google', 'apple', 'Microsoft']; arr.sort(function (s1, s2) { x1 = s1.toUpperCase(); x2 = s2.toUpperCase(); if (x1 x2) { return 1; } return 0; }); // ['apple', 'Google', 'Microsoft'] 忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。 从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。 最后友情提示，sort()方法会直接对Array进行修改，它返回的结果仍是当前Array： var a1 = ['B', 'A', 'C']; var a2 = a1.sort(); a1; // ['A', 'B', 'C'] a2; // ['A', 'B', 'C'] a1 === a2; // true, a1和a2是同一对象 Array中的高阶函数 every every()方法可以判断数组的所有元素是否满足测试条件。 find find()方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回undefined findIndex findIndex()和find()类似，也是查找符合条件的第一个元素，不同之处在于findIndex()会返回这个元素的索引，如果没有找到，返回-1 forEach forEach()和map()类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。forEach()常用于遍历数组，因此，传入的函数不需要返回值 var arr = ['Apple', 'pear', 'orange']; arr.forEach(console.log); // 依次打印每个元素 五、闭包 函数作为返回值 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 我们来实现一个对Array的求和。通常情况下，求和的函数是这样定义的： function sum(arr) { return arr.reduce(function (x, y) { return x + y; }); } sum([1, 2, 3, 4, 5]); // 15 但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！ function lazy_sum(arr) { var sum = function () { return arr.reduce(function (x, y) { return x + y; }); } return sum; } 当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数： var f = lazy_sum([1, 2, 3, 4, 5]); // function sum() 调用函数f时，才真正计算求和的结果： f(); // 15 在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。 请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数： var f1 = lazy_sum([1, 2, 3, 4, 5]); var f2 = lazy_sum([1, 2, 3, 4, 5]); f1 === f2; // false f1()和f2()的调用结果互不影响。 闭包 注意到返回的函数在其定义内部引用了局部变量arr，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。 另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子： function count() { var arr = []; for (var i=1; i 在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了。 你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是： f1(); // 16 f2(); // 16 f3(); // 16 全部都是16！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了4，因此最终结果为16。 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变： function count() { var arr = []; for (var i=1; i 注意这里用了一个“创建一个匿名函数并立刻执行”的语法： (function (x) { return x * x; })(3); // 9 理论上讲，创建一个匿名函数并立刻执行可以这么写： function (x) { return x * x } (3); 但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来： (function (x) { return x * x }) (3); 通常，一个立即执行的匿名函数可以把函数体拆开，一般这么写： (function (x) { return x * x; })(3); 说了这么多，难道闭包就是为了返回一个函数然后延迟执行吗？ 当然不是！闭包有非常强大的功能。举个栗子： 在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。 在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器： 'use strict'; function create_counter(initial) { var x = initial || 0; return { inc: function () { x += 1; return x; } } } 它用起来像这样： var c1 = create_counter(); c1.inc(); // 1 c1.inc(); // 2 c1.inc(); // 3 var c2 = create_counter(10); c2.inc(); // 11 c2.inc(); // 12 c2.inc(); // 13 在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。 六、箭头函数 => 箭头函数 : x => x * x 相当于 : function (x) { return x * x; } 箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ ... }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ ... }和return： x => { // 包含多条语句就不能省略{ ... }和return if (x > 0) { return x * x; } else { return - x * x; } } 如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错： // SyntaxError: x => { foo: x } 因为和函数体的{ ... }有语法冲突，所以要改为： // ok: x => ({ foo: x }) this 箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。 回顾前面的例子，由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果： var obj = { birth: 1990, getAge: function () { var b = this.birth; // 1990 var fn = function () { return new Date().getFullYear() - this.birth; // this指向window或undefined }; return fn(); } }; 现在，箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj： var obj = { birth: 1990, getAge: function () { var b = this.birth; // 1990 var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象 return fn(); } }; obj.getAge(); // 25 如果使用箭头函数，以前的那种hack写法： var that = this; 就不再需要了。 例题--数组排序 对数组[10,20,1,2]进行排序 --> [1,2,10,20] 第一种写法: var arr = [10, 20, 1, 2]; arr.sort(function (x, y) { if (x y) { return 1; } return 0; }); // [1,2,10,20] 第二种写法(箭头函数) : arr.sort((x,y)=>(x-y)); // 无敌 七、生成器generator 略 :生成器generator Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/01.Javascript/03.标准对象.html":{"url":"roccoshi_note/07-前端学习/01.Javascript/03.标准对象.html","title":"03.标准对象","keywords":"","body":"03.标准对象typeof包装对象Date时区正则表达式创建RegExp对象testexec与分组贪婪匹配全局搜索JSON序列化反序列化03.标准对象 typeof 在JavaScript的世界里，一切都是对象。 但是某些对象还是和其他对象不太一样。为了区分对象的类型，我们用typeof操作符获取对象的类型，它总是返回一个字符串： typeof 123; // 'number' typeof NaN; // 'number' typeof 'str'; // 'string' typeof true; // 'boolean' typeof undefined; // 'undefined' typeof Math.abs; // 'function' typeof null; // 'object' typeof []; // 'object' typeof {}; // 'object' 可见，number、string、boolean、function和undefined有别于其他类型。特别注意null的类型是object，Array的类型也是object，如果我们用typeof将无法区分出null、Array和通常意义上的object——{}。 下面请欣赏js的脏语法: 包装对象 除了这些类型外，JavaScript还提供了包装对象，熟悉Java的小伙伴肯定很清楚int和Integer这种暧昧关系。 number、boolean和string都有包装对象。没错，在JavaScript中，字符串也区分string类型和它的包装类型。包装对象用new创建： var n = new Number(123); // 123,生成了新的包装类型 var b = new Boolean(true); // true,生成了新的包装类型 var s = new String('str'); // 'str',生成了新的包装类型 虽然包装对象看上去和原来的值一模一样，显示出来也是一模一样，但他们的类型已经变为object了！所以，包装对象和原始值用===比较会返回false： typeof new Number(123); // 'object' new Number(123) === 123; // false typeof new Boolean(true); // 'object' new Boolean(true) === true; // false typeof new String('str'); // 'object' new String('str') === 'str'; // false 所以闲的蛋疼也不要使用包装对象！尤其是针对string类型！！！ 如果我们在使用Number、Boolean和String时，没有写new会发生什么情况？ 此时，Number()、Boolean和String()被当做普通函数，把任何类型的数据转换为number、boolean和string类型（注意不是其包装类型）： var n = Number('123'); // 123，相当于parseInt()或parseFloat() typeof n; // 'number' var b = Boolean('true'); // true typeof b; // 'boolean' var b2 = Boolean('false'); // true! 'false'字符串转换结果为true！因为它是非空字符串！ var b3 = Boolean(''); // false var s = String(123.45); // '123.45' typeof s; // 'string' 是不是感觉头大了？这就是JavaScript特有的催眠魅力！ 总结一下，有这么几条规则需要遵守： 不要使用new Number()、new Boolean()、new String()创建包装对象； 用parseInt()或parseFloat()来转换任意类型到number； 用String()来转换任意类型到string，或者直接调用某个对象的toString()方法； 通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}； typeof操作符可以判断出number、boolean、string、function和undefined； 判断Array要使用Array.isArray(arr)； 判断null请使用myVar === null； 判断某个全局变量是否存在用typeof window.myVar === 'undefined'； 函数内部判断某个变量是否存在用typeof myVar === 'undefined'。 最后有细心的同学指出，任何对象都有toString()方法吗？null和undefined就没有！确实如此，这两个特殊值要除外，虽然null还伪装成了object类型。 更细心的同学指出，number对象调用toString()报SyntaxError： 123.toString(); // SyntaxError 遇到这种情况，要特殊处理一下： 123..toString(); // '123', 注意是两个点！ (123).toString(); // '123' 不要问为什么，这就是JavaScript代码的乐趣！ Date 在JavaScript中，Date对象用来表示日期和时间。 要获取系统当前时间，用： var now = new Date(); now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST) now.getFullYear(); // 2015, 年份 now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月 now.getDate(); // 24, 表示24号 now.getDay(); // 3, 表示星期三 now.getHours(); // 19, 24小时制 now.getMinutes(); // 49, 分钟 now.getSeconds(); // 22, 秒 now.getMilliseconds(); // 875, 毫秒数 now.getTime(); // 1435146562875, 以number形式表示的时间戳 注意，当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定为任何值。 如果要创建一个指定日期和时间的Date对象，可以用： var d = new Date(2015, 5, 19, 20, 15, 30, 123); d; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST) 你可能观察到了一个非常非常坑爹的地方，就是JavaScript的月份范围用整数表示是0~11，0表示一月，1表示二月……，所以要表示6月，我们传入的是5！这绝对是JavaScript的设计者当时脑抽了一下，但是现在要修复已经不可能了。 第二种创建一个指定日期和时间的方法是解析一个符合ISO 8601格式的字符串： var d = Date.parse('2015-06-24T19:49:22.875+08:00'); d; // 1435146562875 但它返回的不是Date对象，而是一个时间戳。不过有时间戳就可以很容易地把它转换为一个Date： var d = new Date(1435146562875); d; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST) d.getMonth(); // 5 时区 Date对象表示的时间总是按浏览器所在时区显示的，不过我们既可以显示本地时间，也可以显示调整后的UTC时间： var d = new Date(1435146562875); d.toLocaleString(); // '2015/6/24 下午7:49:22'，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关 d.toUTCString(); // 'Wed, 24 Jun 2015 11:49:22 GMT'，UTC时间，与本地时间相差8小时 那么在JavaScript中如何进行时区转换呢？实际上，只要我们传递的是一个number类型的时间戳，我们就不用关心时区转换。任何浏览器都可以把一个时间戳正确转换为本地时间。 时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。 所以，我们只需要传递时间戳，或者把时间戳从数据库里读出来，再让JavaScript自动转换为当地时间就可以了。 正则表达式 JavaScript有两种方式创建一个正则表达式： 第一种方式是直接通过/正则表达式/写出来，第二种方式是通过new RegExp('正则表达式')创建一个RegExp对象。 创建RegExp对象 两种写法是一样的： var re1 = /ABC\\-001/; var re2 = new RegExp('ABC\\\\-001'); re1; // /ABC\\-001/ re2; // /ABC\\-001/ 注意，如果使用第二种写法，因为字符串的转义问题，字符串的两个\\\\实际上是一个\\。 test 先看看如何判断正则表达式是否匹配： var re = /^\\d{3}\\-\\d{3,8}$/; re.test('010-12345'); // true re.test('010-1234x'); // false re.test('010 12345'); // false RegExp对象的test()方法用于测试给定的字符串是否符合条件。 exec与分组 除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如： ^(\\d{3})-(\\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码： var re = /^(\\d{3})-(\\d{3,8})$/; re.exec('010-12345'); // ['010-12345', '010', '12345'] re.exec('010 12345'); // null 如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来。 exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。 exec()方法在匹配失败时返回null。 提取子串非常有用。来看一个更凶残的例子： var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/; re.exec('19:05:30'); // ['19:05:30', '19', '05', '30'] 这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期： var re = /^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/; 对于'2-30'，'4-31'这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。 贪婪匹配 需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0： var re = /^(\\d+)(0*)$/; re.exec('102300'); // ['102300', '102300', ''] 由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。 必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\\d+采用非贪婪匹配： var re = /^(\\d+?)(0*)$/; re.exec('102300'); // ['102300', '1023', '00'] 全局搜索 JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配： var r1 = /test/g; // 等价于: var r2 = new RegExp('test', 'g'); 全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引： var s = 'JavaScript, VBScript, JScript and ECMAScript'; var re=/[a-zA-Z]+Script/g; // 使用全局匹配: re.exec(s); // ['JavaScript'] re.lastIndex; // 10 re.exec(s); // ['VBScript'] re.lastIndex; // 20 re.exec(s); // ['JScript'] re.lastIndex; // 29 re.exec(s); // ['ECMAScript'] re.lastIndex; // 44 re.exec(s); // null，直到结束仍没有匹配到 全局匹配类似搜索，因此不能使用/^...$/，那样只会最多匹配一次。 正则表达式还可以指定i标志，表示忽略大小写，m标志，表示执行多行匹配。 JSON JSON是JavaScript Object Notation的缩写，它是一种数据交换格式。 在JSON出现之前，大家一直用XML来传递数据。因为XML是一种纯文本格式，所以它适合在网络上交换数据。XML本身不算复杂，但是，加上DTD、XSD、XPath、XSLT等一大堆复杂的规范以后，任何正常的软件开发人员碰到XML都会感觉头大了，最后大家发现，即使你努力钻研几个月，也未必搞得清楚XML的规范。 终于，在2002年的一天，道格拉斯·克罗克福特（Douglas Crockford）同学为了拯救深陷水深火热同时又被某几个巨型软件企业长期愚弄的软件工程师，发明了JSON这种超轻量级的数据交换格式。 道格拉斯同学长期担任雅虎的高级架构师，自然钟情于JavaScript。他设计的JSON实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型： number：和JavaScript的number完全一致； boolean：就是JavaScript的true或false； string：就是JavaScript的string； null：就是JavaScript的null； array：就是JavaScript的Array表示方式——[]； object：就是JavaScript的{ ... }表示方式。 并且，JSON还定死了字符集必须是UTF-8，表示多语言就没有问题了。为了统一解析，JSON的字符串规定必须用双引号\"\"，Object的键也必须用双引号\"\"。 由于JSON非常简单，很快就风靡Web世界，并且成为ECMA标准。几乎所有编程语言都有解析JSON的库，而在JavaScript中，我们可以直接使用JSON，因为JavaScript内置了JSON的解析。 把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串，这样才能够通过网络传递给其他计算机。 如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。 序列化 var xiaoming = { name: '小明', age: 14, gender: true, height: 1.65, grade: null, 'middle-school': '\\\"W3C\\\" Middle School', skills: ['JavaScript', 'Java', 'Python', 'Lisp'] }; var s = JSON.stringify(xiaoming); console.log(s); // --> {\"name\":\"小明\",\"age\":14,\"gender\":true,\"height\":1.65,\"grade\":null,\"middle-school\":\"\\\"W3C\\\" Middle School\",\"skills\":[\"JavaScript\",\"Java\",\"Python\",\"Lisp\"]} 要输出得好看一些，可以加上参数，按缩进输出： JSON.stringify(xiaoming, null, ' '); 结果： { \"name\": \"小明\", \"age\": 14, \"gender\": true, \"height\": 1.65, \"grade\": null, \"middle-school\": \"\\\"W3C\\\" Middle School\", \"skills\": [ \"JavaScript\", \"Java\", \"Python\", \"Lisp\" ] } 第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入Array： JSON.stringify(xiaoming, ['name', 'skills'], ' '); 结果： { \"name\": \"小明\", \"skills\": [ \"JavaScript\", \"Java\", \"Python\", \"Lisp\" ] } 还可以传入一个函数，这样对象的每个键值对都会被函数先处理： function convert(key, value) { if (typeof value === 'string') { return value.toUpperCase(); } return value; } JSON.stringify(xiaoming, convert, ' '); 上面的代码把所有属性值都变成大写： { \"name\": \"小明\", \"age\": 14, \"gender\": true, \"height\": 1.65, \"grade\": null, \"middle-school\": \"\\\"W3C\\\" MIDDLE SCHOOL\", \"skills\": [ \"JAVASCRIPT\", \"JAVA\", \"PYTHON\", \"LISP\" ] } 如果我们还想要精确控制如何序列化小明，可以给xiaoming定义一个toJSON()的方法，直接返回JSON应该序列化的数据： var xiaoming = { name: '小明', age: 14, gender: true, height: 1.65, grade: null, 'middle-school': '\\\"W3C\\\" Middle School', skills: ['JavaScript', 'Java', 'Python', 'Lisp'], toJSON: function () { return { // 只输出name和age，并且改变了key： 'Name': this.name, 'Age': this.age }; } }; JSON.stringify(xiaoming); // '{\"Name\":\"小明\",\"Age\":14}' 反序列化 拿到一个JSON格式的字符串，我们直接用JSON.parse()把它变成一个JavaScript对象： JSON.parse('[1,2,3,true]'); // [1, 2, 3, true] JSON.parse('{\"name\":\"小明\",\"age\":14}'); // Object {name: '小明', age: 14} JSON.parse('true'); // true JSON.parse('123.45'); // 123.45 JSON.parse()还可以接收一个函数，用来转换解析出的属性： var obj = JSON.parse('{\"name\":\"小明\",\"age\":14}', function (key, value) { if (key === 'name') { return value + '同学'; } return value; }); console.log(JSON.stringify(obj)); // {name: '小明同学', age: 14} Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/02.NODE.JS/":{"url":"roccoshi_note/07-前端学习/02.NODE.JS/","title":"02.NODE.JS","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/02.NODE.JS/03. 基本模块/":{"url":"roccoshi_note/07-前端学习/02.NODE.JS/03. 基本模块/","title":"03. 基本模块","keywords":"","body":"globalprocess判断JavaScript执行环境 因为Node.js是运行在服务区端的JavaScript环境，服务器程序和浏览器程序相比，最大的特点是没有浏览器的安全限制了，而且，服务器程序必须能接收网络请求，读写文件，处理二进制内容，所以，Node.js内置的常用模块就是为了实现基本的服务器功能。这些模块在浏览器环境中是无法被执行的，因为它们的底层代码是用C/C++在Node.js运行环境中实现的。 global 在前面的JavaScript课程中，我们已经知道，JavaScript有且仅有一个全局对象，在浏览器中，叫window对象。而在Node.js环境中，也有唯一的全局对象，但不叫window，而叫global，这个对象的属性和方法也和浏览器环境的window不同。进入Node.js交互环境，可以直接输入： > global.console Console { log: [Function: bound ], info: [Function: bound ], warn: [Function: bound ], error: [Function: bound ], dir: [Function: bound ], time: [Function: bound ], timeEnd: [Function: bound ], trace: [Function: bound trace], assert: [Function: bound ], Console: [Function: Console] } process process也是Node.js提供的一个对象，它代表当前Node.js进程。通过process对象可以拿到许多有用信息： > process === global.process; true > process.version; 'v5.2.0' > process.platform; 'darwin' > process.arch; 'x64' > process.cwd(); //返回当前工作目录 '/Users/michael' > process.chdir('/private/tmp'); // 切换当前工作目录 undefined > process.cwd(); '/private/tmp' JavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。 如果我们想要在下一次事件响应中执行代码，可以调用process.nextTick()： // test.js // process.nextTick()将在下一轮事件循环中调用: process.nextTick(function () { console.log('nextTick callback!'); }); console.log('nextTick was set!'); 用Node执行上面的代码node test.js，你会看到，打印输出是： nextTick was set! nextTick callback! 这说明传入process.nextTick()的函数不是立刻执行，而是要等到下一次事件循环。 Node.js进程本身的事件就由process对象来处理。如果我们响应exit事件，就可以在程序即将退出时执行某个回调函数： // 程序即将退出时的回调函数: process.on('exit', function (code) { console.log('about to exit with code: ' + code); }); 判断JavaScript执行环境 有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断： if (typeof(window) === 'undefined') { console.log('node.js'); } else { console.log('browser'); } 后面，我们将介绍Node.js的常用内置模块。 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/02.NODE.JS/03. 基本模块/3.1 fs.html":{"url":"roccoshi_note/07-前端学习/02.NODE.JS/03. 基本模块/3.1 fs.html","title":"3.1 fs","keywords":"","body":"3.1 fs异步读文件同步读文件写文件stat异步还是同步3.1 fs Node.js内置的fs模块就是文件系统模块，负责读写文件。 和所有其它JavaScript模块不同的是，fs模块同时提供了异步和同步的方法。 回顾一下什么是异步方法。因为JavaScript的单线程模型，执行IO操作时，JavaScript代码无需等待，而是传入回调函数后，继续执行后续JavaScript代码。比如jQuery提供的getJSON()操作： $.getJSON('http://example.com/ajax', function (data) { console.log('IO结果返回后执行...'); }); console.log('不等待IO结果直接执行后续代码...'); 而同步的IO操作则需要等待函数返回： // 根据网络耗时，函数将执行几十毫秒~几秒不等: var data = getJSONSync('http://example.com/ajax'); 同步操作的好处是代码简单，缺点是程序将等待IO操作，在等待时间内，无法响应其它任何事件。而异步读取不用等待IO操作，但代码较麻烦。 异步读文件 按照JavaScript的标准，异步读取一个文本文件的代码如下： 'use strict'; var fs = require('fs'); fs.readFile('sample.txt', 'utf-8', function (err, data) { if (err) { console.log(err); } else { console.log(data); } }); 请注意，sample.txt文件必须在当前目录下，且文件编码为utf-8。 异步读取时，传入的回调函数接收两个参数，当正常读取时，err参数为null，data参数为读取到的String。当读取发生错误时，err参数代表一个错误对象，data为undefined。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们还会经常编写这种回调函数。 由于err是否为null就是判断是否出错的标志，所以通常的判断逻辑总是： if (err) { // 出错了 } else { // 正常 } 如果我们要读取的文件不是文本文件，而是二进制文件，怎么办？ 下面的例子演示了如何读取一个图片文件： 'use strict'; var fs = require('fs'); fs.readFile('sample.png', function (err, data) { if (err) { console.log(err); } else { console.log(data); console.log(data.length + ' bytes'); } }); 当读取二进制文件时，不传入文件编码时，回调函数的data参数将返回一个Buffer对象。在Node.js中，Buffer对象就是一个包含零个或任意个字节的数组（注意和Array不同）。 Buffer对象可以和String作转换，例如，把一个Buffer对象转换成String： // Buffer -> String var text = data.toString('utf-8'); console.log(text); 或者把一个String转换成Buffer： // String -> Buffer var buf = Buffer.from(text, 'utf-8'); console.log(buf); 同步读文件 除了标准的异步读取模式外，fs也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个Sync后缀，并且不接收回调函数，函数直接返回结果。 用fs模块同步读取一个文本文件的代码如下： 'use strict'; var fs = require('fs'); var data = fs.readFileSync('sample.txt', 'utf-8'); console.log(data); 可见，原异步调用的回调函数的data被函数直接返回，函数名需要改为readFileSync，其它参数不变。 如果同步读取文件发生错误，则需要用try...catch捕获该错误： try { var data = fs.readFileSync('sample.txt', 'utf-8'); console.log(data); } catch (err) { // 出错了 } 写文件 将数据写入文件是通过fs.writeFile()实现的： 'use strict'; var fs = require('fs'); var data = 'Hello, Node.js'; fs.writeFile('output.txt', data, function (err) { if (err) { console.log(err); } else { console.log('ok.'); } }); writeFile()的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是Buffer，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个err参数。 和readFile()类似，writeFile()也有一个同步方法，叫writeFileSync()： 'use strict'; var fs = require('fs'); var data = 'Hello, Node.js'; fs.writeFileSync('output.txt', data); stat 如果我们要获取文件大小，创建时间等信息，可以使用fs.stat()，它返回一个Stat对象，能告诉我们文件或目录的详细信息： 'use strict'; var fs = require('fs'); fs.stat('sample.txt', function (err, stat) { if (err) { console.log(err); } else { // 是否是文件: console.log('isFile: ' + stat.isFile()); // 是否是目录: console.log('isDirectory: ' + stat.isDirectory()); if (stat.isFile()) { // 文件大小: console.log('size: ' + stat.size); // 创建时间, Date对象: console.log('birth time: ' + stat.birthtime); // 修改时间, Date对象: console.log('modified time: ' + stat.mtime); } } }); 运行结果如下： isFile: true isDirectory: false size: 181 birth time: Fri Dec 11 2015 09:43:41 GMT+0800 (CST) modified time: Fri Dec 11 2015 12:09:00 GMT+0800 (CST) stat()也有一个对应的同步函数statSync()，请试着改写上述异步代码为同步代码。 异步还是同步 在fs模块中，提供同步方法是为了方便使用。那我们到底是应该用异步方法还是同步方法呢？ 由于Node环境执行的JavaScript代码是服务器端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，必须使用异步代码，否则，同步代码在执行时期，服务器将停止响应，因为JavaScript只有一个执行线程。 服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/02.NODE.JS/03. 基本模块/3.2 stream.html":{"url":"roccoshi_note/07-前端学习/02.NODE.JS/03. 基本模块/3.2 stream.html","title":"3.2 stream","keywords":"","body":"3.2 streampipe3.2 stream stream是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。 什么是流？流是一种抽象的数据结构。想象水流，当在水管中流动时，就可以从某个地方（例如自来水厂）源源不断地到达另一个地方（比如你家的洗手池）。我们也可以把数据看成是数据流，比如你敲键盘的时候，就可以把每个字符依次连起来，看成字符流。这个流是从键盘输入到应用程序，实际上它还对应着一个名字：标准输入流（stdin）。 如果应用程序把字符一个一个输出到显示器上，这也可以看成是一个流，这个流也有名字：标准输出流（stdout）。流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。 有些流用来读取数据，比如从文件读取数据时，可以打开一个文件流，然后从文件流中不断地读取数据。有些流用来写入数据，比如向文件写入数据时，只需要把数据不断地往文件流中写进去就可以了。 在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：data事件表示流的数据已经可以读取了，end事件表示这个流已经到末尾了，没有数据可以读取了，error事件表示出错了。 下面是一个从文件流读取文本内容的示例： 'use strict'; var fs = require('fs'); // 打开一个流: var rs = fs.createReadStream('sample.txt', 'utf-8'); rs.on('data', function (chunk) { console.log('DATA:') console.log(chunk); }); rs.on('end', function () { console.log('END'); }); rs.on('error', function (err) { console.log('ERROR: ' + err); }); 要注意，data事件可能会有多次，每次传递的chunk是流的一部分数据。 要以流的形式写入文件，只需要不断调用write()方法，最后以end()结束： 'use strict'; var fs = require('fs');js var ws1 = fs.createWriteStream('output1.txt', 'utf-8'); ws1.write('使用Stream写入文本数据...\\n'); ws1.write('END.'); ws1.end(); var ws2 = fs.createWriteStream('output2.txt'); ws2.write(new Buffer('使用Stream写入二进制数据...\\n', 'utf-8')); ws2.write(new Buffer('END.', 'utf-8')); ws2.end(); 所有可以读取数据的流都继承自stream.Readable，所有可以写入的流都继承自stream.Writable。 pipe 就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个Readable流和一个Writable流串起来后，所有的数据自动从Readable流进入Writable流，这种操作叫pipe。 在Node.js中，Readable流有一个pipe()方法，就是用来干这件事的。 让我们用pipe()把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序： 'use strict'; var fs = require('fs'); var rs = fs.createReadStream('sample.txt'); var ws = fs.createWriteStream('copied.txt'); rs.pipe(ws); 默认情况下，当Readable流的数据读取完毕，end事件触发后，将自动关闭Writable流。如果我们不希望自动关闭Writable流，需要传入参数： readable.pipe(writable, { end: false }); Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/02.NODE.JS/03. 基本模块/3.3 http.html":{"url":"roccoshi_note/07-前端学习/02.NODE.JS/03. 基本模块/3.3 http.html","title":"3.3 http","keywords":"","body":"3.3 httpHTTP协议HTTP服务器文件服务器3.3 http HTTP协议 要理解Web服务器程序的工作原理，首先，我们要对HTTP协议有基本的了解。如果你对HTTP协议不太熟悉，先看一看HTTP协议简介。 HTTP服务器 要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的http模块完成了。应用程序并不直接和HTTP协议打交道，而是操作http模块提供的request和response对象。 request对象封装了HTTP请求，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息； response对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器。 用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序hello.js，它对于所有请求，都返回Hello world!： 'use strict'; // 导入http模块: var http = require('http'); // 创建http server，并传入回调函数: var server = http.createServer(function (request, response) { // 回调函数接收request和response对象, // 获得HTTP请求的method和url: console.log(request.method + ': ' + request.url); // 将HTTP响应200写入response, 同时设置Content-Type: text/html: response.writeHead(200, {'Content-Type': 'text/html'}); // 将HTTP响应的HTML内容写入response: response.end('Hello world!'); }); // 让服务器监听8080端口: server.listen(8080); console.log('Server is running at http://127.0.0.1:8080/'); 文件服务器 让我们继续扩展一下上面的Web程序。我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析request.url中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。 解析URL需要用到Node.js提供的url模块，它使用起来非常简单，通过parse()将一个字符串解析为一个Url对象： 'use strict'; var url = require('url'); console.log(url.parse('http://user:pass@host.com:8080/path/to/file?query=string#hash')); 结果如下： Url { protocol: 'http:', slashes: true, auth: 'user:pass', host: 'host.com:8080', port: '8080', hostname: 'host.com', hash: '#hash', search: '?query=string', query: 'query=string', pathname: '/path/to/file', path: '/path/to/file?query=string', href: 'http://user:pass@host.com:8080/path/to/file?query=string#hash' } 处理本地文件目录需要使用Node.js提供的path模块，它可以方便地构造目录： 'use strict'; var path = require('path'); // 解析当前目录: var workDir = path.resolve('.'); // '/Users/michael' // 组合完整的文件路径:当前目录+'pub'+'index.html': var filePath = path.join(workDir, 'pub', 'index.html'); // '/Users/michael/pub/index.html' 使用path模块可以正确处理操作系统相关的文件路径。在Windows系统下，返回的路径类似于C:\\Users\\michael\\static\\index.html，这样，我们就不关心怎么拼接路径了。 最后，我们实现一个文件服务器file_server.js： 'use strict'; var fs = require('fs'), url = require('url'), path = require('path'), http = require('http'); // 从命令行参数获取root目录，默认是当前目录: var root = path.resolve(process.argv[2] || '.'); console.log('Static root dir: ' + root); // 创建服务器: var server = http.createServer(function (request, response) { // 获得URL的path，类似 '/css/bootstrap.css': var pathname = url.parse(request.url).pathname; // 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css': var filepath = path.join(root, pathname); // 获取文件状态: fs.stat(filepath, function (err, stats) { if (!err && stats.isFile()) { // 没有出错并且文件存在: console.log('200 ' + request.url); // 发送200响应: response.writeHead(200); // 将文件流导向response: fs.createReadStream(filepath).pipe(response); } else { // 出错了或者文件不存在: console.log('404 ' + request.url); // 发送404响应: response.writeHead(404); response.end('404 Not Found'); } }); }); server.listen(8080); console.log('Server is running at http://127.0.0.1:8080/'); 没有必要手动读取文件内容。由于response对象本身是一个Writable Stream，直接用pipe()方法就实现了自动读取文件内容并输出到HTTP响应。 在命令行运行node file_server.js /path/to/dir，把/path/to/dir改成你本地的一个有效的目录，然后在浏览器中输入http://localhost:8080/index.html： Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/02.NODE.JS/03. 基本模块/3.4 crypto.html":{"url":"roccoshi_note/07-前端学习/02.NODE.JS/03. 基本模块/3.4 crypto.html","title":"3.4 crypto","keywords":"","body":"3.4 cryptoMD5和SHA1HmacAESDiffie-HellmanRSA证书3.4 crypto crypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。 MD5和SHA1 MD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示： const crypto = require('crypto'); const hash = crypto.createHash('md5'); // 可任意多次调用update(): hash.update('Hello, world!'); hash.update('Hello, nodejs!'); console.log(hash.digest('hex')); // 7e1977739c748beac0c0fd14fd26a544 update()方法默认字符串编码为UTF-8，也可以传入Buffer。 如果要计算SHA1，只需要把'md5'改成'sha1'，就可以得到SHA1的结果1f32b9c9932c02227819a4151feed43e131aca40。 还可以使用更安全的sha256和sha512。 Hmac Hmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥： const crypto = require('crypto'); const hmac = crypto.createHmac('sha256', 'secret-key'); hmac.update('Hello, world!'); hmac.update('Hello, nodejs!'); console.log(hmac.digest('hex')); // 80f7e22570... 只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法。 AES AES是一种常用的对称加密算法，加解密都用同一个密钥。crypto模块提供了AES支持，但是需要自己封装好函数，便于使用： const crypto = require('crypto'); function aesEncrypt(data, key) { const cipher = crypto.createCipher('aes192', key); var crypted = cipher.update(data, 'utf8', 'hex'); crypted += cipher.final('hex'); return crypted; } function aesDecrypt(encrypted, key) { const decipher = crypto.createDecipher('aes192', key); var decrypted = decipher.update(encrypted, 'hex', 'utf8'); decrypted += decipher.final('utf8'); return decrypted; } var data = 'Hello, this is a secret message!'; var key = 'Password!'; var encrypted = aesEncrypt(data, key); var decrypted = aesDecrypt(encrypted, key); console.log('Plain text: ' + data); console.log('Encrypted text: ' + encrypted); console.log('Decrypted text: ' + decrypted); 运行结果如下： Plain text: Hello, this is a secret message! Encrypted text: 8a944d97bdabc157a5b7a40cb180e7... Decrypted text: Hello, this is a secret message! 可以看出，加密后的字符串通过解密又得到了原始内容。 注意到AES有很多不同的算法，如aes192，aes-128-ecb，aes-256-cbc等，AES除了密钥外还可以指定IV（Initial Vector），不同的系统只要IV不同，用相同的密钥加密相同的数据得到的加密结果也是不同的。加密结果通常有两种表示方法：hex和base64，这些功能Nodejs全部都支持，但是在应用中要注意，如果加解密双方一方用Nodejs，另一方用Java、PHP等其它语言，需要仔细测试。如果无法正确解密，要确认双方是否遵循同样的AES算法，字符串密钥和IV是否相同，加密后的数据是否统一为hex或base64格式。 Diffie-Hellman DH算法是一种密钥交换协议，它可以让双方在不泄漏密钥的情况下协商出一个密钥来。DH算法基于数学原理，比如小明和小红想要协商一个密钥，可以这么做： 小明先选一个素数和一个底数，例如，素数p=23，底数g=5（底数可以任选），再选择一个秘密整数a=6，计算A=g^a mod p=8，然后大声告诉小红：p=23，g=5，A=8； 小红收到小明发来的p，g，A后，也选一个秘密整数b=15，然后计算B=g^b mod p=19，并大声告诉小明：B=19； 小明自己计算出s=B^a mod p=2，小红也自己计算出s=A^b mod p=2，因此，最终协商的密钥s为2。 在这个过程中，密钥2并不是小明告诉小红的，也不是小红告诉小明的，而是双方协商计算出来的。第三方只能知道p=23，g=5，A=8，B=19，由于不知道双方选的秘密整数a=6和b=15，因此无法计算出密钥2。 用crypto模块实现DH算法如下： const crypto = require('crypto'); // xiaoming's keys: var ming = crypto.createDiffieHellman(512); var ming_keys = ming.generateKeys(); var prime = ming.getPrime(); var generator = ming.getGenerator(); console.log('Prime: ' + prime.toString('hex')); console.log('Generator: ' + generator.toString('hex')); // xiaohong's keys: var hong = crypto.createDiffieHellman(prime, generator); var hong_keys = hong.generateKeys(); // exchange and generate secret: var ming_secret = ming.computeSecret(hong_keys); var hong_secret = hong.computeSecret(ming_keys); // print secret: console.log('Secret of Xiao Ming: ' + ming_secret.toString('hex')); console.log('Secret of Xiao Hong: ' + hong_secret.toString('hex')); 运行后，可以得到如下输出： $ node dh.js Prime: a8224c...deead3 Generator: 02 Secret of Xiao Ming: 695308...d519be Secret of Xiao Hong: 695308...d519be 注意每次输出都不一样，因为素数的选择是随机的。 RSA RSA算法是一种非对称加密算法，即由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密。 RSA算法是1977年由Ron Rivest、Adi Shamir和Leonard Adleman共同提出的，所以以他们三人的姓氏的头字母命名。 当小明给小红发送信息时，可以用小明自己的私钥加密，小红用小明的公钥解密，也可以用小红的公钥加密，小红用她自己的私钥解密，这就是非对称加密。相比对称加密，非对称加密只需要每个人各自持有自己的私钥，同时公开自己的公钥，不需要像AES那样由两个人共享同一个密钥。 在使用Node进行RSA加密前，我们先要准备好私钥和公钥。 首先，在命令行执行以下命令以生成一个RSA密钥对： openssl genrsa -aes256 -out rsa-key.pem 2048 根据提示输入密码，这个密码是用来加密RSA密钥的，加密方式指定为AES256，生成的RSA的密钥长度是2048位。执行成功后，我们获得了加密的rsa-key.pem文件。 第二步，通过上面的rsa-key.pem加密文件，我们可以导出原始的私钥，命令如下： openssl rsa -in rsa-key.pem -outform PEM -out rsa-prv.pem 输入第一步的密码，我们获得了解密后的私钥。 类似的，我们用下面的命令导出原始的公钥： openssl rsa -in rsa-key.pem -outform PEM -pubout -out rsa-pub.pem 这样，我们就准备好了原始私钥文件rsa-prv.pem和原始公钥文件rsa-pub.pem，编码格式均为PEM。 下面，使用crypto模块提供的方法，即可实现非对称加解密。 首先，我们用私钥加密，公钥解密： const fs = require('fs'), crypto = require('crypto'); // 从文件加载key: function loadKey(file) { // key实际上就是PEM编码的字符串: return fs.readFileSync(file, 'utf8'); } let prvKey = loadKey('./rsa-prv.pem'), pubKey = loadKey('./rsa-pub.pem'), message = 'Hello, world!'; // 使用私钥加密: let enc_by_prv = crypto.privateEncrypt(prvKey, Buffer.from(message, 'utf8')); console.log('encrypted by private key: ' + enc_by_prv.toString('hex')); let dec_by_pub = crypto.publicDecrypt(pubKey, enc_by_prv); console.log('decrypted by public key: ' + dec_by_pub.toString('utf8')); 执行后，可以得到解密后的消息，与原始消息相同。 接下来我们使用公钥加密，私钥解密： // 使用公钥加密: let enc_by_pub = crypto.publicEncrypt(pubKey, Buffer.from(message, 'utf8')); console.log('encrypted by public key: ' + enc_by_pub.toString('hex')); // 使用私钥解密: let dec_by_prv = crypto.privateDecrypt(prvKey, enc_by_pub); console.log('decrypted by private key: ' + dec_by_prv.toString('utf8')); 执行得到的解密后的消息仍与原始消息相同。 如果我们把message字符串的长度增加到很长，例如1M，这时，执行RSA加密会得到一个类似这样的错误：data too large for key size，这是因为RSA加密的原始信息必须小于Key的长度。那如何用RSA加密一个很长的消息呢？实际上，RSA并不适合加密大数据，而是先生成一个随机的AES密码，用AES加密原始信息，然后用RSA加密AES口令，这样，实际使用RSA时，给对方传的密文分两部分，一部分是AES加密的密文，另一部分是RSA加密的AES口令。对方用RSA先解密出AES口令，再用AES解密密文，即可获得明文。 证书 crypto模块也可以处理数字证书。数字证书通常用在SSL连接，也就是Web的https连接。一般情况下，https连接只需要处理服务器端的单向认证，如无特殊需求（例如自己作为Root给客户发认证证书），建议用反向代理服务器如Nginx等Web服务器去处理证书。 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/02.NODE.JS/01. 安装与使用.html":{"url":"roccoshi_note/07-前端学习/02.NODE.JS/01. 安装与使用.html","title":"01. 安装与使用","keywords":"","body":"01. 安装与使用Node.jsnpm第一个node程序使用严格模式01. 安装与使用 Node.js 官方网站 : https://nodejs.org/ 安装后利用node -v查看版本号 在命令行输入node进入node.js的交互环境, 推出环境连续按两次ctrl + c npm 在正式开始Node.js学习之前，我们先认识一下npm。 npm是什么东东？npm其实是Node.js的包管理工具（package manager）。 为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。 更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。 讲了这么多，npm究竟在哪？ 其实npm已经在Node.js安装的时候顺带装好了。我们在命令提示符或者终端输入npm -v，应该看到类似的输出： C:\\>npm -v 4.1.2 如果直接输入npm，你会看到类似下面的输出： C:\\> npm Usage: npm where is one of: ... 上面的一大堆文字告诉你，npm需要跟上命令。现在我们不用关心这些命令，后面会一一讲到。目前，你只需要确保npm正确安装了，能运行就行。 第一个node程序 建立一个文件命名为hello.js 写入 'use strict'; console.log('Hello, world.'); 然后打开cmd切换到当前目录, 输入node hello.js 可以看到命令行显示了hello world. 使用严格模式 如果在JavaScript文件开头写上'use strict';，那么Node在执行该JavaScript时将使用严格模式。但是，在服务器环境下，如果有很多JavaScript文件，每个文件都写上'use strict';很麻烦。我们可以给Nodejs传递一个参数，让Node直接为所有js文件开启严格模式： node --use_strict calc.js Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/02.NODE.JS/02. 模块.html":{"url":"roccoshi_note/07-前端学习/02.NODE.JS/02. 模块.html","title":"02. 模块","keywords":"","body":"02. 模块CommonJS规范结论深入了解模块原理module.exports vs exports结论02. 模块 在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。 为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Node环境中，一个.js文件就称之为一个模块（module）。 使用模块有什么好处？ 最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。 使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。 在上一节，我们编写了一个hello.js文件，这个hello.js文件就是一个模块，模块的名字就是文件名（去掉.js后缀），所以hello.js文件就是名为hello的模块。 我们把hello.js改造一下，创建一个函数，这样我们就可以在其他地方调用这个函数： 'use strict'; var s = 'Hello'; function greet(name) { console.log(s + ', ' + name + '!'); } module.exports = greet; 函数greet()是我们在hello模块中定义的，你可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了。 问题是其他模块怎么使用hello模块的这个greet函数呢？我们再编写一个main.js文件，调用hello模块的greet函数： 'use strict'; // 引入hello模块: var greet = require('./hello'); var s = 'Michael'; greet(s); // Hello, Michael! 注意到引入hello模块用Node提供的require函数： var greet = require('./hello'); 引入的模块作为变量保存在greet变量中，那greet变量到底是什么东西？其实变量greet就是在hello.js中我们用module.exports = greet;输出的greet函数。所以，main.js就成功地引用了hello.js模块中定义的greet()函数，接下来就可以直接使用它了。 在使用require()引入模块的时候，请注意模块的相对路径。因为main.js和hello.js位于同一个目录，所以我们用了当前目录.： var greet = require('./hello'); // 不要忘了写相对目录! 如果只写模块名： var greet = require('hello'); 则Node会依次在内置模块、全局模块和当前模块下查找hello.js，你很可能会得到一个错误： module.js throw err; ^ Error: Cannot find module 'hello' at Function.Module._resolveFilename at Function.Module._load ... at Function.Module._load at Function.Module.runMain 遇到这个错误，你要检查： 模块名是否写对了； 模块文件是否存在； 相对路径是否写对了。 CommonJS规范 这种模块加载机制被称为CommonJS规范。在这个规范下，每个.js文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，hello.js和main.js都申明了全局变量var s = 'xxx'，但互不影响。 一个模块想要对外暴露变量（函数也是变量），可以用module.exports = variable;，一个模块要引用其他模块暴露的变量，用var ref = require('module_name');就拿到了引用模块的变量。 结论 要在模块中对外输出变量，用： module.exports = variable; 输出的变量可以是任意对象、函数、数组等等。 要引入其他模块输出的对象，用： jvar foo = require('other_module'); 引入的对象具体是什么，取决于引入模块输出的对象。 深入了解模块原理 如果你想详细地了解CommonJS的模块实现原理，请继续往下阅读。如果不想了解，请直接跳到最后做练习。 当我们编写JavaScript代码时，我们可以申明全局变量： var s = 'global'; 在浏览器中，大量使用全局变量可不好。如果你在a.js中使用了全局变量s，那么，在b.js中也使用全局变量s，将造成冲突，b.js中对s赋值会改变a.js的运行逻辑。 也就是说，JavaScript语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。 那Node.js是如何实现这一点的？ 其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js也并不会增加任何JavaScript语法。实现“模块”功能的奥妙就在于JavaScript是一种函数式编程语言，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。 请注意我们编写的hello.js代码是这样的： var s = 'Hello'; var name = 'world'; console.log(s + ' ' + name + '!'); Node.js加载了hello.js后，它可以把代码包装一下，变成这样执行： (function () { // 读取的hello.js代码: var s = 'Hello'; var name = 'world'; console.log(s + ' ' + name + '!'); // hello.js代码结束 })(); 这样一来，原来的全局变量s现在变成了匿名函数内部的局部变量。如果Node.js继续加载其他模块，这些模块中定义的“全局”变量s也互不干扰。 所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。 但是，模块的输出module.exports怎么实现？ 这个也很容易实现，Node可以先准备一个对象module： // 准备module对象: var module = { id: 'hello', exports: {} }; var load = function (module) { // 读取的hello.js代码: function greet(name) { console.log('Hello, ' + name + '!'); } module.exports = greet; // hello.js代码结束 return module.exports; }; var exported = load(module); // 保存module: save(module, exported); 可见，变量module是Node在加载js文件前准备的一个变量，并将其传入加载函数，我们在hello.js中可以直接使用变量module原因就在于它实际上是函数的一个参数： module.exports = greet; 通过把参数module传递给load()函数，hello.js就顺利地把一个变量传递给了Node执行环境，Node会把module变量保存到某个地方。 由于Node保存了所有导入的module，当我们用require()获取module时，Node找到对应的module，把这个module的exports变量返回，这样，另一个模块就顺利拿到了模块的输出： var greet = require('./hello'); 以上是Node实现JavaScript模块的一个简单的原理介绍。 module.exports vs exports 很多时候，你会看到，在Node环境中，有两种方法可以在一个模块中输出变量： 方法一：对module.exports赋值： // hello.js function hello() { console.log('Hello, world!'); } function greet(name) { console.log('Hello, ' + name + '!'); } module.exports = { hello: hello, greet: greet }; 方法二：直接使用exports： // hello.js function hello() { console.log('Hello, world!'); } function greet(name) { console.log('Hello, ' + name + '!'); } function hello() { console.log('Hello, world!'); } exports.hello = hello; exports.greet = greet; 但是你不可以直接对exports赋值： // 代码可以执行，但是模块并没有输出任何变量: exports = { hello: hello, greet: greet }; 如果你对上面的写法感到十分困惑，不要着急，我们来分析Node的加载机制： 首先，Node会把整个待加载的hello.js文件放入一个包装函数load中执行。在执行这个load()函数前，Node准备好了module变量： var module = { id: 'hello', exports: {} }; load()函数最终返回module.exports： var load = function (exports, module) { // hello.js的文件内容 ... // load函数返回: return module.exports; }; var exported = load(module.exports, module); 也就是说，默认情况下，Node准备的exports变量和module.exports变量实际上是同一个变量，并且初始化为空对象{}，于是，我们可以写： exports.foo = function () { return 'foo'; }; exports.bar = function () { return 'bar'; }; 也可以写： module.exports.foo = function () { return 'foo'; }; module.exports.bar = function () { return 'bar'; }; 换句话说，Node默认给你准备了一个空对象{}，这样你可以直接往里面加东西。 但是，如果我们要输出的是一个函数或数组，那么，只能给module.exports赋值： module.exports = function () { return 'foo'; }; 给exports赋值是无效的，因为赋值后，module.exports仍然是空对象{}。 结论 如果要输出一个键值对象{}，可以利用exports这个已存在的空对象{}，并继续在上面添加新的键值； 如果要输出一个函数或数组，必须直接对module.exports对象赋值。 所以我们可以得出结论：直接对module.exports赋值，可以应对任何情况： module.exports = { foo: function () { return 'foo'; } }; 或者： module.exports = function () { return 'foo'; }; 最终，我们强烈建议使用module.exports = xxx的方式来输出模块变量，这样，你只需要记忆一种方法。 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/03.Echarts/":{"url":"roccoshi_note/07-前端学习/03.Echarts/","title":"03.Echarts","keywords":"","body":" Echarts -- 数据可视化 视频学习地址 : https://www.bilibili.com/video/BV1v7411R7mp 技术栈 : flexible.js + rem 大屏适配 VScode cssrem插件 Flex 布局 Less 使用 基于ECharts数据可视化展示 ECharts柱状图数据设置 ECharts地图引入 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/03.Echarts/01. 可视化适配方案.html":{"url":"roccoshi_note/07-前端学习/03.Echarts/01. 可视化适配方案.html","title":"01. 可视化适配方案","keywords":"","body":"01. 可视化适配方案1 | 文件结构和相关插件文件结构插件配置01. 可视化适配方案 1 | 文件结构和相关插件 文件结构 ├───css ├───font ├───images └───js └───index.html 插件配置 cssrem -> 完成rem和px的相互转换 rem : Easy LESS -> .less文件保存自动生成.css文件 Less 是一门CSS 预处理语言，它扩展了CSS 语言，增加了变量、Mixin、函数等特性，使CSS 更易维护和扩展。 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/03.Echarts/02. 头部制作.html":{"url":"roccoshi_note/07-前端学习/03.Echarts/02. 头部制作.html","title":"02. 头部制作","keywords":"","body":"02. 头部制作关于时间的格式化02. 头部制作 关于时间的格式化 var t = null; t = setTimeout(time, 1000); function time() { clearTimeout(t); var nowDate = new Date(); document.querySelector(\".showTime\").innerHTML = 'Time : ' + format(nowDate,'-'); function format(Date,str){ var obj = { Y: Date.getFullYear(), M: Date.getMonth() + 1, D: Date.getDate(), H: Date.getHours(), Mi: Date.getMinutes(), S: Date.getSeconds() } // 拼接时间 hh:mm:ss var time = ' ' +supplement(obj.H) + ':' + supplement(obj.Mi) + ':' + supplement(obj.S); // yyyy-mm-dd if(str.indexOf('-') > -1){ return obj.Y + '-' + supplement(obj.M) + '-' + supplement(obj.D) + time; } // yyyy/mm/dd if(str.indexOf('/') > -1){ return obj.Y + '/' + supplement(obj.M) + '/' + supplement(obj.D) + time; } } // 位数不足两位补全0 function supplement(nn){ return nn = nn 格式化成yyyy-MM-dd hh:mm:ss 设定每秒刷新一次达到动态显示的效果 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/03.Echarts/03. 主体制作.html":{"url":"roccoshi_note/07-前端学习/03.Echarts/03. 主体制作.html","title":"03. 主体制作","keywords":"","body":"03. 主体制作1 | 给矩形框添加四个边角 -- 使用伪元素关于伪元素2 | bar - 柱形图的绘制03. 主体制作 1 | 给矩形框添加四个边角 -- 使用伪元素 关于这四个脚的写法 html部分 : css部分 : (less) .panel { position: relative; height: 3.875rem; padding: 0 0.1875rem 0.5rem; border: 1px solid rgba(25, 185, 139, 0.17); background: url(../images/line.png) rgba(255, 255, 255, 0.03); margin-bottom: 0.1875rem; &::before { // 伪元素添加折角边框 -- 左上方 position: absolute; top: 0; left: 0; width: 10px; height: 10px; border-left: 2px solid #02a6b5; border-top: 2px solid #02a6b5; content:\"\" } &::after { // 伪元素添加折角边框 -- 右上方 position: absolute; top: 0; right: 0; width: 10px; height: 10px; border-right: 2px solid #02a6b5; border-top: 2px solid #02a6b5; content:\"\" } .panel-footer { &::before { // 伪元素添加折角边框 -- 左下方 position: absolute; bottom: 0; left: 0; width: 10px; height: 10px; border-left: 2px solid #02a6b5; border-bottom: 2px solid #02a6b5; content:\"\" } &::after { // 伪元素添加折角边框 -- 右下方 position: absolute; bottom: 0; right: 0; width: 10px; height: 10px; border-right: 2px solid #02a6b5; border-bottom: 2px solid #02a6b5; content:\"\" } } } 关于伪元素 补充 : CSS伪元素是用来添加一些选择器的特殊效果。 所有CSS的伪元素 选择器 示例 示例说明 :link a:link 选择所有未访问链接 :visited a:visited 选择所有访问过的链接 :active a:active 选择正在活动链接 :hover a:hover 把鼠标放在链接上的状态 :focus input:focus 选择元素输入后具有焦点 :first-letter p:first-letter 选择每个 元素的第一个字母 :first-line p:first-line 选择每个 元素的第一行 :first-child p:first-child 选择器匹配属于任意元素的第一个子元素的 元素 :before p:before 在每个元素之前插入内容 :after p:after 在每个元素之后插入内容 :lang(language) p:lang(it) 为元素的lang属性选择一个开始值 2 | bar - 柱形图的绘制 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/03.Echarts/04. Echarts简介.html":{"url":"roccoshi_note/07-前端学习/03.Echarts/04. Echarts简介.html","title":"04. Echarts简介","keywords":"","body":"04. ECharts简介1 | 常见的数据可视化库2 | ECharts上手3 | Echarts基础配置04. ECharts简介 1 | 常见的数据可视化库 D3.js ( 评价最高, 入手难 ) Echarts.js ( 百度 ) Highcharts.js ( 国外 ) AntV Hightcharts和Echarts就像是Office和WPS的关系 2 | ECharts上手 使用步骤 : 下载和引入echarts.js文件 准备一个具备大小的dom容器 初始化echarts实例对象 var myChart = echarts.init(document.querySelector(\".box\")); 指定配置项和相关数据 var option = xxxx 将配置项设置给echarts实例对象 myChart.setOption(option); // 初始化echarts实例对象 var myChart = echarts.init(document.querySelector(\".box\")); // 指定配置项和相关数据 var option = { title: { text: 'echarts init' }, tooltip: {}, legend: { data:['sales'] }, xAxis: { data: ['shirt', 'wether', 'jeans', 'socks'] }, yAxis: {}, series: [ { name: 'sales', type: 'bar', data: [5, 20 ,36, 10] } ] }; // 将配置项设置给echarts实例对象 myChart.setOption(option); 3 | Echarts基础配置 配置项手册 : https://echarts.apache.org/zh/option.html 名称 作用 title 标题组件 series 系列图表的具体信息 grid 直角坐标系绘图网格相关配置, 可以控制图表大小等 xAxis x轴信息 yAxis y轴信息 tooltip 提示框组件 ( 鼠标放上去的提示信息 ) legend 图例组件 ( 如果series里面写了name, 则legend可以不用写) toolbox 工具箱组件 ( 另存为图片等功能 ) color 修改颜色 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/03.Echarts/05. 图表的绘制.html":{"url":"roccoshi_note/07-前端学习/03.Echarts/05. 图表的绘制.html","title":"05. 图表的绘制","keywords":"","body":"05. 图表的绘制1 | 利用立即执行函数防止变量污染2 | 让图标跟随屏幕自适应3 | 实现点击切换数据内容05. 图表的绘制 1 | 利用立即执行函数防止变量污染 分析需求可知我们一共需要绘制6个echarts, 但是每个echarts中都有option之类的变量, 我们不希望使用option1, option2之类的命名, 可以采用立即执行函数来防止变量的污染问题 立即执行函数的格式 : (function() {})(); 2 | 让图标跟随屏幕自适应 window.addEventListener('resize', function() { myChart.resize(); }); 3 | 实现点击切换数据内容 html部分 Bar-Employment 2019 2020 css部分 .mainbox .panel h2 a { margin-left: 5%; position: absolute; color: rgba(255, 255, 255, 0.671); font-size: 0.125rem; } .mainbox .panel h2 #a1 { margin-top: -2.5%; } .mainbox .panel h2 #a2 { margin-top: 2.5%; } js部分 // 实现数据的切换效果 var yearData = [{ \"year\": 2019, data: [ [24, 40, 101, 134, 90, 230, 210, 230, 120, 230, 210, 120], [24, 40, 101, 134, 90, 230, 210, 230, 102, 71, 210, 120], ], }, { \"year\": 2020, data: [ [40, 64, 191, 324, 290, 330, 310, 213, 180, 200, 180, 79], [99, 12, 111, 134, 90, 421, 310, 230, 212, 011, 210, 120], ] }, ]; $(\".line h2\").on(\"click\", \"a\", function () { console.log('点击'); let obj = yearData[$(this).index()]; // index指向a标签的index, 第一个a标签index为0, 第二个为1 option.series[0].data = obj.data[0]; option.series[1].data = obj.data[1]; myChart.setOption(option); // 刷新 }) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/04.VUE/":{"url":"roccoshi_note/07-前端学习/04.VUE/","title":"04.VUE","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/04.VUE/01. 基础语法.html":{"url":"roccoshi_note/07-前端学习/04.VUE/01. 基础语法.html","title":"01. 基础语法","keywords":"","body":"01. 基础语法v-text v-html v-onv-show01. 基础语法 v-text v-html v-on {{ message }} var app = new Vue( { el: \"#app\", data: { message: \"hello world\", info: \"你好,VUE\", script:\"THIS IS A SCRIPT\", }, methods: { doit:function(){ alert(this.info); } }, }) v-show Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/05.webpack/":{"url":"roccoshi_note/07-前端学习/05.webpack/","title":"05.webpack","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/05.webpack/01.webpack简介.html":{"url":"roccoshi_note/07-前端学习/05.webpack/01.webpack简介.html","title":"01.webpack简介","keywords":"","body":"01. webpack简介1 | 什么是webpack2 |01. webpack简介 1 | 什么是webpack webpack可以看作是模块打包机 作用 : 分析项目结构, 找到JavaScript模块以及其他的一些浏览器不能直接运行的扩展语言 ( Scss, TypeScript等 ), 并将其打包为合适的格式以供浏览器使用. 代码转换, 文件优化, 代码分割, 模块合并, 自动刷新, 代码校验, 自动发布 2 | Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/06.基础css复习/":{"url":"roccoshi_note/07-前端学习/06.基础css复习/","title":"06.基础css复习","keywords":"","body":"css的引入方式css的三大特性 不全, 仅记录以前用的不熟的 css的引入方式 种类 引入方式 内部样式表 中标签 外部样式表 行内样式表 css的三大特性 层叠性, 继承性, 优先级 层叠性 : “就近原则” 继承性 : 子元素会继承父元素的属性 关于行高的继承 : body { font: 12px/1.5 Microsoft YaHei; /* 表示12px字体大小, 1.5em的行高 子元素会根据自己的文字大小自动调整行高 */ } 优先级 低 -> 高 选择器 权重 继承 / * 0000 元素选择器 0001 类/伪类选择器 0010 ID选择器 0100 行内样式style 1000 !important ∞ !important div { color: red!important; } Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/06.基础css复习/01. 基本属性.html":{"url":"roccoshi_note/07-前端学习/06.基础css复习/01. 基本属性.html","title":"01. 基本属性","keywords":"","body":"01. 基本属性文本属性text背景background背景混合写法01. 基本属性 文本属性text 装饰文本: text-decoration : line-through (删除线) | none (取消下划线) | underline(下划线) 文本缩进: text-indent px(像素) | em(相对大小, 基准为一个文字) 行间距: line-height ( 上一行最下沿到本行最下沿的高度就是行高 = 上空隙 + 文字高 + 下空隙 ) 背景background 背景颜色: background-color : transparent(透明) | color | rgb(x,x,x) | rgba(x,x,x,.x) ( 可以设置透明度) 背景图片: background-image : none | url(url) 背景图片平铺: background-repeat : repeat | no-repeat | repeat-x | repeat-y 背景图片位置: background-position : x(水平) y(垂直) 注意 : 如果参数是方位名词 ( right, top, left, bottom, center ) , 则与位置无关 如果指定两个数值, 那么第一个是x值 ( 距左侧 ) , 第二个是y值 ( 距顶部 ) 如果指定一个数值, 那么就是x值, y值为垂直居中 背景图像固定 background-attachment : scroll(滚动) | fixed(固定) 背景混合写法 在背景混合写法中对位置没有强制要求, 一般顺序为: background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置 ( 开发中常用 ) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/06.基础css复习/02. 复合选择器.html":{"url":"roccoshi_note/07-前端学习/06.基础css复习/02. 复合选择器.html","title":"02. 复合选择器","keywords":"","body":"02. 复合选择器1 | 后代选择器2 | 子选择器3 | 并集选择器4 | 伪类选择器4.1 | 链接伪类选择器4.2 | focus伪类选择器02. 复合选择器 1 | 后代选择器 作用 : 选择父元素中的子元素 语法 : 父元素1 子元素2 {} e.g. ol li {} ps : 元素2不一定要是1的亲儿子, 可以是子孙 2 | 子选择器 作用 : 选择父元素中的亲儿子 语法 : 父元素1 > 子元素2 {} e.g. div > p {} 3 | 并集选择器 作用 : 选择多组(没有关系的)标签, 同时定义样式 语法 : 元素1, 元素2 {} e.g. div, p {} -> 同时选择元素div和p 4 | 伪类选择器 作用 : 向某些选择器添加特殊的效果, 比如给链接添加特殊效果, 或者选择第一个, 第n个元素 4.1 | 链接伪类选择器 名字 作用 a:link 选择所有未被访问的链接 a:visited 选择所有已被访问的链接 a:hover 选择鼠标指针位于其上的链接 a:active 选择活动链接 ( 鼠标按下未弹起的链接 ) 注意 : 链接伪类需要按顺序写, LVHA ( link->visited->hover->active ), 不然可能会不生效 链接是特殊元素, 修改body样式不会改变a的样式 开发中一般写 a {} 和 a:hover {} 即可 4.2 | focus伪类选择器 :focus 伪类选择器用于获得焦点的表单元素 焦点就是光标, 一般情况下 表单元素才能获取, 因此这个选择器也主要针对于表单元素来说. 最常用 : input:focus input:focus Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/06.基础css复习/03. 元素的显示模式.html":{"url":"roccoshi_note/07-前端学习/06.基础css复习/03. 元素的显示模式.html","title":"03. 元素的显示模式","keywords":"","body":"03. css元素的显示模式1 | 块元素2 | 行内元素3 | 行内块元素4 | 元素显示模式的转换4.1 | 把行内元素转换为块级元素4.2 | 把块级元素转换为行内元素4.3 | 转换为行内块元素5 | 如何让单行文字垂直居中03. css元素的显示模式 1 | 块元素 常见的块元素 : h1 - h6, p, div, ul, ol, li等 块元素的特点 : 独占一行 高度, 宽度, 内外边距可以控制 宽度默认是容器 ( 父亲 )宽度的100% 是一个容器及盒子, 里面可以放行内或者块级元素 ( p, h1-h6等文字类块标签不能放块级元素 ) 2 | 行内元素 常见的行内元素 : a, strong, b, em, i, del, s, ins, u, span等 行内元素的特点 : 相邻行内元素在一行上, 一行可以显示多个 高, 宽度直接设置无效 默认宽度就是它本身内容的宽度 行内元素只能容纳文本或者其他行内元素 a是一个特殊的行内元素, 里面可以包含块级元素, 但a里面不能再放a 3 | 行内块元素 在行内元素中有几个特殊的标签 img, input, td 他们同时具有行内元素和块元素的特点 行内块元素的特点 : 和相邻行内元素和行内块元素在一行上, 但是它们之间会有空白缝隙, 一行可以显示多个 默认宽度就是它本身内容的宽度 ( 行内元素特点 ) 高度, 宽度, 内外边距可以控制 ( 块元素特点 ) 4 | 元素显示模式的转换 display 4.1 | 把行内元素转换为块级元素 a { width: 100px; height: 100px; display: block; /* 把行内元素a转换为块级元素, 可以设置width, height */ } 4.2 | 把块级元素转换为行内元素 div { display: inline; /* 转换为行内元素 */ } 4.3 | 转换为行内块元素 div { display: inline-block; /* 转换为行内块元素 */ } 5 | 如何让单行文字垂直居中 让line-height和容器的高度height相等即可 e.g. a { display: block; height: 40px; line-height: 40px; } Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/06.基础css复习/04. 盒子模型.html":{"url":"roccoshi_note/07-前端学习/06.基础css复习/04. 盒子模型.html","title":"04. 盒子模型","keywords":"","body":"04. 盒子模型1 | 边框2 | 内外边距外边距内边距水平居中效果3 | 圆角边框, 盒子阴影, 文字阴影圆角边框 : border-radius: length盒子阴影: box-shadow文字阴影 : text-shadow04. 盒子模型 1 | 边框 属性 作用 border-width 边框的粗细 border-style 边框的样式 border-color 边框的颜色 2 | 内外边距 外边距 外边距 : margin ( 上下, 左右 margin: 0 auto->实现居中 (上下0 左右auto) ) 内边距 内边距 : padding 复合属性 ( 上, 右, 下, 左 -> 即顺时针 ) 水平居中效果 实现行内元素和行内块元素的水平居中 : 给父元素添加text-align: center 3 | 圆角边框, 盒子阴影, 文字阴影 css3新增 圆角边框 : border-radius: length border-radius 盒子阴影: box-shadow box-shadow: h-shadow v-shadow blur spread color inset 值 描述 h-shadow 水平阴影 v-shadow 垂直阴影 blur 模糊距离 spread 阴影尺寸 color 阴影颜色 inset 将外部阴影 -> 内部阴影 阴影是不占用空间的 文字阴影 : text-shadow text-shadow : h-shadow v-shadow blur color Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/06.基础css复习/05. CSS浮动.html":{"url":"roccoshi_note/07-前端学习/06.基础css复习/05. CSS浮动.html","title":"05. CSS浮动","keywords":"","body":"05. CSS浮动1 | 浮动特性1-1 | 浮动元素会脱离标准流 ( 脱标 )1-2 | 浮动元素会具有行内块元素的特性1-3 | 浮动不会压住文字和图片2 | 浮动元素搭配标准流父级使用3 | 浮动布局的实现4 | 清除浮动的方法4-1 | 额外标签法4-2 | 父级添加overflow4-3 | :after伪元素4.4 | 双伪元素清除浮动05. CSS浮动 网页布局第一准则 : 多个块级元素纵向排列找标准流, 多个块级元素横向排列找浮动 ( float ) 1 | 浮动特性 1-1 | 浮动元素会脱离标准流 ( 脱标 ) 浮动的盒子不再保留原先的位置 浮动的盒子会压住标准流的盒子 1-2 | 浮动元素会具有行内块元素的特性 任何元素都可以浮动, 不管原先是什么模式的元素, 添加浮动之后都具有行内块元素相似的特性 如果块级盒子没有设置宽度, 默认宽度和父级元素一样宽, 但是添加浮动后, 它的大小根据内容来决定 浮动的盒子中间是没有缝隙的, 是紧挨在一起的 1-3 | 浮动不会压住文字和图片 浮动会压住下面标准流的盒子, 但是不会压住下面标准流盒子里面的文字和图片. 2 | 浮动元素搭配标准流父级使用 为了约束浮动元素的位置, 我们网页布局一般采取的策略是 : 先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置, 符合网页布局第一准则 ps : 浮动只会影响之后的标准流, 不会影响前面的标准流 3 | 浮动布局的实现 代码 Float * { margin: 0; padding: 0; } .top { height: 50px; background-color: gray; } .banner { width: 980px; height: 150px; background-color: gray; margin: 10px auto; } .box { width: 980px; height: 300px; background-color: pink; margin: 0 auto; } .box li { float: left; width: 237px; height: 300px; list-style: none; margin-right: 10px; background-color: gray; } .box li:nth-child(4) { margin-right: 0; } .footer { height: 200px; background-color: gray; margin-top: 10px; } 1 2 3 4 效果 : 4 | 清除浮动的方法 4-1 | 额外标签法 在最后一个子元素后添加一个块级元素, 并给与clear:both的css属性 4-2 | 父级添加overflow 父级添加overflow:hidden 4-3 | :after伪元素 .clearfix:after { content: \"\"; display: block; height: 0; clear: both; visibility: hidden; } .clearfix { /* 照顾ie6, 7 */ *zoom: 1; } 之后在需要清楚浮动的元素添加clearfix类名即可 4.4 | 双伪元素清除浮动 .clearfix:before, .clearfix:after { content: \"\"; display: none; } .clearfix:after { clear: both; } .clearfix { /* 照顾ie6, 7 */ *zoom: 1; } Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/06.基础css复习/06. 一些图片操作.html":{"url":"roccoshi_note/07-前端学习/06.基础css复习/06. 一些图片操作.html","title":"06. 一些图片操作","keywords":"","body":"06. 一些图片操作1 | 常见的图片格式2 | ps切图工具 -- cutterman06. 一些图片操作 1 | 常见的图片格式 图像格式 说明 jpg \\ jpeg 对色彩的信息保留好, 高清, 颜色较多 ( 产品类的图片 ) gif 最多只能存储256色, 通常用来显示简单图形以及字体, 但是可以保存透明背景和动画效果 png 网络图形格式, 结合了gif和jpeg的优点, 具有存储形式丰富的特点, 能够保持透明背景 psd photoshop的专用格式, 里面可以存放图层, 通道, 遮罩等多种设计稿 2 | ps切图工具 -- cutterman Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/06.基础css复习/07. css定位.html":{"url":"roccoshi_note/07-前端学习/06.基础css复习/07. css定位.html","title":"07. css定位","keywords":"","body":"07. css定位1 | 定位模式2 | 边偏移3 | 静态定位4 | 相对定位 ( 常用 )5 | 绝对定位 ( 常用 )6 | 「子绝父相」 ( 重要 )7 | 固定定位 fixed例子: 固定在版心右侧位置8 | 定位的叠放顺序 z-index07. css定位 定位 = 定位模式 + 边偏移 1 | 定位模式 定位模式决定元素的定位方式, 通过css的position属性来设置 值 含义 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 sticky 粘性定位 2 | 边偏移 边偏移就是定位的盒子移动到最终位置, 有top, bottom, left和right 4个属性 表示和父元素边线之间的距离 3 | 静态定位 position: static 静态定位按照标准流特性摆放位置, 它没有边偏移 静态定位在布局时很少使用 4 | 相对定位 ( 常用 ) position: relative 相对定位是在元素移动位置的时候, 是相对它原来的位置来说的 原来在标准流的位置继续占有, 后面的盒子仍然以标准流的方式对待他 ( 不脱标, 继续保留原来的位置 ) 相对定位最典型的应用: 用于控制绝对定位 5 | 绝对定位 ( 常用 ) position: absolute 绝对定位是元素在移动位置的时候, 相对于祖先元素来说的 绝对定位的特点 : 如果没有祖先元素或者祖先元素没有定位, 则以浏览器为准进行对齐 如果祖先元素有定位 ( 相对, 绝对, 固定定位 ), 则以最近一级的有定位祖先元素为参考点移动位置. 绝对定位不再占有原来的位置. ( 脱标 ) 6 | 「子绝父相」 ( 重要 ) 子绝父相 : 子级绝对定位, 父亲相对定位 子绝父相是定位中最常用的一种方式 子级绝对定位, 不会占有位置, 可以放到父盒子里面的任何一个地方, 不会影响其他的兄弟盒子 父盒子需要加定位限制子盒子在父盒子内显示 父盒子布局时, 需要占有位置, 因此父亲只能是相对定位 7 | 固定定位 fixed 固定定位是元素固定于浏览器可视区的位置, 主要使用场景 : 可以使浏览器页面滚动时元素的位置不会改变. 固定定位的特点 : 以浏览器的可视窗口为参照点移动元素 跟父元素没有任何关系 不随滚动条滚动 例子: 固定在版心右侧位置 让固定定位的盒子left: 50%, 走到浏览器可视区 ( 也可以看作版心 )的一半位置. 让固定定位的盒子margin-left: 版心宽度一半的距离, 多走版心宽度一半位置. 8 | 定位的叠放顺序 z-index 在使用定位布局的时候, 可能会出现盒子重叠的情况, 这时可以使用z-index来决定元素的叠放次序 z-index的数值可以是正整数, 负整数或0, 默认是auto, 数值越大, 盒子越靠上 如果属性值相同, 则按照书写顺序, 后来居上 数字后面不能加单位 只有定位的盒子才有z-index属性, 标准流和浮动都没有 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/06.基础css复习/08. css其他技巧.html":{"url":"roccoshi_note/07-前端学习/06.基础css复习/08. css其他技巧.html","title":"08. css其他技巧","keywords":"","body":"08. css其他技巧1 | 精灵图1-1 | 精灵图sprites的使用2 | 字体图标 iconfont2-1 | 字体图标的使用3 | CSS用户界面样式3-1 | 鼠标样式cursor3-2 | 禁止文本域(textarea)拖拽3-3 | 取消表单轮廓4 | css初始化08. css其他技巧 1 | 精灵图 一个网页中往往会应用很多小的背景图像进行修饰, 当网页中的图像过多时, 服务器就会频繁地接收的发送请求图片, 造成服务器请求压力过大, 这将大大降低页面的加载速度. 为了有效地减少服务器接受和发送请求的次数, 提高页面的加载速度, 出现了css精灵技术 ( 也成为 css Sprites ) 核心原理 : 将很多小图片整合成一张大图片中, 这样浏览器只需要请求一次就可以了. 1-1 | 精灵图sprites的使用 移动背景图片的位置, 主要使用background-position 因为一般情况下都是往上或者往左移动, 所以数值是负值 使用精灵图的时候要精确测量每个小背景图片的大小和位置 2 | 字体图标 iconfont 字体图标展示的是图标, 但是本质是字体 ( 文字 ) 优点 : 轻量 : 字体加载后图标马上渲染, 减小了服务器的请求 灵活 : 本质是文字, 可以随意的改变颜色, 产生阴影和透明效果等 兼容 : 几乎支持所有的浏览器 2-1 | 字体图标的使用 下载网站 : icomoon字体库 : (http://icomoon.io) 阿里iconfont字体库 : (http://www.iconfont.cn/) 3 | CSS用户界面样式 3-1 | 鼠标样式cursor 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状 属性值 描述 default 箭头 pointer 手形 move 十字架移动状态 text 文本 not-allowed 禁止 3-2 | 禁止文本域(textarea)拖拽 textarea { resize: none; } 3-3 | 取消表单轮廓 input, textarea { outline: none; } 4 | css初始化 不同浏览器对有些标签的默认值是不同的, 为了消除不同浏览器对html文本呈现的差异, 照顾浏览器的兼容性 css初始化是指重设浏览器的样式 ( 也称为css reset ) 每个网页都必须首先进行css初始化 mark P275 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/06.基础css复习/09. html5和css3新特性.html":{"url":"roccoshi_note/07-前端学习/06.基础css复习/09. html5和css3新特性.html","title":"09. html5和css3新特性","keywords":"","body":"HTML5和css3新特性1 | HTML5新增的语义化标签2 | HTML5新增的多媒体标签3 | HTML5新增的input类型4 | HTML5新增的表单属性5 | css3的新增选择器5-1 | 属性选择器5-2 | 结构伪类选择器5-3 | 伪元素选择器6 | css3盒子模型7 | css其他特性7-1 | css3滤镜filter ( 让图片变模糊 )7-2 | calc函数7-3 | css3过渡 ( 制作动画 ) 「常用,重点」HTML5和css3新特性 html5的新增特性主要是针对于以前的不足, 增加了一些新的标签, 新的表单和新的表单属性等 1 | HTML5新增的语义化标签 在以前的布局中, 我们基本用div来做, 但是div对搜索引擎来说是没有语义的 在html5中新增了如下的语义化标签 : 标签 介绍 header 头部标签 nav 导航标签 article 内容标签 section 定义文档的某个区域 aside 侧边栏标签 footer 尾部标签 这些语义化标签主要是针对搜索引擎的爬虫的 2 | HTML5新增的多媒体标签 新增的多媒体标签主要包含两个 视频 : 支持三种视频格式 mp4, WebM, ogg ( 尽量使用mp4格式 ) 使用方法 : vedio的常用属性 : vedio常用属性 音频 使用方法 : (src尽量选用mp3格式) 常见的音频属性 3 | HTML5新增的input类型 新增的input类型 4 | HTML5新增的表单属性 HTML5新增的表单属性 5 | css3的新增选择器 5-1 | 属性选择器 属性选择器可以根据元素特定属性来选择元素 用法 : (例如选择含有value属性的input标签) // css选择input标签 input[value] { xxxxxx } 其他用法 : css3属性选择器 input[att=\"val\"] 为最常用的用法 5-2 | 结构伪类选择器 结构伪类选择器主要根据文档结构来选择元素, 常用于根据父级选择器里面的子元素 结构伪类选择器 nth-child(n)选择某个父元素的一个或多个特定的子元素 n可以是数字, 关键字和公式 n如果是数字, 就是选择第n个子元素 ( 从1开始 ) n可以是关键字 : even表示偶数, odd表示奇数 n可以是公式, 常见的公式如下 : nth-child和nth-of-type的区别 : nth-child会把所有的盒子都排列序号, 而nth-of-type只会把指定的盒子排列序号. 5-3 | 伪元素选择器 伪元素选择器可以帮助我们利用css创建新标签伪元素, 而不需要HTML标签, 从而简化HTML结构 选择符 简介 ::before 在元素内部的前面插入内容 ::after 在元素内部的后面插入内容 注意 : before和after创建一个元素, 但是属于行内元素 新创建的元素在文档树中无法找到, 所以称为伪元素 before和after必须有content属性 伪元素选择器和标签选择器的权重一样, 都为1 6 | css3盒子模型 css中可以通过box-sizing来指定盒子模型, 有两个值, 可以指定为 content-box, border-box 这样我们计算盒子大小的方式就发生了改变 可以分成两种情况 : box-sizing: content-box盒子大小为width + padding + border (以前默认的) box-sizing: border-box盒子大小为width ( 这样padding和border就不会撑大盒子了, 前提是padding和border不会超过width的宽度 ) 7 | css其他特性 7-1 | css3滤镜filter ( 让图片变模糊 ) 语法格式 : filter: function() 其中function代表一个函数 例如: filter: blur(5px);做模糊处理, 5px部分越大图片越模糊 7-2 | calc函数 例如 : 将子盒子的width改为 -> calc(100%-30px)可以让子盒子永远比父盒子小30像素 7-3 | css3过渡 ( 制作动画 ) 「常用,重点」 过渡是css3中的特性之一, 我们可以在不适用flash动画或者javascript的情况下, 当元素从一种样式变化为另一种样式时为元素添加效果. ( 常常与:hover搭配使用 ) transition: 要过渡的属性 花费时间 运动曲线 何时开始 属性 : 想要变化的css属性, ( 宽度高度, 背景颜色, 内外边距 ), 如果想要所有的属性都变化过渡, 则添加all 花费时间 : 单位是s, e.g. 0.5s 运动曲线 : 默认是ease 何时开始 : 单位是s, 可以设置延迟触发时间 ( 默认是0s ) 过渡的使用: 「谁过渡给谁加」 例子 : div { width: 200px; height: 100px; background-color: pink; transition: width .5s; } div:hover { width: 400px; } /* 效果: 这个div盒子会在鼠标放上去的时候在0.5s内宽度(width)渐渐由200px-->400px */ Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/06.基础css复习/10. 移动端开发入门.html":{"url":"roccoshi_note/07-前端学习/06.基础css复习/10. 移动端开发入门.html","title":"10. 移动端开发入门","keywords":"","body":"10. 移动端开发入门1 | 视口viewport1-1 | 视口的分类1-2 | meta视口标签2 | 二倍图2-1 | 物理像素 & 物理像素比2-2 | 背景缩放background-size3 | 移动端的开发选择3-1 | 移动端的主流方案3-2 | css初始化3-3 | 移动端技术选型10. 移动端开发入门 兼容移动端主流浏览器, 处理webkit内核即可, 大多数浏览器都是基于webkit内核开发的 1 | 视口viewport 视口 ( viewport ) 是浏览器显示页面内容的屏幕区域 1-1 | 视口的分类 布局视口layout viewport 一般的移动设备的浏览器都默认设置了一个布局视口, 用于解决早期的PC端页面在手机上显示的问题 ios, android基本都将这个视口分辨率设置为980px, 所以pc上的网页大多都能在手机上呈现, 只不过元素看上去很小, 一般默认可以通过手动缩放网页 并不合适, 因为分辨率设定为980px后字太小 视觉视口 visual port 视觉视口表示用户正在看到的网站的区域 我们可以通过缩放去操作视觉视口, 但是不会影响布局视口, 布局视口仍旧保持原来的宽度 理想视口ideal viewport 为了使网站有最理想的浏览和阅读宽度而设定 理想视口对设备来讲是最理想的视口尺寸 需要手动填写meta视口标签通知浏览器操作 meta视口标签的主要目的 : 布局视口的宽度应该与理想视口的宽度一致, 简单理解就是设备有多宽, 布局视口就有多宽 1-2 | meta视口标签 2 | 二倍图 2-1 | 物理像素 & 物理像素比 在电脑中, px和物理像素是一一对应的关系, 而在移动端, px和物理像素不是一一对应的关系 一个px能显示的物理像素点的个数, 称为物理像素比 比如在ipone8中, 物理像素比为2, 即100x100的图片放到iphone8中会变成200x200 故我们准备的图片就需要比实际需要的大小大2倍, 这就是二倍图 2-2 | 背景缩放background-size background-size: 宽度 高度规定背景图像的尺寸 如果只写一个参数, 则为指定宽度, 高度为等比例缩放 单位: 长度 | 百分比 | cover | contain cover把背景图像扩展至足够大, 完全覆盖div盒子, 可能有部分背景图片显示不全 contain将图像扩展至最大尺寸, 使得高度和宽度完全适应盒子尺寸 ( 等比缩放, 宽度或者高度到盒子宽/高度就不再缩放 ) 3 | 移动端的开发选择 3-1 | 移动端的主流方案 单独制作移动端页面 响应式页面兼容移动端 ( 需要不断调整, 比较麻烦 ) 3-2 | css初始化 移动端css初始化推荐使用 : normalize.css/ 官网地址 : http://necolas.github.io/normalize.css/ 3-3 | 移动端技术选型 单独制作移动端页面 ( 主流 ) 流式布局 ( 百分比布局 ) --> 不适用固定的像素而使用百分比 flex弹性布局 less + rem + 媒体查询布局 混合布局 响应式页面兼容移动端 媒体查询 bootstrap Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/07-前端学习/Emmet语法.html":{"url":"roccoshi_note/07-前端学习/Emmet语法.html","title":"Emmet语法","keywords":"","body":"Emmet语法Emmet语法 Emmet语法使用缩写提高html/css的编写速度, vscode内部已经集成 emmet语法速查 : https://docs.emmet.io/cheat-sheet/ 本地 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/08-Flask学习/":{"url":"roccoshi_note/08-Flask学习/","title":"08-Flask学习","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/08-Flask学习/01.pipenv环境搭建.html":{"url":"roccoshi_note/08-Flask学习/01.pipenv环境搭建.html","title":"01.pipenv环境搭建","keywords":"","body":"01.pipenv环境搭建一. 解决pipenv install报错的问题二. pipenv的介绍和简单使用基本命令更换虚拟环境的路径两个文件Pipfile和Pipfile.lock换源pycharm设置解释器为虚拟环境解释器01.pipenv环境搭建 一. 解决pipenv install报错的问题 pipenv install raise ValueError(\"Not a valid python path: %r\" % path) ValueError: Not a valid python path: 'C:/Python27/Scripts/python.exe' 解决方法 : 按照提示安装python2到对应目录... ( 没有找到其他解决方法 ) 进入https://www.python.org/downloads/release/python-2718/下载对应的python.exe到提示的`'C:/Python27/Scripts/python.exe'`目录下 然后执行pipenv install,发现成功了 E:\\projects\\Env-Flask>pipenv install Creating a virtualenv for this project… Pipfile: E:\\projects\\Env-Flask\\Pipfile Using C:/Python38/python.exe (3.8.3) to create virtualenv… [ =] Creating virtual environment...created virtual environment CPython3.8.3.final.0-64 in 2717ms creator CPython3Windows(dest=C:\\Users\\47461\\.virtualenvs\\Env-Flask-TxTdDa0v, clear=False, global=False) seeder FromAppData(download=False, pip=bundle, setuptools=bundle, wheel=bundle, via=copy, app_data_dir=C:\\Users\\47461\\AppData\\Local\\pypa\\virtualenv) added seed packages: pip==20.2.2, setuptools==49.6.0, wheel==0.35.1 activators BashActivator,BatchActivator,FishActivator,PowerShellActivator,PythonActivator,XonshActivator Successfully created virtual environment! Virtualenv location: C:\\Users\\47461\\.virtualenvs\\Env-Flask-TxTdDa0v Creating a Pipfile for this project… Pipfile.lock not found, creating… Locking [dev-packages] dependencies… Locking [packages] dependencies… Updated Pipfile.lock (db4242)! Installing dependencies from Pipfile.lock (db4242)… ================================ 0/0 - 00:00:00 To activate this project's virtualenv, run pipenv shell. Alternatively, run a command inside the virtualenv with pipenv run. 二. pipenv的介绍和简单使用 基本命令 pipenv install 本命令将在对应文件夹下创建一个pipenv的虚拟环境 pipenv shell 显式激活虚拟环境, 在虚拟环境下用pip相当于在全局环境下的pipenv pipenv run 不显式激活虚拟环境的情况下使用当前项目的虚拟环境执行命令 pipenv --venv 查看虚拟环境的路径 其他 : $ pipenv Usage: pipenv [OPTIONS] COMMAND [ARGS]... Options: --update 更新Pipenv & pip --where 显示项目文件所在路径 --venv 显示虚拟环境实际文件所在路径 --py 显示虚拟环境Python解释器所在路径 --envs 显示虚拟环境的选项变量 --rm 删除虚拟环境 --bare 最小化输出 --completion 完整输出 --man 显示帮助页面 --three / --two 使用Python 3/2创建虚拟环境（注意本机已安装的Python版本） --python TEXT 指定某个Python版本作为虚拟环境的安装源 --site-packages 附带安装原Python解释器中的第三方库 --jumbotron 不知道啥玩意.... --version 版本信息 -h, --help 帮助信息 Commands: check 检查安全漏洞 graph 显示当前依赖关系图信息 install 安装虚拟环境或者第三方库 lock 锁定并生成Pipfile.lock文件 open 在编辑器中查看一个库 run 在虚拟环境中运行命令 shell 进入虚拟环境 uninstall 卸载一个库 update 卸载当前所有的包，并安装它们的最新版本 虚拟环境的文件名一般为项目名+随机字符串的形式, 比如我项目名为Env-Flask, 则虚拟环境名为Env-Flask-TxTdDa0v 更换虚拟环境的路径 由于默认路径在C盘, 而C盘太满了...于是考虑更换虚拟环境的目录 方法: 设置环境变量WORKON_HOME值为对应的目录, 如果希望虚拟环境在项目文件夹, 则值填写为PIPENV_VENV_IN_PROJECT 两个文件Pipfile和Pipfile.lock 进行依赖的管理等, 前者记录了项目依赖包列表, 后者记录了固定版本的详细依赖包列表, 当使用pipenv安装/删除/更新依赖的时候, 这俩文件会自动更新 当需要在一个新目录下建立虚拟环境时, 会自动从目录下的pipfile中读取依赖并安装 换源 打开目录下的./Pipfile文件 [[source]] name = \"pypi\" url = \"https://pypi.org/simple\" verify_ssl = true [dev-packages] [packages] [requires] python_version = \"3.8\" 将url替换为\"https://pypi.tuna.tsinghua.edu.cn/simple\"即可 pycharm设置解释器为虚拟环境解释器 File - settings - Project - Project Interpreter - 设置⚙ - Add... - Pipenv Environment/Virtualenv Environment ( 我这直接使用pipenv environment报错了... ) Pipenv Environment ​ Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/08-Flask学习/02.部署上线.html":{"url":"roccoshi_note/08-Flask学习/02.部署上线.html","title":"02.部署上线","keywords":"","body":"安装git和配置创建超级用户上传代码并Clone github仓库安装python 3.8一. 下载python 3.8安装包二. 安装过程三. 修复yumpipenv install让公网能访问到端口设置nginx转发 由于迫切的想玩玩, 所以直接跳过内容先学习部署上线了 安装git和配置 $ yum install git $ git config --global user.name \"Lincest\" $ git config --global user.email \"474617032@qq.com\" 生成ssh密钥 ssh-keygen -t rsa -C \"474617032@qq.com\" 查看pub公钥并复制到github添加ssh cat /root/.ssh/id_rsa.pub 创建超级用户 adduser flask passwd flask usermod -aG wheel flask 上传代码并Clone github仓库 windows上传代码到github 服务器端clone仓库 pip3 install pipenv -i https://pypi.tuna.tsinghua.edu.cn/simple pipenv install 报错提示没有安装python 3.8 安装python 3.8 一. 下载python 3.8安装包 ( 这里用的是mirrors.sohu.com源 ) 切换目录到/opt : cd /opt wget http://mirrors.sohu.com/python/3.8.0/Python-3.8.0.tar.xz 二. 安装过程 解压文件 : tar -xvf Python-3.8.0.tar.xz configure : ./configure --prefix=/usr/local/python38 编译安装 : make && make install >/dev/null 删除老python的符号链接 : rm -f /usr/bin/python 建立符号链接 : ln -s /usr/local/python38/bin/python3.8 /usr/bin/python 三. 修复yum 修改/usr/bin/yum的第一行，以及/usr/libexec/urlgrabber-ext-down的第一行 #!/usr/bin/python 改为 #!/usr/bin/python2.7 pipenv install 直接执行会显示错误找不到python 找到python目录/usr/bin/python 然后执行pipenv install --python /usr/bin/python即可 让公网能访问到端口 首先阿里云安全组打开5000端口 然后执行pipenv run flask run --host=0.0.0.0 --port=5000即可 设置nginx转发 server { listen 80; server_name flask.roccoshi.top; location / { proxy_pass http://127.0.0.1:5000; proxy_redirect off; } } 效果 : flask.roccoshi.top Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/08-Flask学习/03.基础学习.html":{"url":"roccoshi_note/08-Flask学习/03.基础学习.html","title":"03.基础学习","keywords":"","body":"03.基础学习一. 环境变量--flaskenv和env二. 启动对外可见和改变端口三. URL与端点四. 自定义flask命令03.基础学习 一. 环境变量--flaskenv和env windows下使用set FLASK=hello, LINUX下使用export FLASK=hello设置环境变量 但是命令行下的环境变量在重启电脑后清除, 并且多个flaskapp同名的环境变量可能需要不同的值, 这时候就需要使用python-dotenv管理项目的环境变量 安装dotenv : pipenv install python-dotenv 在目录下新建.flaskenv和.env文件, .flaskenv存储flask相关的公开环境变量, .env存储包含敏感信息的环境变量 注意, 由于.env包含敏感信息, 绝对不能提交到git仓库里 二. 启动对外可见和改变端口 在flask run后添加--host=0.0.0.0和--port=xxxx 三. URL与端点 如: @app.route('/') def index(): return 'hello flask' 中端点就是index, 调用url_for('index')即可获取对应的url, 即“/” ( url_for生成的url是相对url, 如果要生成绝对url, 应当在调用url_for()函数时将_external参数设置为True ) 四. 自定义flask命令 通过创建一个函数并为之添加app.cli.command()装饰器即可 如: @app.cli.command() def hello(): click.echo('hello human') # click.echo可以在命令行界面输出字符 app.cli.command Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/08-Flask学习/04.FLask与HTTP.html":{"url":"roccoshi_note/08-Flask学习/04.FLask与HTTP.html","title":"04.FLask与HTTP","keywords":"","body":"04.FLask与HTTP一. Request对象二. 在Flask中处理请求2.1 路由匹配2.2 设置监听的HTTP方法2.3 URL处理2.4 请求钩子2.5 在flask中生成响应2.6 Cookie2.7 Session三. Flask上下文四. 一些进阶内容4.1 重定向回上一个页面4.2 对URL进行安全验证4.3 使用AJAX技术发送异步请求4.4 HTTP服务器端推送04.FLask与HTTP 一. Request对象 @app.route('/hello') def hello(): name = request.args.get('name', 'Flask') # 获取name值, 默认为name=Flask return 'Hello, %s!' % name 此时发送get请求name=hihihi则显示Hello, hihihi! 二. 在Flask中处理请求 2.1 路由匹配 flask routes 显示 : (Env-Flask-TxTdDa0v) E:\\projects\\Env-Flask>flask routes Endpoint Methods Rule -------- ------- ----------------------- hello GET /hello static GET /static/ 2.2 设置监听的HTTP方法 @app.route('/hi', methods=['GET', 'POST']) def hi(): return 'Hello, Flask!' 则仅当接收到get和post请求时才返回 2.3 URL处理 @app.route('/goback/') def go_back(year): return 'Welcome to %d year' % year 就是一个 其他转换器 : string - int - float - path - any - uuid any的用法 : @app.route('/selcolor/') def selcolor(color): return '%s is color' % color 此时除了blue和red, 其他都会报Not Found错误 2.4 请求钩子 对请求进行预处理( preprocessing )和后处理 ( postprocessing )的Hook 几种请求钩子 : before_first_request before_request after_request teardown_request after_this_request 2.5 在flask中生成响应 2.5.1 重定向 @app.route('/blog') def toBlog(): return redirect('https://roccoshi.top', 302) 2.5.2 错误响应 @app.route('/404') def not_found(): abort(404) 2.5.3 响应格式 MIME类型 : 在Content-Type中定义, 几种MIME类型 纯文本 : text/plain HTML : text/html XML : application/html JSON : application/json flask的make_response并设置MIME类型: @app.route('/foo') def foo(): response = make_response('Hello World!') response.mimetype = 'text/plain' return response 2.6 Cookie 使用set_cookie的方式设置cookie @app.route('/set/') def setCookie(name): response = make_response(redirect(url_for('foo'))) response.set_cookie('name',name) return response 设置cookie 在flask中, Cookie可以通过请求对象的cookies属性读取 @app.route('/') def hello(): name = request.args.get('name') if name is None: name = request.cookies.get('name','Human') return 'hello %s' % name # 如果get请求没得到name, 就从cookies里找, 如果cookies也没有, 就设置为Human 2.7 Session session用于将cookie数据加密存储 首先将一串随机字符写入.env文件作为密钥SECRET_KEY, 如SECRET_KEY='askjdhSKJDksk-DSj1sA' import os from flask import * app = Flask(__name__) app.secret_key = os.getenv('SECRET_KEY', '1k23kasjd') # 设置secret_key, 首先从环境变量中获取, 如果没有就默认为后面这一串 @app.route('/login') def login(): session['logged_in'] = True return redirect(url_for('hello')) @app.route('/') @app.route('/hello') def hello(): return 'hello world' 使用session 使用session模拟登录验证 import os from flask import * app = Flask(__name__) app.secret_key = os.getenv('SECRET_KEY', '1k23kasjd') # 登录 @app.route('/login') def login(): session['logged_in'] = True return redirect(url_for('hello')) # 登出 @app.route('/logout') def logout(): if 'logged_in' in session: session.pop('logged_in') return redirect(url_for('hello')) @app.route('/') @app.route('/hello') def hello(): name = request.args.get('name') if name is None: name = request.cookies.get('name', 'Human') response = 'Hello, %s!' % name if 'logged_in' in session: response += '[Authenticated]' else: response += '[Not Authenticated]' return response 注意 : 尽管session对象会对Cookie进行签名和加密, 但这种方式仅能够确保session的内容不会被篡改, 加密后的数据借助工具仍然能够轻易读取 ( 即使不知道密钥 ) 因此, 绝对不能在session中存储敏感信息, 比如用户密码 三. Flask上下文 Flask中的上下文变量 变量名 上下文类别 说明 current_app 程序上下文 指向处理请求的当前程序实例 g 程序上下文 替代Python的全局变量用法, 确保仅在当前请求中可用用于存储全局数据，每次请求都会重设 request 请求上下文 封装客户端发出的请求报文数据 session 请求上下文 用于请求, 通过Cookie实现 @app.before_request def get_name(): g.name = request.args.get('name') # 把name复制给g.name作为全局变量 上下文钩子 : Flask为上下文提供了一个teardown_appcontext钩子, 使用它注册的回调函数会在程序上下文被销毁时调用, 而且通常也会在请求上下文被销毁时使用 四. 一些进阶内容 4.1 重定向回上一个页面 方法一 : 利用request.referrer return redirect(request.referrer or url_for('xx')) 方法二 : 查询参数 @app.route('/bar') def bar(): return 'hido something and back' % url_for('doSth', next=request.full_path) # 设置一个参数next @app.route('/dosth') def doSth() return redirect(request.args.get('next', url_for('hello'))) # 重定向到next, 如果next不存在就定向到hello 重定向回上一个页面的代码 : def redirect_back(default=\"hello\", **kwargs): for target in request.args.get('next'), request.referrer: if target: return redirect(target) return redirect(url_for(default, **kwargs)) 4.2 对URL进行安全验证 由4.1中例子可以看出, 没有对next进行验证, 则next也可以被用户传入, 重定向到其他网站 def is_safe_url(target): ref_url = urlparse(request.host_url) test_url = urlparse(urljoin(request.host_url, target)) return test_url.scheme in ('http', 'https') and ref_url.netloc == test_url.netloc 4.3 使用AJAX技术发送异步请求 AJAX指异步Javascript和XML, 可以让我们在不重载页面的情况下和服务器进行数据交换 4.4 HTTP服务器端推送 传统的通信模式为客户端拉取 ( client pull ), 在这种模式下, 用户只能通过刷新页面或主动单击加载按钮来拉取新数据. 但是在某些场景下, 我们需要的通信模式是服务器端的主动推送 ( server push ) 实现服务器端推送的技术 : 传统轮询 : 利用AJAX技术不断向服务器发送http请求, 然后获取新的数据并更新页面 长轮询 : 和传统轮询类似, 但是如果服务器没有返回数据, 那就保持连接开启, 直到有数据后才返回 Server-Sent Events (SSE) : 在服务器端和客户端建立一个单向通道, 客户端监听来自服务器端的数据 ( 订阅 - 发布 模式) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/08-Flask学习/05.模板.html":{"url":"roccoshi_note/08-Flask学习/05.模板.html","title":"05.模板","keywords":"","body":"05.模板一. 模板基本用法二. 模板语法一个典型的if语句一个典型的for语句三. 渲染模板05.模板 一. 模板基本用法 {{ user.username }}'s Watchlist &larr; Return {{ user.username }} {% if user.bio %} {{ user.bio }} {% else %} This user has not provided a bio. {% endif %} {# Below is the movie list (this is comment) #} {{ user.username }}'s Watchlist ({{ movies|length }}): {% for movie in movies %} {{ movie.name }} - {{ movie.year }} {% endfor %} flask中 : user = { 'username': 'Grey Li', 'bio': 'A boy who loves movies and music.', } movies = [ {'name': 'My Neighbor Totoro', 'year': '1988'}, {'name': 'Three Colours trilogy', 'year': '1993'}, {'name': 'Forrest Gump', 'year': '1994'}, {'name': 'Perfect Blue', 'year': '1997'}, {'name': 'The Matrix', 'year': '1999'}, {'name': 'Memento', 'year': '2000'}, {'name': 'The Bucket list', 'year': '2007'}, {'name': 'Black Swan', 'year': '2010'}, {'name': 'Gone Girl', 'year': '2014'}, {'name': 'CoCo', 'year': '2017'}, ] @app.route('/watchlist') def watchlist(): return render_template('watchlist.html', user=user, movies=movies) 效果 : 使用模板 Jinja2中常用的三种定界符 : 1. 语句 {% ... %} 2. 表达式 {{ ... }} 3. 注释 {# ... #} 二. 模板语法 Jinja2 : 模板引擎 Jinja2允许你在模板中使用大部分Python对象, 比如字符串, 列表, 字典, 元组, 整型, 浮点型, 布尔值 Jinja2支持基本的运算符号 ( +, -, *, /等 ), 比较符号, 逻辑符号以及is, in, None和布尔值 Jinja2提供了多种控制结构来控制模板的输出, 其中for和if是最常用的两种 一个典型的if语句 {% if user.bio %} {{ user.bio }} {% else %} This user has not porvided a bio {% endif %} 在语句结束的地方必须添加结束标签 一个典型的for语句 {% for movie in movies %} {{ movie.name }} - {{ movie.year }} {% endfor %} 三. 渲染模板 render_template()用于渲染模板, 首先传入模板的文件名作为参数, 然后传入关键字参数 如 : render_template('watchlist.html', user=user, movies=movies) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/09-算法/":{"url":"roccoshi_note/09-算法/","title":"09-算法","keywords":"","body":" 算法笔记 算法课 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/09-算法/01. 算法笔记/":{"url":"roccoshi_note/09-算法/01. 算法笔记/","title":"01. 算法笔记","keywords":"","body":" 《算法笔记》 胡凡 练习与总结 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/09-算法/01. 算法笔记/1.1 动态规划.html":{"url":"roccoshi_note/09-算法/01. 算法笔记/1.1 动态规划.html","title":"1.1 动态规划","keywords":"","body":"/** * author: roccoshi * created: 2020-10-04 10:22:58 */ #include using namespace std; #define MAXN 1000005 vector dp(MAXN,-1); // Fibonacci question with recursion ( general solution ) int F1 (int n) { if (n==0 || n == 1) return 1; else return F1(n-1) + F1(n-2); } // Fibonacci question with dynamic programming int F2 (int n) { if (n == 0 || n == 1) { return 1; } if (dp[n] != -1) return dp[n]; else { dp[n] = F2(n-1) + F2(n-2); return dp[n]; } } // \"A problem -> many subproblems\" called \"Overlapping Subproblems\" int main() { freopen(\"out.txt\", \"w\", stdout); double clk1 = (double)clock()/CLOCKS_PER_SEC; for (int i = 0; i /** * author: roccoshi * created: 2020-10-04 10:53:34 */ #include using namespace std; #define maxn 20 vector > dp(maxn, vector (maxn, -1)); vector > f(maxn, vector (maxn, -1)); void reIO() { #ifndef ROCCOSHI freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); #endif } /* number-tower problem 5 / \\ 8 3 / \\ / \\ 12 7 16 /\\ /\\ /\\ 4 10 11 6 /\\ /\\ /\\ /\\ 9 5 3 9 4 task : try to find the maximum sum of each layer */ // state transition equation // dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + f[i][j] // dp[i][j] saves the [j-th num in the i-th layer] to the bottom layer's maximum sum // dp[i+1][j] -- left child // dp[i+1][j+1] -- right child int main() { reIO(); int n; cin >> n; // layer : 0 ~ n-1 // the i-th layer has i+1 nums for(int i = 0; i > f[i][j]; // cin num-tower } } // init the last layer for (int i = 0; i = 0; --i) { // find the num from (n-1)th layer to first layer for(int j = 0; j /** * author: roccoshi * created: 2020-10-04 11:30:52 */ // Maximum contiguous subsequence sum // sequence A1....An // 1 using namespace std; // let dp[i] represents the max sum with A[i] as the end of array // the state trasition equastion is : // dp[i] = max(dp[i-1] + A[i], A[i]) void reIO() { #ifndef ROCCOSHI freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); #endif } const int maxn = 10005; int A[maxn], dp[maxn]; int main() { reIO(); int n; cin >> n; for (int i = 0; i > A[i]; } dp[0] = A[0]; int ans = -1; for (int i = 1; i ans) ans = dp[i]; } cout /** * author: roccoshi * created: 2020-10-04 11:55:50 */ // Longest Increasing Sequence ( LIS ) // can be incontiguous // dp state transition equation : // dp[i] = max(1, dp[j] + 1) // the condition : { j = 1,2...,i-1 && A[j] using namespace std; void reIO() { #ifndef ROCCOSHI freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); #endif } const int maxn = 10005; int A[maxn], dp[maxn]; int main() { reIO(); int n; cin >> n; int ans = -1; for (int i = 0; i > A[i]; } for(int i = 0; i Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/09-算法/02. STL使用/":{"url":"roccoshi_note/09-算法/02. STL使用/","title":"02. STL使用","keywords":"","body":"STL目录1. 容器1.1 序列式容器1.2 关联式容器1.3 无序关联式容器1.4 其他2. 迭代器定义STL https://blog.csdn.net/weixin_45761327/article/details/107561697 目录 1. 容器 1.1 序列式容器 1. 数组(array) 数组-使用前 数组-创建与初始化 数组-array容器成员函数汇总 数组-访问数组元素 2. 向量(vector) 向量-使用前 向量-创建与初始化 向量-vector 容器的成员函数 向量-访问向量元素 向量-insert语法格式 向量-删除元素 3. 双端队列 队列-使用前 队列-创建与初始化 队列-deque容器的成员函数 队列-访问队列中的元素 队列-insert() 成员函数语法格式 4. 双链表 双链表-使用前 双链表-创建与初始化 双链表-list容器的成员函数 双链表-访问链表中的元素 双链表-list添加（插入）元素 双链表-insert()语法格式 双链表-list splice()成员方法 双链表-list删除元素 5. 正向链表 单链表-使用前 单链表-创建与初始化 单链表- forward_list 容器可用的成员函数 6. array、vector 和 deque 容器的函数成员 7. list 和 forward_list 的函数成员 1.2 关联式容器 1. pair类模板 pair类的构造方法 2. map map-使用前 map-创建与初始化 map-map容器常用成员方法 map-map获取键对应值 map-map insert()插入数据 3. multimap容器 multimap-使用前 multimap-创建与初始化 multimap-multimap 容器常用成员方法 4. set set-使用前 set-创建与初始化 set-set 容器常用成员方法 set-set迭代器 set-insert()函数详解 set-set删除数据 5.multiset multiset-使用前 multiset-创建与初始化 multiset-multiset 容器常用成员方法 1.3 无序关联式容器 1. unordered_map unordered_map-使用前 unordered_map - 创建与初始化 unordered_map - unordered_map类模板成员方法 unordered_map - unordered_map获取元素 unordered_map -insert() unordered_map-unordered_map删除元素 2. unordered_multimap unordered_multimap-使用前 unordered_multimap-创建与初始化 unordered_multimap类模板成员方法 3. unordered_set unordered_set-使用前 unordered_set-创建与初始化 unordered_set - unordered_set 类模板成员方法 4. unordered_multiset unordered_multiset-使用前 unordered_multiset-创建与初始化 1.4 其他 1.String String - 创建与初始化 String - string 类的所有成员函数 2.栈 栈-使用前 栈-创建与初始化 栈-常用函数 3.queue queue- 使用前 queue-创建于初始化 queue-queue容器适配器支持的成员函数 4.priority_queue（优先队列） priority_queue-使用前 priority_queue-创建与初始化 priority_queue-常用函数 2. 迭代器定义 1. 容器 容器种类 功能 序列容器 主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。 之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。 将元素插入容器时，指定在什么位置，元素就会位于什么位置。 排序容器 包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。 排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。 哈希容器 C++ 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。 和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。 1.1 序列式容器 1. 数组(array) array（数组容器）：表示可以存储 N 个 T 类型的元素,元素个数固定。就是一个添加了一些成员函数和全局函数的数组，效率不降的情况下比普通数组更加安全。 数组-使用前 在使用数组容器之前，代码中需引入头文件，并默认使用 std 命令空间，如下所示： #include using namespace std; 数组-创建与初始化 array 容器有多种初始化方式，具体如下： 创建具有 4 个 int 类型元素的 array 容器： std::array values;//若已指定std命名空间，则可省略std:: 创建时将所有的元素初始化为 0 或者和默认元素类型等效的值： std::array values {}; 像创建常规数组那样对元素进行初始化 std::array values {0.5,1.0,1.5,2.0};//如同常规数组一样，初始化时未涉及的其余元素都会被初始化为0 数组-array容器成员函数汇总 重要的函数已加粗 成员函数 功能 begin() 返回指向容器中第一个元素的随机访问迭代器。 end() 返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。 rbegin() 返回指向最后一个元素的随机访问迭代器。 rend() 返回指向第一个元素之前一个位置的随机访问迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 size() 返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。 max_size() 返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。 empty() 判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。 at(n) 返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。 front() 返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。 back() 返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。 data() 返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能。 fill(val) 将 val 这个值赋值给容器中的每个元素。 array1.swap(array2) 交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。 部分函数使用示例 #include //需要引入 array 头文件 #include using namespace std; int main() { std::array values{}; //初始化 values 容器为 {0,1,2,3} for (int i = 0; i (values) 数组-访问数组元素 调用size()函数返回个数使用for循环遍历每个元素 array values{1,2,3,4,5}; //从下标 0 一直遍历到 size()-1 处 for (int i = 0; i 使用迭代器进行访问-利用begin()/end() 函数 array values{1,2,3,4,5}; for (auto first = values.begin(); first 如上示例，我们可使用at()函数，但同时也可使用[]+索引的方式 at()函数会检查越界，而索引的方式则不会进行检查 values.at (4) = values.at(3) + 2.O*values.at(1); values[4] = values[3] + 2.O*values[1]; 同理我们可使用get()函数和索引的方式获取元素值 2. 向量(vector) vector（向量容器）：用来存放 T 类型的元素，是一个长度可变的序列容器,长度不足时会自动申请内存空间以增长。在尾部增删效率为O(1)，但在其他位置增删效率为O(n) 向量-使用前 vector 容器以类模板 vector（ T 表示存储元素的类型）的形式定义在 头文件中，并位于 std 命名空间中。因此，在创建该容器之前，代码中需包含如下内容： #include using namespace std; 向量-创建与初始化 创建 vector 容器的方式有很多，大致可分为以下几种。 创建一个空的存储double类型的vector容器 std::vector values; 创建时初始化值 std::vector primes {2, 3, 5, 7, 11, 13, 17, 19}; 创建时指定元素个数 std::vector values(20);//这20个元素默认初始值都是0 创建时指定元素个数并指定默认初始值 std::vector values(20, 1.0);//这 20 个元素的初始值都是 1.0 通过存储元素类型相同的其它 vector 容器，可以创建新的 vector 容器 std::vectorvalue1(5, 'c'); std::vectorvalue2(value1); //若不想保存所有元素 int array[]={1,2,3}; std::vectorvalues(array, array+2);//values 将保存{1,2} std::vectorvalue1{1,2,3,4,5}; std::vectorvalue2(std::begin(value1),std::begin(value1)+3);//value2保存{1,2,3} 向量-vector 容器的成员函数 成员函数 功能 begin() 返回指向容器中第一个元素的迭代器。 end() 返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。 rbegin() 返回指向最后一个元素的迭代器。 rend() 返回指向第一个元素所在位置前一个位置的迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 size() 返回实际元素个数。 max_size() 返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。 resize() 改变实际元素的个数。 capacity() 返回当前容量。 empty() 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 reserve() 增加容器的容量。 shrink _to_fit() 将内存减少到等于当前元素实际所使用的大小。 operator[ ] 重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 at() 使用经过边界检查的索引访问元素。 front() 返回第一个元素的引用。 back() 返回最后一个元素的引用。 data() 返回指向容器中第一个元素的指针。 assign() 用新元素替换原有内容。 push_back() 在序列的尾部添加一个元素。 pop_back() 移出序列尾部的元素。 insert() 在指定的位置插入一个或多个元素。 erase() 移出一个元素或一段元素。 clear() 移出所有的元素，容器大小变为 0。 swap() 交换两个容器的所有元素。 emplace() 在指定的位置直接生成一个元素。 emplace_back() 在序列尾部生成一个元素。 对于空的 vector 容器来说，begin() 和 end() 成员函数返回的迭代器是相等的，即它们指向的是同一个位置。 所以，对于空的 vector 容器来说，可以通过调用 push_back() 或者借助 resize() 成员函数实现初始化容器的目的。 除此之外，vector 容器在申请更多内存的同时，容器中的所有元素可能会被复制或移动到新的内存地址，这会导致之前创建的迭代器失效。 注意：emplace_back() 和 push_back() 的虽然都是向容器尾部添加一个元素 ， 但两者底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。 因此emplace_back()的效率会更高， insert()和emplace()同理。 向量-访问向量元素 调用size()函数返回个数使用for循环遍历每个元素 vector values{1,2,3,4,5}; //从下标 0 一直遍历到 size()-1 处 for (int i = 0; i 使用迭代器进行访问-利用begin()/end() 函数 vector values{1,2,3,4,5}; for (auto first = values.begin(); first 如上示例，我们可使用at()函数，但同时也可使用[]+索引的方式 at()函数会检查越界，而索引的方式则不会进行检查 values.at (4) = values.at(3) + 2.O*values.at(1); values[4] = values[3] + 2.O*values[1]; 同理我们可使用get()函数和索引的方式获取元素值 我们可以调用front() 和 back()函数，它们分别返回 vector 容器中第一个和最后一个元素的引用，通过利用这 2 个函数返回的引用，可以访问（甚至修改）容器中的首尾元素。 我们也可以调用 data() 成员函数，该函数的功能是返回指向容器中首个元素的指针。通过该指针也可以访问甚至修改容器中的元素 vector values{1,2,3,4,5}; //输出容器中第 3 个元素的值 cout 向量-insert语法格式 语法格式 功能 iterator insert(pos,elem) 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。 iterator insert(pos,n,elem) 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。 iterator insert(pos,first,last) 在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。 iterator insert(pos,initlist) 在迭代器 pos指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。 iterator insert(pos,elem) 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。 std::vector demo{1,2}; //第一种格式用法 demo.insert(demo.begin() + 1, 3);//{1,3,2} iterator insert(pos,n,elem) 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。 //第二种格式用法 demo.insert(demo.end(), 2, 5);//{1,3,2,5,5} iterator insert(pos,first,last) 在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。 //第三种格式用法 std::arraytest{ 7,8,9 }; demo.insert(demo.end(), test.begin(), test.end());//{1,3,2,5,5,7,8,9} iterator insert(pos,initlist) 在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。 //第四种格式用法 demo.insert(demo.end(), { 10,11 });//{1,3,2,5,5,7,8,9,10,11} 向量-删除元素 删除 vector 容器元素的几种方式 函数 功能 pop_back() 删除 vector 容器中最后一个元素，该容器的大小（size）会减 1，但容量（capacity）不会发生改变。 erase(pos) 删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置元素的迭代器。该容器的大小（size）会减 1，但容量（capacity）不会发生改变。 swap(beg)、pop_back() 先调用 swap() 函数交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back() 删除该目标元素。 erase(beg,end) 删除 vector 容器中位于迭代器 [beg,end)指定区域内的所有元素，并返回指向被删除区域下一个位置元素的迭代器。该容器的大小（size）会减小，但容量（capacity）不会发生改变。 remove() 删除容器中所有和指定元素值相等的元素，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。 clear() 删除 vector 容器中所有的元素，使其变成空的 vector 容器。该函数会改变 vector 的大小（变为 0），但不是改变其容量。 3. 双端队列 deque（双端队列容器）：和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶； 注意，其实除此之外，stack 和 queue 本质上也属于序列容器，只不过它们都是在 deque 容器的基础上改头换面而成，通常更习惯称它们为容器适配器，有关它们的介绍，会放到后续章节中。 队列-使用前 deque 容器以模板类 deque（T 为存储元素的类型）的形式在 头文件中，并位于 std 命名空间中。因此，在使用该容器之前，代码中需要包含下面两行代码： #include using namespace std; 队列-创建与初始化 创建 deque 容器，根据不同的实际场景，可选择使用如下几种方式。 创建一个没有任何元素的空 deque 容器： std::deque d; 创建一个具有 n 个元素的 deque 容器，其中每个元素都采用对应类型的默认值： std::deque d(10); 创建一个具有 n 个元素的 deque 容器，并为每个元素都指定初始值，例如： std::deque d(10, 5) 在已有 deque 容器的情况下，可以通过拷贝该容器创建一个新的 deque 容器，例如： std::deque d1(5); std::deque d2(d1); 通过拷贝其他类型容器中指定区域内的元素（也可以是普通数组），可以创建一个新容器，例如： //拷贝普通数组，创建deque容器 int a[] = { 1,2,3,4,5 }; std::dequed(a, a + 5); //适用于所有类型的容器 std::arrayarr{ 11,12,13,14,15 }; std::dequed(arr.begin()+2, arr.end());//拷贝arr容器中的{13,14,15} 队列-deque容器的成员函数 重要函数已加粗标出 函数成员 函数功能 begin() 返回指向容器中第一个元素的迭代器。 end() 返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。 rbegin() 返回指向最后一个元素的迭代器。 rend() 返回指向第一个元素所在位置前一个位置的迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 size() 返回实际元素个数。 max_size() 返回容器所能容纳元素个数的最大值。这通常是一个很大的值，一般是 232-1，我们很少会用到这个函数。 resize() 改变实际元素的个数。 empty() 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 shrink _to_fit() 将内存减少到等于当前元素实际所使用的大小。 at() 使用经过边界检查的索引访问元素。 front() 返回第一个元素的引用。 back() 返回最后一个元素的引用。 assign() 用新元素替换原有内容。 push_back() 在序列的尾部添加一个元素。 push_front() 在序列的头部添加一个元素。 pop_back() 移除容器尾部的元素。 pop_front() 移除容器头部的元素。 insert() 在指定的位置插入一个或多个元素。 erase() 移除一个元素或一段元素。 clear() 移出所有的元素，容器大小变为 0。 swap() 交换两个容器的所有元素。 emplace() 在指定的位置直接生成一个元素。 emplace_front() 在容器头部生成一个元素。和 push_front() 的区别是，该函数直接在容器头部构造元素，省去了复制移动元素的过程。 emplace_back() 在容器尾部生成一个元素。和 push_back() 的区别是，该函数直接在容器尾部构造元素，省去了复制移动元素的过程。 关于empalace()函数和insert()的效率问题前面已经讨论 这里不再涉及 队列-访问队列中的元素 队列可以像普通数组一样采用索引的方式访问元素 dequed{ 1,2,3,4 }; cout 队列可以调用at()函数来访问元素 at() 成员函数会自行判定访问位置是否越界，如果越界则抛出std::out_of_range异常。 dequed{ 1,2,3,4 }; cout 队列可以调用front()和back()函数来访问队列的首尾元素 deque d{ 1,2,3,4,5 }; cout 注意，deque没有提供data()函数 队列-insert() 成员函数语法格式 语法格式 功能 iterator insert(pos,elem) 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。 iterator insert(pos,n,elem) 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。 iterator insert(pos,first,last) 在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。 iterator insert(pos,initlist) 在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。 std::deque d{ 1,2 }; //第一种格式用法 d.insert(d.begin() + 1, 3);//{1,3,2} //第二种格式用法 d.insert(d.end(), 2, 5);//{1,3,2,5,5} //第三种格式用法 std::arraytest{ 7,8,9 }; d.insert(d.end(), test.begin(), test.end());//{1,3,2,5,5,7,8,9} //第四种格式用法 d.insert(d.end(), { 10,11 });//{1,3,2,5,5,7,8,9,10,11} 注意:下图为vector的insert()函数语法格式,注意到两者是一致的! 4. 双链表 list（链表容器）：是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素。 实际场景中，如何需要对序列进行大量添加或删除元素的操作，而直接访问元素的需求却很少，这种情况建议使用 list 容器存储序列。 双链表-使用前 list 容器以模板类 list（T 为存储元素的类型）的形式在头文件中，并位于 std 命名空间中。因此，在使用该容器之前，代码中需要包含下面两行代码： #include using namespace std; 注意，std 命名空间也可以在使用 list 容器时额外注明，两种方式都可以。 双链表-创建与初始化 创建一个没有任何元素的空list容器 std::list values; 创建一个包含n个元素的list容器 std::list values(10);//注意:容积用小括号 创建一个包含n个元素的list容器并制定初始值 std::list values(10 , 5); 通过拷贝已有的list容器创建新的容器 std::list values1(10 , 5); std::list values2(values1); 通过拷贝已有的list容器中的部分元素创建新的容器 //拷贝普通数组，创建list容器 int a[] = { 1,2,3,4,5 }; std::list values(a, a+5); //拷贝其它类型的容器，创建 list 容器 std::arrayarr{ 11,12,13,14,15 }; std::listvalues(arr.begin()+2, arr.end());//拷贝arr容器中的{13,14,15} 双链表-list容器的成员函数 重要的函数已加粗标出 成员函数 功能 begin() 返回指向容器中第一个元素的双向迭代器。 end() 返回指向容器中最后一个元素的双向迭代器。 rbegin() 返回指向最后一个元素的反向双向迭代器。 rend() 返回指向第一个元素所在位置前一个位置的反向双向迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 empty() 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 size() 返回当前容器实际包含的元素个数。 max_size() 返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。 front() 返回第一个元素的引用。 back() 返回最后一个元素的引用。 assign() 用新元素替换容器中原有内容。 emplace_front() 在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。 push_front() 在容器头部插入一个元素。 pop_front() 删除容器头部的一个元素。 emplace_back() 在容器尾部直接生成一个元素。该函数和 push_back() 的功能相同，但效率更高。 push_back() 在容器尾部插入一个元素。 pop_back() 删除容器尾部的一个元素。 emplace() 在容器中的指定位置插入元素。该函数和 insert() 功能相同，但效率更高。 insert() 在容器中的指定位置插入元素。 erase() 删除容器中一个或某区域内的元素。 swap() 交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。 resize() 调整容器的大小。 clear() 删除容器存储的所有元素。 splice() 将一个 list 容器中的元素插入到另一个容器的指定位置。 remove(val) 删除容器中所有等于 val 的元素。 remove_if() 删除容器中满足条件的元素。 unique() 删除容器中相邻的重复元素，只保留一个。 merge() 合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的。 sort() 通过更改容器中元素的位置，将它们进行排序。 reverse() 反转容器中元素的顺序。 emplace()系列函数和insert()系列函数的效率问题,前者更高,原因在前面已经给出,这里不再讨论. 双链表-访问链表中的元素 访问 list 容器中存储元素的方式很有限，即要么使用 front() 和 back() 成员函数，要么使用 list 容器迭代器。 list 容器不支持随机访问，未提供下标操作符 [] 和 at() 成员函数，也没有提供 data() 成员函数。 除此之外，如果想访问 list 容存储的其他元素，就只能使用 list 容器的迭代器。 const std::list mylist{1,2,3,4,5}; auto it = mylist.begin(); cout 双链表-list添加（插入）元素 list 模板类中，与“添加或插入新元素”相关的成员方法有如下几个： push_front()：向 list 容器首个元素前添加新元素； push_back()：向 list 容器最后一个元素后添加新元素； emplace_front()：在容器首个元素前直接生成新的元素； emplace_back()：在容器最后一个元素后直接生成新的元素； emplace()：在容器的指定位置直接生成新的元素； insert()：在指定位置插入新元素； splice()：将其他 list 容器存储的多个元素添加到当前 list 容器的指定位置处。 双链表-insert()语法格式 语法格式 功能 iterator insert(pos,elem) 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。 iterator insert(pos,n,elem) 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。 iterator insert(pos,first,last) 在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。 iterator insert(pos,initlist) 在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。 std::list values{ 1,2 }; //第一种格式用法 values.insert(values.begin() , 3);//{3,1,2} //第二种格式用法 values.insert(values.end(), 2, 5);//{3,1,2,5,5} //第三种格式用法 std::arraytest{ 7,8,9 }; values.insert(values.end(), test.begin(), test.end());//{3,1,2,5,5,7,8,9} //第四种格式用法 values.insert(values.end(), { 10,11 });//{3,1,2,5,5,7,8,9,10,11} 注意！迄今为止，向量，队列，链表的insert()函数语法格式都是一致的 双链表-list splice()成员方法 和 insert() 成员方法相比，splice() 成员方法的作用对象是其它 list 容器，其功能是将其它 list 容器中的元素添加到当前 list 容器中指定位置处。 splice() 成员方法的语法格式有 3 种 语法格式 功能 void splice (iterator position, list& x); position 为迭代器，用于指明插入位置；x 为另一个 list 容器。 此格式的 splice() 方法的功能是，将 x 容器中存储的所有元素全部移动当前 list 容器中 position 指明的位置处。 void splice (iterator position, list& x, iterator i); position 为迭代器，用于指明插入位置；x 为另一个 list 容器；i 也是一个迭代器，用于指向 x 容器中某个元素。 此格式的 splice() 方法的功能是将 x 容器中 i 指向的元素移动到当前容器中 position 指明的位置处。 void splice (iterator position, list& x, iterator first, iterator last); position 为迭代器，用于指明插入位置；x 为另一个 list 容器；first 和 last 都是迭代器，[fist,last) 用于指定 x 容器中的某个区域。 此格式的 splice() 方法的功能是将 x 容器 [first, last) 范围内所有的元素移动到当前容器 position 指明的位置处。 //创建并初始化 2 个 list 容器 list mylist1{ 1,2,3,4 }, mylist2{10,20,30}; list::iterator it = ++mylist1.begin(); //指向 mylist1 容器中的元素 2 //调用第一种语法格式 mylist1.splice(it, mylist2); // mylist1: 1 10 20 30 2 3 4 // mylist2: // it 迭代器仍然指向元素 2，只不过容器变为了 mylist1 //调用第二种语法格式，将 it 指向的元素 2 移动到 mylist2.begin() 位置处 mylist2.splice(mylist2.begin(), mylist1, it); // mylist1: 1 10 20 30 3 4 // mylist2: 2 // it 仍然指向元素 2 //调用第三种语法格式，将 [mylist1.begin(),mylist1.end())范围内的元素移动到 mylist.begin() 位置处 mylist2.splice(mylist2.begin(), mylist1, mylist1.begin(),mylist1.end());//mylist1: //mylist2:1 10 20 30 3 4 2 双链表-list删除元素 实现 list 容器删除元素的成员函数 成员函数 功能 pop_front() 删除位于 list 容器头部的一个元素。 pop_back() 删除位于 list 容器尾部的一个元素。 erase() 该成员函数既可以删除 list 容器中指定位置处的元素，也可以删除容器中某个区域内的多个元素。 clear() 删除 list 容器存储的所有元素。 remove(val) 删除容器中所有等于 val 的元素。 unique() 删除容器中相邻的重复元素，只保留一份。 remove_if() 删除容器中满足条件的元素。 erase()函数可传入一个或两个迭代器的位置,分别为删除一个和一段的元素 若想根据元素的值来执行删除操作,则可使用remove操作,直接传入值即可 unique() 函数也可选择是否传入一个二元谓词函数,可自定义去重规则 remove_if()和unique()一致,可选择是否传入二元谓词函数 #include #include using namespace std; //二元谓词函数 bool demo(double first, double second) { return (int(first) == int(second)); } int main() { list mylist{ 1,1.2,1.2,3,4,4.5,4.6 }; //删除相邻重复的元素，仅保留一份 mylist.unique();//{1, 1.2, 3, 4, 4.5, 4.6} for (auto it = mylist.begin(); it != mylist.end(); ++it) cout 5. 正向链表 forward_list（正向链表容器）：和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。 单链表-使用前 由于 forward_list 容器以模板类 forward_list（T 为存储元素的类型）的形式被包含在头文件中，并定义在 std 命名空间中。因此，在使用该容器之前，代码中需包含下面两行代码： #include using namespace std; 单链表-创建与初始化 创建 forward_list 容器的方式，大致分为以下 5 种。 创建一个没有任何元素的空list容器 std::forward_list values; 创建一个包含n个元素的list容器 std::forward_list values(10);//注意:容积用小括号 创建一个包含n个元素的list容器并制定初始值 std::forward_list values(10 , 5); 通过拷贝已有的list容器创建新的容器 std::forward_list values1(10 , 5); std::forward_list values2(values1); 通过拷贝已有的list容器中的部分元素创建新的容器 //拷贝普通数组，创建list容器 int a[] = { 1,2,3,4,5 }; std::forward_list values(a, a+5); //拷贝其它类型的容器，创建 list 容器 std::arrayarr{ 11,12,13,14,15 }; std::forward_listvalues(arr.begin()+2, arr.end());//拷贝arr容器中的{13,14,15} 仔细观察,单链表和双链表的初始化方式都是一样的 单链表- forward_list 容器可用的成员函数 重要的函数已加粗标出 成员函数 功能 before_begin() 返回一个前向迭代器，其指向容器中第一个元素之前的位置。 begin() 返回一个前向迭代器，其指向容器中第一个元素的位置。 end() 返回一个前向迭代器，其指向容器中最后一个元素之后的位置。 cbefore_begin() 和 before_begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 empty() 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 max_size() 返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。 front() 返回第一个元素的引用。 assign() 用新元素替换容器中原有内容。 push_front() 在容器头部插入一个元素。 emplace_front() 在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。 pop_front() 删除容器头部的一个元素。 emplace_after() 在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。和 insert_after() 的功能相同，但效率更高。 insert_after() 在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。 erase_after() 删除容器中某个指定位置或区域内的所有元素。 swap() 交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。 resize() 调整容器的大小。 clear() 删除容器存储的所有元素。 splice_after() 将某个 forward_list 容器中指定位置或区域内的元素插入到另一个容器的指定位置之后。 remove(val) 删除容器中所有等于 val 的元素。 remove_if() 删除容器中满足条件的元素。 unique() 删除容器中相邻的重复元素，只保留一个。 merge() 合并两个事先已排好序的 forward_list 容器，并且合并之后的 forward_list 容器依然是有序的。 sort() 通过更改容器中元素的位置，将它们进行排序。 reverse() 反转容器中元素的顺序。 关于empalace()函数和insert()的效率问题前面已经讨论 这里不再涉及 通过表我们知道，forward_list 容器中是不提供 size() 函数的，但如果想要获取 forward_list 容器中存储元素的个数，可以使用头文件 中的 distance() 函数。举个例子 std::forward_list my_words{1,2,3,4}; int count = std::distance(std::begin(my_words), std::end(my_words)); cout 6. array、vector 和 deque 容器的函数成员 函数成员 函数功能 array vector deque begin() 返回指向容器中第一个元素的迭代器。 是 是 是 end() 返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。 是 是 是 rbegin() 返回指向最后一个元素的迭代器。 是 是 是 rend() 返回指向第一个元素所在位置前一个位置的迭代器。 是 是 是 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 是 是 是 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 是 是 是 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 是 是 是 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 是 是 是 assign() 用新元素替换原有内容。 - 是 是 operator=() 复制同类型容器的元素，或者用初始化列表替换现有内容。 是 是 是 size() 返回实际元素个数。 是 是 是 max_size() 返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。 是 是 是 capacity() 返回当前容量。 - 是 - empty() 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 是 是 是 resize() 改变实际元素的个数。 - 是 是 shrink _to_fit() 将内存减少到等于当前元素实际所使用的大小。 - 是 是 front() 返回第一个元素的引用。 是 是 是 back() 返回最后一个元素的引用。 是 是 是 operator 使用索引访问元素。 是 是 是 at() 使用经过边界检査的索引访问元素。 是 是 是 push_back() 在序列的尾部添加一个元素。 - 是 是 insert() 在指定的位置插入一个或多个元素。 - 是 是 emplace() 在指定的位置直接生成一个元素。 - 是 是 emplace_back() 在序列尾部生成一个元素。 - 是 是 pop_back() 移出序列尾部的元素。 - 是 是 erase() 移出一个元素或一段元素。 - 是 是 clear() 移出所有的元素，容器大小变为 0。 - 是 是 swap() 交换两个容器的所有元素。 是 是 是 data() 返回指向容器中第一个元素的指针。 是 是 - 7. list 和 forward_list 的函数成员 list 和 forward_list 容器彼此非常相似，forward_list 中包含了 list 的大部分成员函数，而未包含那些需要反向遍历的函数。表 3 展示了 list 和 forward_list 的函数成员。 函数成员 函数功能 list forward_list begin() 返回指向容器中第一个元素的迭代器 是 是 end() 返回指向容器最后一个元素所在位置后一个位置的迭代器。 是 是 rbegin() 返回指向最后一个元素的迭代器。 是 - rend() 返回指向第一个元素所在位置前一个位置的迭代器。 是 - cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 是 是 before_begin() 返回指向第一个元素前一个位置的迭代器。 - 是 cbefore_begin() 和 before_begin() 功能相同，只不过在其基础上，增加了 const 属性，即不能用该指针修改元素的值。 - 是 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 是 是 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 是 - crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 是 - assign() 用新元素替换原有内容。 是 是 operator=() 复制同类型容器的元素，或者用初始化列表替换现有内容。 是 是 size() 返回实际元素个数。 是 - max_size() 返回元素个数的最大值，这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。 是 是 resize() 改变实际元素的个数。 是 是 empty() 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 是 是 front() 返回容器中第一个元素的引用。 是 是 back() 返回容器中最后一个元素的引用。 是 - push_back() 在序列的尾部添加一个元素。 是 - push_front() 在序列的起始位置添加一个元素。 是 是 emplace() 在指定位置直接生成一个元素。 是 - emplace_after() 在指定位置的后面直接生成一个元素。 - 是 emplace_back() 在序列尾部生成一个元素。 是 - cmplacc_front() 在序列的起始位生成一个元索。 是 是 insert() 在指定的位置插入一个或多个元素。 是 - insert_after() 在指定位置的后面插入一个或多个元素。 - 是 pop_back() 移除序列尾部的元素。 是 - pop_front() 移除序列头部的元素。 是 是 reverse() 反转容器中某一段的元素。 是 是 erase() 移除指定位置的一个元素或一段元素。 是 - erase_after() 移除指定位置后面的一个元素或一段元素。 - 是 remove() 移除所有和参数匹配的元素。 是 是 remove_if() 移除满足一元函数条件的所有元素。 是 是 unique() 移除所有连续重复的元素。 是 是 clear() 移除所有的元素，容器大小变为 0。 是 是 swap() 交换两个容器的所有元素。 是 是 sort() 对元素进行排序。 是 是 merge() 合并两个有序容器。 是 是 splice() 移动指定位置前面的所有元素到另一个同类型的 list 中。 是 - splice_after() 移动指定位置后面的所有元素到另一个同类型的 list 中。 - 是 1.2 关联式容器 和序列式容器不同的是，关联式容器在存储元素时还会为每个元素在配备一个键，整体以键值对的方式存储到容器中。相比前者，关联式容器可以通过键值直接找到对应的元素，而无需遍历整个容器。另外，关联式容器在存储元素，默认会根据各元素键值的大小做升序排序。 相比其它类型容器，关联式容器查找、访问、插入和删除指定元素的效率更高。 弃用序列式容器，转而选用关联式容器存储元素，往往就是看中了关联式容器可以快速查找、读取或者删除所存储的元素，同时该类型容器插入元素的效率也比序列式容器高。 关联式容器所具备的这些特性，归咎于 STL 标准库在实现该类型容器时，底层选用了 「红黑树」这种数据结构来组织和存储各个键值对。 关联式容器，包括 map、multimap、set 以及 multiset 这 4 种容器。 关联式容器名称 特点 map 定义在 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根据各元素键的大小，默认进行升序排序（调用 std::less）。 set 定义在 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序（调用 std::less）。 multimap 定义在 头文件中，和 map 容器唯一的不同在于，multimap 容器中存储元素的键可以重复。 multiset 定义在 头文件中，和 set 容器唯一的不同在于，multiset 容器中存储元素的值可以重复（一旦值重复，则意味着键也是重复的）。 1. pair类模板 pair 类模板定义在头文件中，所以在使用该类模板之前，需引入此头文件。 C++ STL 标准库提供了 pair 类模板，其专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素 pair类的构造方法 #1) 默认构造函数，即创建空的 pair 对象 pair(); pair pair1; #2) 直接使用 2 个元素初始化成 pair 对象 pair (const first_type& a, const second_type& b); pair pair2(\"STL教程\",\"http://c.biancheng.net/stl/\"); #3) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象 template pair (const pair& pr); pair pair3(pair2); #4) 移动构造函数 template pair (pair&& pr); pair pair4(make_pair(\"C++教程\", \"http://c.biancheng.net/cplus/\")); #5) 使用右值引用参数，创建 pair 对象 template pair (U&& a, V&& b); pair pair5(string(\"Python教程\"), string(\"http://c.biancheng.net/python/\")); 头文件中除了提供创建 pair 对象的方法之外，还为 pair 对象重载了 、>=、==、!= 这 6 的运算符，其运算规则是：对于进行比较的 2 个 pair 对象，先比较 pair.first 元素的大小，如果相等则继续比较 pair.second 元素的大小。 2. map 作为关联式容器的一种，map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。其中，各个键值对的键和值可以是任意数据类型，包括 C++ 基本数据类型（int、double 等）、使用结构体或类自定义的类型。 map-使用前 map 容器定义在 头文件中，并位于 std 命名空间中。因此，如果想使用 map 容器，代码中应包含如下语句： #include using namespace std; map 容器的模板定义如下： template , // 指定排序规则 class Alloc = allocator > // 指定分配器对象的类型 > class map; 可以看到，map 容器模板有 4 个参数，其中后 2 个参数都设有默认值。大多数场景中，我们只需要设定前 2 个参数的值，有些场景可能会用到第 3 个参数，但最后一个参数几乎不会用到。 map-创建与初始化 创建一个空的map容器 std::mapmyMap; 在创建map容器的同时进行初始化 std::mapmyMap{ {\"C语言教程\",10},{\"STL教程\",20} }; std::mapmyMap{std::make_pair(\"C语言教程\",10),std::make_pair(\"STL教程\",20)}; 利用已有的map容器创建新的map容器 std::mapnewMap(myMap); 利用已有map容器中的部分键值对创建新的map容器 std::mapmyMap{ {\"C语言教程\",10},{\"STL教程\",20} }; std::mapnewMap(++myMap.begin(), myMap.end()); 在以上几种创建 map 容器的基础上，我们都可以手动修改 map 容器的排序规则。默认情况下，map 容器调用 std::less 规则，根据容器内各键值对的键的大小，对所有键值对做升序排序。 //以下两行等价 std::mapmyMap{ {\"C语言教程\",10},{\"STL教程\",20} }; std::map >myMap{ {\"C语言教程\",10},{\"STL教程\",20} }; 下面程序手动修改了 myMap 容器的排序规则，令其作降序排序： std::map >myMap{ {\"C语言教程\",10},{\"STL教程\",20} }; map-map容器常用成员方法 成员方法 功能 begin() 返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 end() 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 rbegin() 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 rend() 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 find(key) 在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 lower_bound(key) 返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 upper_bound(key) 返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 equal_range(key) 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。 empty() 若容器为空，则返回 true；否则 false。 size() 返回当前 map 容器中存有键值对的个数。 max_size() 返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。 operator[] map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。 at(key) 找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。 insert() 向 map 容器中插入键值对。 erase() 删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对。后续章节还会对该方法做重点讲解。 swap() 交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。 clear() 清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0。 emplace() 在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。 emplace_hint() 在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。 count(key) 在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。 map-map获取键对应值 map 容器的类模板中提供了以下 2 种方法，可直接获取 map 容器指定键对应的值。 map 类模板中对[ ]运算符进行了重载，这意味着，类似于借助数组下标可以直接访问数组中元素，通过指定的键，我们可以轻松获取 map 容器中该键对应的值。 注意，只有当 map 容器中确实存有包含该指定键的键值对，借助重载的 [ ] 运算符才能成功获取该键对应的值；反之，若当前 map 容器中没有包含该指定键的键值对，则此时使用 [ ] 运算符将不再是访问容器中的元素，而变成了向该 map 容器中增添一个键值对。 //创建并初始化 map 容器 std::mapmyMap{ {\"STL教程\",\"http://c.biancheng.net/stl/\"}, {\"C语言教程\",\"http://c.biancheng.net/c/\"}, {\"Java教程\",\"http://c.biancheng.net/java/\"} }; string cValue = myMap[\"C语言教程\"]; cout 除了借助 [ ] 运算符获取 map 容器中指定键对应的值，还可以使用 at() 成员方法。和前一种方法相比，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出 out_of_range 异常。 //创建并初始化 map 容器 std::mapmyMap{ {\"STL教程\",\"http://c.biancheng.net/stl/\"}, {\"C语言教程\",\"http://c.biancheng.net/c/\"}, {\"Java教程\",\"http://c.biancheng.net/java/\"} }; cout 如果以上方法都不适用，我们还可以遍历整个 map 容器，找到包含指定键的键值对，进而获取该键对应的值。 //创建并初始化 map 容器 std::mapmyMap{ {\"STL教程\",\"http://c.biancheng.net/stl/\"}, {\"C语言教程\",\"http://c.biancheng.net/c/\"}, {\"Java教程\",\"http://c.biancheng.net/java/\"} }; for (auto iter = myMap.begin(); iter != myMap.end(); ++iter) { //调用 string 类的 compare() 方法，找到一个键和指定字符串相同的键值对 if (!iter->first.compare(\"C语言教程\")) { cout first second map-map insert()插入数据 向map容器的指定位置插入新键值对 //以普通引用的方式传递 val 参数 iterator insert (const_iterator position, const value_type& val); //以右值引用的方式传递 val 键值对参数 template iterator insert (const_iterator position, P&& val); 其中 val 为要插入的键值对变量。注意，和第 1 种方式的语法格式不同，这里 insert() 方法返回的是迭代器，而不再是 pair 对象： 如果插入成功，insert() 方法会返回一个指向 map 容器中已插入键值对的迭代器； 如果插入失败，insert() 方法同样会返回一个迭代器，该迭代器指向 map 容器中和 val 具有相同键的那个键值对。 示例: //创建一个空 map 容器 std::map mymap; //创建一个真实存在的键值对变量 std::pair STL = { \"STL教程\",\"http://c.biancheng.net/stl/\" }; //指定要插入的位置 std::map::iterator it = mymap.begin(); //向 it 位置以普通引用的方式插入 STL auto iter1 = mymap.insert(it, STL); cout first second (\"C语言教程\", \"http://c.biancheng.net/c/\")); cout first second (\"STL教程\", \"http://c.biancheng.net/java/\")); 利用insert() 方法向当前 map 容器中插入其它 map 容器指定区域内的所有键值对 template void insert (InputIterator first, InputIterator last); 其中 first 和 last 都是迭代器，它们的组合可以表示某 map 容器中的指定区域。 示例: //创建并初始化 map 容器 std::mapmymap{ {\"STL教程\",\"http://c.biancheng.net/stl/\"}, {\"C语言教程\",\"http://c.biancheng.net/c/\"}, {\"Java教程\",\"http://c.biancheng.net/java/\"} }; //创建一个空 map 容器 std::mapcopymap; //指定插入区域 std::map::iterator first = ++mymap.begin(); std::map::iterator last = mymap.end(); //将区域内的键值对插入到 copymap 中 copymap.insert(first, last); 1234567891011 利用insert() 方法一次向 map 容器中插入多个键值对 void insert ({val1, val2, ...}); 其中，vali 都表示的是键值对变量。 示例: //创建空的 map 容器 std::mapmymap; //向 mymap 容器中添加 3 个键值对 mymap.insert({ {\"STL教程\", \"http://c.biancheng.net/stl/\"}, { \"C语言教程\",\"http://c.biancheng.net/c/\" }, { \"Java教程\",\"http://c.biancheng.net/java/\" } }); emplace(函数) 实现相同的插入操作，无论是用 emplace() 还是 emplace_hont()，都比 insert() 方法的效率高. 和 insert() 方法相比，emplace() 和 emplace_hint() 方法的使用要简单很多，因为它们各自只有一种语法格式。 template pair emplace (Args&&... args); 参数 (Args&&… args) 指的是，这里只需要将创建新键值对所需的数据作为参数直接传入即可，此方法可以自行利用这些数据构建出指定的键值对。 另外，该方法的返回值也是一个 pair 对象，其中 pair.first 为一个迭代器，pair.second 为一个 bool 类型变量： 当该方法将键值对成功插入到 map 容器中时，其返回的迭代器指向该新插入的键值对，同时 bool 变量的值为 true； 当插入失败时，则表明 map 容器中存在具有相同键的键值对，此时返回的迭代器指向此具有相同键的键值对，同时 bool 变量的值为 false。 示例: //创建并初始化 map 容器 std::mapmymap; //插入键值对 pair::iterator, bool> ret = mymap.emplace(\"STL教程\", \"http://c.biancheng.net/stl/\"); cout first second \" first second \" first second \" 3. multimap容器 multimap容器与map容器比较相似，multimap 容器也用于存储 pair 类型的键值对（其中 K 表示键的类型，T 表示值的类型），其中各个键值对的键的值不能做修改；并且，该容器也会自行根据键的大小对存储的所有键值对做排序操作。和 map 容器的区别在于，multimap 容器中可以同时存储多（≥2）个键相同的键值对。 multimap-使用前 和 map 容器一样，实现 multimap 容器的类模板也定义在头文件，并位于 std 命名空间中。因此，在使用 multimap 容器前，程序应包含如下代码： #include using namespace std; multimap-创建与初始化 创建一个空的map容器 std::multimapmymultimap; 在创建map容器的同时进行初始化 //创建并初始化 multimap 容器 multimapmymultimap{ {\"C语言教程\", \"http://c.biancheng.net/c/\"}, {\"Python教程\", \"http://c.biancheng.net/python/\"}, {\"STL教程\", \"http://c.biancheng.net/stl/\"} }; 利用已有的map容器创建新的map容器 multimapnewmultimap(mymultimap); 利用已有map容器中的部分键值对创建新的map容器 //创建并初始化 multimap 容器 multimapmymultimap{ {\"C语言教程\", \"http://c.biancheng.net/c/\"}, {\"Python教程\", \"http://c.biancheng.net/python/\"}, {\"STL教程\", \"http://c.biancheng.net/stl/\"} }; multimapnewmultimap(++mymultimap.begin(), mymultimap.end()); 在以上几种创建 map 容器的基础上，我们都可以手动修改 map 容器的排序规则。默认情况下，map 容器调用 std::less 规则，根据容器内各键值对的键的大小，对所有键值对做升序排序。 //以下两行等价 multimapmymultimap{ {'a',1},{'b',2} }; multimap>mymultimap{ {'a',1},{'b',2} }; 下面程序利用了 STL 模板库提供的std::greater排序函数，实现令 multimap 容器对存储的键值对做降序排序： multimap>mymultimap{ {'a',1},{'b',2} }; multimap-multimap 容器常用成员方法 成员方法 功能 begin() 返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 end() 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 rbegin() 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 rend() 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 find(key) 在 multimap 容器中查找首个键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 lower_bound(key) 返回一个指向当前 multimap 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 upper_bound(key) 返回一个指向当前 multimap 容器中第一个大于 key 的键值对的迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 equal_range(key) 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对。 empty() 若容器为空，则返回 true；否则 false。 size() 返回当前 multimap 容器中存有键值对的个数。 max_size() 返回 multimap 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。 insert() 向 multimap 容器中插入键值对。 erase() 删除 multimap 容器指定位置、指定键（key）值或者指定区域内的键值对。 swap() 交换 2 个 multimap 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。 clear() 清空 multimap 容器中所有的键值对，使 multimap 容器的 size() 为 0。 emplace() 在当前 multimap 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。 emplace_hint() 在本质上和 emplace() 在 multimap 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。 count(key) 在当前 multimap 容器中，查找键为 key 的键值对的个数并返回。 4. set 和 map、multimap 容器不同，使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。 set-使用前 值得一提的是，set 容器定义于头文件，并位于 std 命名空间中。因此如果想在程序中使用 set 容器，该程序代码应先包含如下语句： #include using namespace std; set 容器的类模板定义如下： template , // 指定 set 容器内部的排序规则 class Alloc = allocator // 指定分配器对象的类型 > class set; 注意，由于 set 容器存储的各个键值对，其键和值完全相同，也就意味着它们的类型相同，因此 set 容器类模板的定义中，仅有第 1 个参数用于设定存储数据的类型。 对于 set 类模板中的 3 个参数，后 2 个参数自带默认值，且几乎所有场景中只需使用前 2 个参数，第 3 个参数不会用到。 set-创建与初始化 创建空的set容器 std::set myset; 创建set容器的同时进行初始化 std::set myset{\"http://c.biancheng.net/java/\", \"http://c.biancheng.net/stl/\", \"http://c.biancheng.net/python/\"}; 利用已有set容器创建新的set容器(拷贝) std::set copyset(myset); //等同于 //std::set copyset = myset 利用已有set容器的部分元素创建新的set容器 std::set myset{ \"http://c.biancheng.net/java/\", \"http://c.biancheng.net/stl/\", \"http://c.biancheng.net/python/\" }; std::set copyset(++myset.begin(), myset.end()); 创建set容器的同时修改排序规则 std::set > myset{ \"http://c.biancheng.net/java/\", \"http://c.biancheng.net/stl/\", \"http://c.biancheng.net/python/\"}; set-set 容器常用成员方法 常用函数已加粗标出 成员方法 功能 begin() 返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 end() 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 rbegin() 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 rend() 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 find(val) 在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 lower_bound(val) 返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 upper_bound(val) 返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 equal_range(val) 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。 empty() 若容器为空，则返回 true；否则 false。 size() 返回当前 set 容器中存有元素的个数。 max_size() 返回 set 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。 insert() 向 set 容器中插入元素。 erase() 删除 set 容器中存储的元素。 swap() 交换 2 个 set 容器中存储的所有元素。这意味着，操作的 2 个 set 容器的类型必须相同。 clear() 清空 set 容器中所有的元素，即令 set 容器的 size() 为 0。 emplace() 在当前 set 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。 emplace_hint() 在本质上和 emplace() 在 set 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数 count(val) 在当前 set 容器中，查找值为 val 的元素的个数，并返回。注意，由于 set 容器中各元素的值是唯一的，因此该函数的返回值最大为 1。 emplace()系列函数比inser()系列函数效率更高,具体原因呢这里不再展开,看参考之前的讨论 set-set迭代器 和 map 容器不同，C++ STL 中的 set 容器类模板中未提供 at() 成员函数，也未对 [] 运算符进行重载。因此，要想访问 set 容器中存储的元素，只能借助 set 容器的迭代器。 值得一提的是，C++ STL 标准库为 set 容器配置的迭代器类型为双向迭代器。这意味着，假设 p 为此类型的迭代器，则其只能进行 ++p、p++、–p、p–、*p 操作，并且 2 个双向迭代器之间做比较，也只能使用 == 或者 != 运算符。 set-insert()函数详解 直接传值 //普通引用方式传参 pair insert (const value_type& val); //右值引用方式传参 pair insert (value_type&& val); 其中，val 表示要添加的新元素，该方法的返回值为 pair 类型。 以上 2 种格式的区别仅在于传递参数的方式不同，即第一种采用普通引用的方式传参，而第二种采用右值引用的方式传参。右值引用为 C++ 11 新添加的一种引用方式，可阅读《C++ 右值引用》一文做详细了解。 可以看到，以上 2 种语法格式的 insert() 方法，返回的都是 pair 类型的值，其包含 2 个数据，一个迭代器和一个 bool 值： 当向 set 容器添加元素成功时，该迭代器指向 set 容器新添加的元素，bool 类型的值为 true； 如果添加失败，即证明原 set 容器中已存有相同的元素，此时返回的迭代器就指向容器中相同的此元素，同时 bool 类型的值为 false。 示例: //创建并初始化set容器 std::set myset; //准备接受 insert() 的返回值 pair::iterator, bool> retpair; //采用普通引用传值方式 string str = \"http://c.biancheng.net/stl/\"; retpair = myset.insert(str); 将元素插入到指定位置 //以普通引用的方式传递 val 值 iterator insert (const_iterator position, const value_type& val); //以右值引用的方式传递 val 值 iterator insert (const_iterator position, value_type&& val); 以上 2 种语法格式中，insert() 函数的返回值为迭代器： 当向 set 容器添加元素成功时，该迭代器指向容器中新添加的元素； 当添加失败时，证明原 set 容器中已有相同的元素，该迭代器就指向 set 容器中相同的这个元素。 示例: //创建并初始化set容器 std::set myset; //准备接受 insert() 的返回值 set::iterator iter; //采用普通引用传值方式 string str = \"http://c.biancheng.net/stl/\"; iter = myset.insert(myset.begin(),str); //采用右值引用传值方式 iter = myset.insert(myset.end(),\"http://c.biancheng.net/python/\"); 向当前set容器插入其他set容器指定区域内的所有元素(两个set容器存储的元素类型要一致) template void insert (InputIterator first, InputIterator last); 其中 first 和 last 都是迭代器，它们的组合 [first,last) 可以表示另一 set 容器中的一块区域，该区域包括 first 迭代器指向的元素，但不包含 last 迭代器指向的元素。 示例: //创建并初始化set容器 std::set myset{ \"http://c.biancheng.net/stl/\", \"http://c.biancheng.net/python/\", \"http://c.biancheng.net/java/\" }; //创建一个同类型的空 set 容器 std::set otherset; //利用 myset 初始化 otherset otherset.insert(++myset.begin(), myset.end()); 一次向set容器中添加多个元素 void insert ( {E1, E2,...,En} ); 其中，Ei 表示新添加的元素。 示例: //创建并初始化set容器 std::set myset; //向 myset 中添加多个元素 myset.insert({ \"http://c.biancheng.net/stl/\", \"http://c.biancheng.net/python/\", \"http://c.biancheng.net/java/\" }); set-set删除数据 如果想删除 set 容器存储的元素，可以选择用 erase() 或者 clear() 成员方法。 set 类模板中，erase() 方法有 3 种语法格式，分别如下： //删除 set 容器中值为 val 的元素 size_type erase (const value_type& val); //删除 position 迭代器指向的元素 iterator erase (const_iterator position); //删除 [first,last) 区间内的所有元素 iterator erase (const_iterator first, const_iterator last); 其中，第 1 种格式的 erase() 方法，其返回值为一个整数，表示成功删除的元素个数；后 2 种格式的 erase() 方法，返回值都是迭代器，其指向的是 set 容器中删除元素之后的第一个元素。 注意，如果要删除的元素就是 set 容器最后一个元素，则 erase() 方法返回的迭代器就指向新 set 容器中最后一个元素之后的位置（等价于 end() 方法返回的迭代器）。 示例: //创建并初始化 set 容器 std::setmyset{1,2,3,4,5}; cout ::iterator iter = myset.erase(myset.begin()); //删除元素 1，myset={3,4,5} cout \" ::iterator iter2 = myset.erase(myset.begin(), --myset.end());//删除元素 3,4，myset={5} cout \" 如果需要删除 set 容器中存储的所有元素，可以使用 clear() 成员方法。该方法的语法格式如下： void clear(); 示例: //创建并初始化 set 容器 std::setmyset{1,2,3,4,5}; cout 5.multiset multiset-使用前 和 set 类模板一样，multiset 类模板也定义在头文件，并位于 std 命名空间中。这意味着，如果想在程序中使用 multiset 容器，该程序代码应包含如下语句： #include using namespace std; multiset 容器类模板的定义如下所示： template , // 指定容器内部的排序规则 class Alloc = allocator > // 指定分配器对象的类型 > class multiset; 显然，multiset 类模板有 3 个参数，其中后 2 个参数自带有默认值。值得一提的是，在实际使用中，我们最多只需要使用前 2 个参数即可，第 3 个参数不会用到。 multiset-创建与初始化 创建空的multiset容器 std::multiset mymultiset; 创建容器的同时进行初始化 std::multiset mymultiset{ \"http://c.biancheng.net/java/\", \"http://c.biancheng.net/stl/\", \"http://c.biancheng.net/python/\" }; 利用已有的multiset容器创建新的容器(拷贝) std::multiset copymultiset(mymultiset); //等同于 //std::multiset copymultiset = mymultiset; 利用已有的multiset容器的部分元素创建新的容器 std::multiset mymultiset{ \"http://c.biancheng.net/java/\", \"http://c.biancheng.net/stl/\", \"http://c.biancheng.net/python/\" }; std::set copymultiset(++mymultiset.begin(), mymultiset.end()); 创建容器的同时修改排序规则 std::multiset > mymultiset{ \"http://c.biancheng.net/java/\", \"http://c.biancheng.net/stl/\", \"http://c.biancheng.net/python/\" }; multiset-multiset 容器常用成员方法 重要方法已加粗标出 成员方法 功能 begin() 返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 end() 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 rbegin() 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 rend() 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 find(val) 在 multiset 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 lower_bound(val) 返回一个指向当前 multiset 容器中第一个大于或等于 val 的元素的双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 upper_bound(val) 返回一个指向当前 multiset 容器中第一个大于 val 的元素的迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 equal_range(val) 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含所有值为 val 的元素。 empty() 若容器为空，则返回 true；否则 false。 size() 返回当前 multiset 容器中存有元素的个数。 max_size() 返回 multiset 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。 insert() 向 multiset 容器中插入元素。 erase() 删除 multiset 容器中存储的指定元素。 swap() 交换 2 个 multiset 容器中存储的所有元素。这意味着，操作的 2 个 multiset 容器的类型必须相同。 clear() 清空 multiset 容器中所有的元素，即令 multiset 容器的 size() 为 0。 emplace() 在当前 multiset 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。 emplace_hint() 本质上和 emplace() 在 multiset 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。 count(val) 在当前 multiset 容器中，查找值为 val 的元素的个数，并返回。 注意，虽然 multiset 容器和 set 容器拥有的成员方法完全相同，但由于 multiset 容器允许存储多个值相同的元素，因此诸如 count()、find()、lower_bound()、upper_bound()、equal_range()等方法，更常用于 multiset 容器。 1.3 无序关联式容器 和关联式容器一样，无序容器也使用键值对（pair 类型）的方式存储数据。不过，本教程将二者分开进行讲解，因为它们有本质上的不同： 关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构； 无序容器的底层实现采用的是哈希表的存储结构。 C++ STL 底层采用哈希表实现无序容器时，会将所有数据存储到一整块连续的内存空间中，并且当数据存储位置发生冲突时，解决方法选用的是“链地址法”（又称“开链法”）。 基于底层实现采用了不同的数据结构，因此和关联式容器相比，无序容器具有以下 2 个特点： 无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键， 和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。 无序容器种类 无序容器 功能 unordered_map 存储键值对 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。 unordered_multimap 和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。 unordered_set 不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。 unordered_multiset 和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。 注意:以上 4 种无序容器的名称，仅是在前面所学的 4 种关联式容器名称的基础上，添加了 “unordered_”。如果读者已经学完了 map、multimap、set 和 multiset 容器不难发现，以 map 和 unordered_map 为例，其实它们仅有一个区别，即 map 容器内存会对存储的键值对进行排序，而 unordered_map 不会。 针对有序容器和无序容器的使用选择，总的来说，实际场景中如果涉及大量遍历容器的操作，建议首选关联式容器；反之，如果更多的操作是通过键获取对应的值，则应首选无序容器。 1. unordered_map unordered_map-使用前 unordered_map 容器在头文件中，并位于 std 命名空间中。因此，如果想使用该容器，代码中应包含如下语句： #include using namespace std; unordered_map 容器模板的定义如下所示： template , //容器内部存储键值对所用的哈希函数 class Pred = equal_to, //判断各个键值对键相同的规则 class Alloc = allocator > // 指定分配器对象的类型 > class unordered_map; 以上 5 个参数中，必须显式给前 2 个参数传值，并且除特殊情况外，最多只需要使用前 4 个参数，各自的含义和功能如表 1 所示。 unordered_map - 创建与初始化 创建一个空的unordered_map容器 std::unordered_mapumap; 在创建unordered_map容器的同时进行初始化 std::unordered_mapumap{ {\"C语言教程\",10},{\"STL教程\",20} }; 利用已有的unordered_map容器创建新的map容器 std::unordered_mapumap2(umap); 利用已有map容器中的部分键值对创建新的map容器 std::unordered_mapumap{ {\"C语言教程\",10},{\"STL教程\",20} }; std::unordered_mapumap2(++umap.begin(), umap.end()); unordered_map - unordered_map类模板成员方法 unordered_map类模板成员方法 成员方法 功能 begin() 返回指向容器中第一个键值对的正向迭代器。 end() 返回指向容器中最后一个键值对之后位置的正向迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。 empty() 若容器为空，则返回 true；否则 false。 size() 返回当前容器中存有键值对的个数。 max_size() 返回容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。 operator[key] 该模板类中重载了 [] 运算符，其功能是可以向访问数组中元素那样，只要给定某个键值对的键 key，就可以获取该键对应的值。注意，如果当前容器中没有以 key 为键的键值对，则其会使用该键向当前容器中插入一个新键值对。 at(key) 返回容器中存储的键 key 对应的值，如果 key 不存在，则会抛出 out_of_range 异常。 find(key) 查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。 count(key) 在容器中查找以 key 键的键值对的个数。 equal_range(key) 返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。 emplace() 向容器中添加新键值对，效率比 insert() 方法高。 emplace_hint() 向容器中添加新键值对，效率比 insert() 方法高。 insert() 向容器中添加新键值对。 erase() 删除指定键值对。 clear() 清空容器，即删除容器中存储的所有键值对。 swap() 交换 2 个 unordered_map 容器存储的键值对，前提是必须保证这 2 个容器的类型完全相等。 bucket_count() 返回当前容器底层存储键值对时，使用桶（一个线性链表代表一个桶）的数量。 max_bucket_count() 返回当前系统中，unordered_map 容器底层最多可以使用多少桶。 bucket_size(n) 返回第 n 个桶中存储键值对的数量。 bucket(key) 返回以 key 为键的键值对所在桶的编号。 load_factor() 返回 unordered_map 容器中当前的负载因子。负载因子，指的是的当前容器中存储键值对的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。 max_load_factor() 返回或者设置当前 unordered_map 容器的负载因子。 rehash(n) 将当前容器底层使用桶的数量设置为 n。 reserve() 将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。 hash_function() 返回当前容器使用的哈希函数对象。 unordered_map - unordered_map获取元素 使用重载运算符[ ] unordered_map umap{ {\"Python教程\",\"http://c.biancheng.net/python/\"}, {\"Java教程\",\"http://c.biancheng.net/java/\"}, {\"Linux教程\",\"http://c.biancheng.net/linux/\"} }; //获取 \"Java教程\" 对应的值 string str = umap[\"Java教程\"]; cout 注意:若当前容器中并没有存储以 [ ] 运算符内指定的元素作为键的键值对，则此时 [ ] 运算符的功能将转变为：向当前容器中添加以目标元素为键的键值对。 使用at函数 unordered_map umap{ {\"Python教程\",\"http://c.biancheng.net/python/\"}, {\"Java教程\",\"http://c.biancheng.net/java/\"}, {\"Linux教程\",\"http://c.biancheng.net/linux/\"} }; //获取指定键对应的值 string str = umap.at(\"Python教程\"); cout 注意:和使用 [ ] 运算符一样，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出out_of_range异常。 使用find()函数 //创建 umap 容器 unordered_map umap{ {\"Python教程\",\"http://c.biancheng.net/python/\"}, {\"Java教程\",\"http://c.biancheng.net/java/\"}, {\"Linux教程\",\"http://c.biancheng.net/linux/\"} }; //查找成功 unordered_map::iterator iter = umap.find(\"Python教程\"); cout first second ::iterator iter2 = umap.find(\"GO教程\"); if (iter2 == umap.end()) { cout 通过 find() 方法得到的是一个正向迭代器，该迭代器的指向分以下 2 种情况： 当 find() 方法成功找到以指定元素作为键的键值对时，其返回的迭代器就指向该键值对； 当 find() 方法查找失败时，其返回的迭代器和 end() 方法返回的迭代器一样，指向容器中最后一个键值对之后的位置。 通过迭代器遍历整个容器 //创建 umap 容器 unordered_map umap{ {\"Python教程\",\"http://c.biancheng.net/python/\"}, {\"Java教程\",\"http://c.biancheng.net/java/\"}, {\"Linux教程\",\"http://c.biancheng.net/linux/\"} }; //遍历整个容器中存储的键值对 for (auto iter = umap.begin(); iter != umap.end(); ++iter) { //判断当前的键值对是否就是要找的 if (!iter->first.compare(\"Java教程\")) { cout second unordered_map -insert() insert() 方法可以将 pair 类型的键值对元素添加到 unordered_map 容器中 //以普通方式传递参数 pair insert ( const value_type& val ); //以右值引用的方式传递参数 template pair insert ( P&& val ); 参数 val 表示要添加到容器中的目标键值对元素；该方法的返回值为 pair类型值，内部包含一个 iterator 迭代器和 bool 变量： 当 insert() 将 val 成功添加到容器中时，返回的迭代器指向新添加的键值对，bool 值为 True； 当 insert() 添加键值对失败时，意味着当前容器中本就存储有和要添加键值对的键相等的键值对，这种情况下，返回的迭代器将指向这个导致插入操作失败的迭代器，bool 值为 False。 示例: //创建一个空 map 容器 std::map mymap; //创建一个真实存在的键值对变量 std::pair STL = { \"STL教程\",\"http://c.biancheng.net/stl/\" }; //指定要插入的位置 std::map::iterator it = mymap.begin(); //向 it 位置以普通引用的方式插入 STL auto iter1 = mymap.insert(it, STL); cout first second (\"C语言教程\", \"http://c.biancheng.net/c/\")); cout first second (\"STL教程\", \"http://c.biancheng.net/java/\")); insert() 方法还可以指定新键值对要添加到容器中的位置 //以普通方式传递 val 参数 iterator insert ( const_iterator hint, const value_type& val ); //以右值引用方法传递 val 参数 template iterator insert ( const_iterator hint, P&& val ); 其中 first 和 last 都是迭代器，它们的组合可以表示某 map 容器中的指定区域。 示例: //创建空 umap 容器 unordered_map umap; //构建要添加的键值对 std::pairmypair(\"STL教程\", \"http://c.biancheng.net/stl/\"); //创建接收 insert() 方法返回值的迭代器类型变量 unordered_map::iterator iter; //调用第一种语法格式 iter = umap.insert(umap.begin(), mypair); //调用第二种语法格式 iter = umap.insert(umap.begin(),std::make_pair(\"Python教程\", \"http://c.biancheng.net/python/\")); insert() 方法还支持将某一个 unordered_map 容器中指定区域内的所有键值对，复制到另一个 unordered_map 容器中 void insert ({val1, val2, ...}); 其中，vali 都表示的是键值对变量。 示例: //创建空的 map 容器 std::mapmymap; //向 mymap 容器中添加 3 个键值对 mymap.insert({ {\"STL教程\", \"http://c.biancheng.net/stl/\"}, { \"C语言教程\",\"http://c.biancheng.net/c/\" }, { \"Java教程\",\"http://c.biancheng.net/java/\" } }); insert() 方法还支持一次向 unordered_map 容器添加多个键值对，其语法格式如下： void insert ( initializer_list il ); 参数 (Args&&… args) 指的是，这里只需要将创建新键值对所需的数据作为参数直接传入即可，此方法可以自行利用这些数据构建出指定的键值对。 另外，该方法的返回值也是一个 pair 对象，其中 pair.first 为一个迭代器，pair.second 为一个 bool 类型变量： 当该方法将键值对成功插入到 map 容器中时，其返回的迭代器指向该新插入的键值对，同时 bool 变量的值为 true； 当插入失败时，则表明 map 容器中存在具有相同键的键值对，此时返回的迭代器指向此具有相同键的键值对，同时 bool 变量的值为 false。 示例: //创建空的 umap 容器 unordered_map umap; //向 umap 容器同时添加多个键值对 umap.insert({ {\"STL教程\",\"http://c.biancheng.net/stl/\"}, {\"Python教程\",\"http://c.biancheng.net/python/\"}, {\"Java教程\",\"http://c.biancheng.net/java/\"} }); unordered_map-unordered_map删除元素 C++ STL 标准库为了方便用户可以随时删除 unordered_map 容器中存储的键值对，unordered_map 容器类模板中提供了以下 2 个成员方法： erase()：删除 unordered_map 容器中指定的键值对； clear()：删除 unordered_map 容器中所有的键值对，即清空容器。 erase()函数 erase() 方法可以接受一个正向迭代器，并删除该迭代器指向的键值对。该方法的语法格式如下 iterator erase ( const_iterator position ); 示例: cout ::iterator ret; //删除容器中第一个键值对 ret = umap.erase(umap.begin()); 我们还可以直接将要删除键值对的键作为参数直接传给 erase() 方法，该方法会自行去 unordered_map 容器中找和给定键相同的键值对，将其删除。 size_type erase ( const key_type& k ); int delNum = umap.erase(\"Python教程\"); 除了支持删除 unordered_map 容器中指定的某个键值对，erase() 方法还支持一次删除指定范围内的所有键值对 iterator erase ( const_iterator first, const_iterator last ); //创建 umap 容器 unordered_map umap{ {\"STL教程\", \"http://c.biancheng.net/stl/\"}, {\"Python教程\", \"http://c.biancheng.net/python/\"}, {\"Java教程\", \"http://c.biancheng.net/java/\"} }; //first 指向第一个键值对 unordered_map::iterator first = umap.begin(); //last 指向最后一个键值对 unordered_map::iterator last = --umap.end(); //删除[fist,last)范围内的键值对 auto ret = umap.erase(first, last); 2. unordered_multimap unordered_multimap-使用前 STL 标准库中实现 unordered_multimap 容器的模板类并没有定义在以自己名称命名的头文件中，而是和 unordered_map 容器一样，定义在头文件，且位于 std 命名空间中。因此，在使用 unordered_multimap 容器之前，程序中应包含如下 2 行代码： #include using namespace std; unordered_multimap 容器模板的定义如下所示： template , //底层存储键值对时采用的哈希函数 class Pred = equal_to, //判断各个键值对的键相等的规则 class Alloc = allocator > // 指定分配器对象的类型 > class unordered_multimap; 以上 5 个参数中，必须显式给前 2 个参数传值，且除极个别的情况外，最多只使用前 4 个参数 unordered_multimap-创建与初始化 创建一个空的unordered_multimap容器 std::unordered_multimapmyummap; 在创建unordered_multimap容器的同时进行初始化 std::unordered_multimapumap{ {\"C语言教程\",10},{\"STL教程\",20} }; 利用已有的unordered_multimap容器创建新的map容器 std::unordered_mapmyummap2(myummap); 利用已有unordered_multimap容器中的部分键值对创建新的map容器 std::unordered_multimapmyummap{ {\"C语言教程\",10},{\"STL教程\",20} }; std::unordered_multimapmyummap2(++myummap.begin(), umap.end()); unordered_multimap类模板成员方法 成员方法 功能 begin() 返回指向容器中第一个键值对的正向迭代器。 end() 返回指向容器中最后一个键值对之后位置的正向迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。 empty() 若容器为空，则返回 true；否则 false。 size() 返回当前容器中存有键值对的个数。 max_size() 返回容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。 find(key) 查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。 count(key) 在容器中查找以 key 键的键值对的个数。 equal_range(key) 返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。 emplace() 向容器中添加新键值对，效率比 insert() 方法高。 emplace_hint() 向容器中添加新键值对，效率比 insert() 方法高。 insert() 向容器中添加新键值对。 erase() 删除指定键值对。 clear() 清空容器，即删除容器中存储的所有键值对。 swap() 交换 2 个 unordered_multimap 容器存储的键值对，前提是必须保证这 2 个容器的类型完全相等。 bucket_count() 返回当前容器底层存储键值对时，使用桶（一个线性链表代表一个桶）的数量。 max_bucket_count() 返回当前系统中，unordered_multimap 容器底层最多可以使用多少桶。 bucket_size(n) 返回第 n 个桶中存储键值对的数量。 bucket(key) 返回以 key 为键的键值对所在桶的编号。 load_factor() 返回 unordered_multimap 容器中当前的负载因子。负载因子，指的是的当前容器中存储键值对的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。 max_load_factor() 返回或者设置当前 unordered_multimap 容器的负载因子。 rehash(n) 将当前容器底层使用桶的数量设置为 n。 reserve() 将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。 hash_function() 返回当前容器使用的哈希函数对象。 3. unordered_set unordered_set-使用前 实现 unordered_set 容器的模板类定义在头文件，并位于 std 命名空间中。这意味着，如果程序中需要使用该类型容器，则首先应该包含如下代码： #include using namespace std; unordered_set 容器的类模板定义如下： template , //确定元素存储位置所用的哈希函数 class Pred = equal_to, //判断各个元素是否相等所用的函数 class Alloc = allocator //指定分配器对象的类型 > class unordered_set; 可以看到，以上 4 个参数中，只有第一个参数没有默认值，这意味着如果我们想创建一个 unordered_set 容器，至少需要手动传递 1 个参数。事实上，在 99% 的实际场景中最多只需要使用前 3 个参数（各自含义如表 1 所示），最后一个参数保持默认值即可。 unordered_set-创建与初始化 创建一个空的unordered_set 容器 std::unordered_set uset; 在创建unordered_set 容器的同时进行初始化 std::unordered_set uset{ \"http://c.biancheng.net/c/\", \"http://c.biancheng.net/java/\", \"http://c.biancheng.net/linux/\" }; 利用已有的unordered_set 容器创建新的unordered_set 容器 std::unordered_set uset2(uset); 利用已有unordered_set 容器中的部分键值对创建新的unordered_set 容器 //传入 2 个迭代器， std::unordered_set uset2(++uset.begin(),uset.end()); unordered_set - unordered_set 类模板成员方法 成员方法 功能 begin() 返回指向容器中第一个元素的正向迭代器。 end(); 返回指向容器中最后一个元素之后位置的正向迭代器。 cbegin() 和 begin() 功能相同，只不过其返回的是 const 类型的正向迭代器。 cend() 和 end() 功能相同，只不过其返回的是 const 类型的正向迭代器。 empty() 若容器为空，则返回 true；否则 false。 size() 返回当前容器中存有元素的个数。 max_size() 返回容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。 find(key) 查找以值为 key 的元素，如果找到，则返回一个指向该元素的正向迭代器；反之，则返回一个指向容器中最后一个元素之后位置的迭代器（如果 end() 方法返回的迭代器）。 count(key) 在容器中查找值为 key 的元素的个数。 equal_range(key) 返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中值为 key 的元素所在的范围。 emplace() 向容器中添加新元素，效率比 insert() 方法高。 emplace_hint() 向容器中添加新元素，效率比 insert() 方法高。 insert() 向容器中添加新元素。 erase() 删除指定元素。 clear() 清空容器，即删除容器中存储的所有元素。 swap() 交换 2 个 unordered_map 容器存储的元素，前提是必须保证这 2 个容器的类型完全相等。 bucket_count() 返回当前容器底层存储元素时，使用桶（一个线性链表代表一个桶）的数量。 max_bucket_count() 返回当前系统中，unordered_map 容器底层最多可以使用多少桶。 bucket_size(n) 返回第 n 个桶中存储元素的数量。 bucket(key) 返回值为 key 的元素所在桶的编号。 load_factor() 返回 unordered_map 容器中当前的负载因子。负载因子，指的是的当前容器中存储元素的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。 max_load_factor() 返回或者设置当前 unordered_map 容器的负载因子。 rehash(n) 将当前容器底层使用桶的数量设置为 n。 reserve() 将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。 hash_function() 返回当前容器使用的哈希函数对象。 4. unordered_multiset unordered_multiset-使用前 实现 unordered_multiset 容器的模板类并没有定义在以该容器名命名的文件中，而是和 unordered_set 容器共用同一个头文件，并且也位于 std 命名空间。因此，如果程序中需要使用该类型容器，应包含如下代码： #include using namespace std; unordered_multiset 容器类模板的定义如下： 纯文本复制 template , //确定元素存储位置所用的哈希函数 class Pred = equal_to, //判断各个元素是否相等所用的函数 class Alloc = allocator //指定分配器对象的类型 > class unordered_multiset; 需要说明的是，在 99% 的实际场景中，最多只需要使用前 3 个参数（各自含义如表 1 所示），最后一个参数保持默认值即可。 unordered_multiset-创建与初始化 创建一个空的unordered_multiset 容器 std::unordered_multiset umset; 在创建unordered_multiset 容器的同时进行初始化 std::unordered_multiset umset{ \"http://c.biancheng.net/c/\", \"http://c.biancheng.net/java/\", \"http://c.biancheng.net/linux/\" }; 利用已有的unordered_multiset 容器创建新的unordered_multiset 容器 std::unordered_multiset umset2(umset); 利用已有unordered_set 容器中的部分键值对创建新的unordered_set 容器 //传入 2 个迭代器， std::unordered_multiset umset2(++umset.begin(), umset.end()); unordered_set 类模板成员方法 成员方法 功能 begin() 返回指向容器中第一个元素的正向迭代器。 end(); 返回指向容器中最后一个元素之后位置的正向迭代器。 cbegin() 和 begin() 功能相同，只不过其返回的是 const 类型的正向迭代器。 cend() 和 end() 功能相同，只不过其返回的是 const 类型的正向迭代器。 empty() 若容器为空，则返回 true；否则 false。 size() 返回当前容器中存有元素的个数。 max_size() 返回容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。 find(key) 查找以值为 key 的元素，如果找到，则返回一个指向该元素的正向迭代器；反之，则返回一个指向容器中最后一个元素之后位置的迭代器（如果 end() 方法返回的迭代器）。 count(key) 在容器中查找值为 key 的元素的个数。 equal_range(key) 返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中值为 key 的元素所在的范围。 emplace() 向容器中添加新元素，效率比 insert() 方法高。 emplace_hint() 向容器中添加新元素，效率比 insert() 方法高。 insert() 向容器中添加新元素。 erase() 删除指定元素。 clear() 清空容器，即删除容器中存储的所有元素。 swap() 交换 2 个 unordered_multimap 容器存储的元素，前提是必须保证这 2 个容器的类型完全相等。 bucket_count() 返回当前容器底层存储元素时，使用桶（一个线性链表代表一个桶）的数量。 max_bucket_count() 返回当前系统中，容器底层最多可以使用多少桶。 bucket_size(n) 返回第 n 个桶中存储元素的数量。 bucket(key) 返回值为 key 的元素所在桶的编号。 load_factor() 返回容器当前的负载因子。所谓负载因子，指的是的当前容器中存储元素的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。 max_load_factor() 返回或者设置当前 unordered_map 容器的负载因子。 rehash(n) 将当前容器底层使用桶的数量设置为 n。 reserve() 将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。 hash_function() 返回当前容器使用的哈希函数对象。 1.4 其他 1.String String - 创建与初始化 构造 string strs ;//生成空字符串 string s(str);//生成字符串str的复制品 string s(str, stridx) ; //将字符串str中始于stridx的部分作为构造函数的初值 string s(str, strbegin, strlen); //将字符串str中始于strbegin、长度为strlen的部分作为字符串初值 string s(cstr);//以C_string类型cstr作为字符串s的初值 string s(cstr,char_len);//以C_string类型cstr的前char_len个字符串作为字符串s的初值 string s(num, c);//生成一个字符串，包含num个c字符 string s(strs, beg, end) ;//以区间[beg, end]内的字符作为字符串s的初值 析构 ~string() ; //销毁所有内存，释放内存 String - string 类的所有成员函数 函数名称 功能 构造函数 产生或复制字符串 析构函数 销毁字符串 =，assign 赋以新值 Swap 交换两个字符串的内容 + =，append( )，push_back() 添加字符 insert () 插入字符 erase() 删除字符 clear () 移除全部字符 resize () 改变字符数量 replace() 替换字符 + 串联字符串 ==，！ =，，>=，compare() 比较字符串内容 size()，length() 返回字符数量 max_size () 返回字符的最大可能个数 empty () 判断字符串是否为空 capacity () 返回重新分配之前的字符容量 reserve() 保留内存以存储一定数量的字符 [],at() 存取单一字符 >>，getline() 从 stream 中读取某值 将值写入 stream copy() 将内容复制为一个 C - string c_str() 将内容以 C - string 形式返回 data() 将内容以字符数组形式返回 substr() 返回子字符串 find() 搜寻某子字符串或字符 begin( )，end() 提供正向迭代器支持 rbegin()，rend() 提供逆向迭代器支持 get_allocator() 返回配置器 2.栈 栈-使用前 由于 stack 适配器以模板类 stack（其中 T 为存储元素的类型，Container 表示底层容器的类型）的形式位于头文件中，并定义在 std 命名空间里。因此，在创建该容器之前，程序中应包含以下 2 行代码： #include using namespace std; 栈-创建与初始化 创建一个不包含任何元素的 stack 适配器，并采用默认的 deque 基础容器 std::stack values; stack 模板类提供了 2 个参数，通过指定第二个模板类型参数，我们可以使用出 deque 容器外的其它序列式容器，只要该容器支持 empty()、size()、back()、push_back()、pop_back() 这 5 个成员函数即可。 std::stack> values; 可以用一个基础容器来初始化 stack 适配器，只要该容器的类型和 stack 底层使用的基础容器类型相同即可。 std::list values {1, 2, 3}; std::stack> my_stack (values); 可以用一个 stack 适配器来初始化另一个 stack 适配器，只要它们存储的元素类型以及底层采用的基础容器类型相同即可。 std::list values{ 1, 2, 3 }; std::stack> my_stack1(values); std::stack> my_stack=my_stack1; //std::stack> my_stack(my_stack1); 栈-常用函数 stack容器适配器支持的成员函数 成员函数 功能 empty() 当 stack 栈中没有元素时，该成员函数返回 true；反之，返回 false。 size() 返回 stack 栈中存储元素的个数。 top() 返回一个栈顶元素的引用，类型为 T&。如果栈为空，程序会报错。 push(const T& val) 先复制 val，再将 val 副本压入栈顶。这是通过调用底层容器的 push(T&& obj) 以移动元素的方式将其压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。 pop() 弹出栈顶元素。 emplace(arg…) arg… 可以是一个参数，也可以是多个参数，但它们都只用于构造一个对象，并在栈顶直接生成该对象，作为新的栈顶元素。 swap(stack & other_stack) 将两个 stack 适配器中的元素进行互换，需要注意的是，进行互换的 2 个 stack 适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。 3.queue queue- 使用前 queue 容器适配器以模板类 queue（其中 T 为存储元素的类型，Container 表示底层容器的类型）的形式位于头文件中，并定义在 std 命名空间里。因此，在创建该容器之前，程序中应包含以下 2 行代码： #include using namespace std; queue-创建与初始化 创建一个空的 queue 容器适配器，其底层使用的基础容器选择默认的 deque 容器 std::queue values; 手动指定 queue 容器适配器底层采用的基础容器类型 作为 queue 容器适配器的基础容器，其必须提供 front()、back()、push_back()、pop_front()、empty() 和 size() 这几个成员函数，符合条件的序列式容器仅有 deque 和 list。 可以用基础容器来初始化 queue 容器适配器，只要该容器类型和 queue 底层使用的基础容器类型相同即可。 std::deque values{1,2,3}; std::queue my_queue(values); 可以直接通过 queue 容器适配器来初始化另一个 queue 容器适配器，只要它们存储的元素类型以及底层采用的基础容器类型相同即可。 std::deque values{1,2,3}; std::queue my_queue1(values); std::queue my_queue(my_queue1); //或者使用 //std::queue my_queue = my_queue1; queue-queue容器适配器支持的成员函数 成员函数 功能 empty() 如果 queue 中没有元素的话，返回 true。 size() 返回 queue 中元素的个数。 front() 返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 back() 返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 push(const T& obj) 在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。 emplace() 在 queue 的尾部直接添加一个元素。 push(T&& obj) 以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。 pop() 删除 queue 中的第一个元素。 swap(queue &other_queue) 将两个 queue 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 queue 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。 4.priority_queue（优先队列） priority_queue 容器适配器模拟的也是队列这种存储结构，即使用此容器适配器存储元素只能“从一端进（称为队尾），从另一端出（称为队头）”，且每次只能访问 priority_queue 中位于队头的元素。 但是，priority_queue 容器适配器中元素的存和取，遵循的并不是 “First in,First out”（先入先出）原则，而是“First in，Largest out”原则。直白的翻译，指的就是先进队列的元素并不一定先出队列，而是优先级最大的元素最先出队列。 priority_queue-使用前 由于 priority_queue 容器适配器模板位于头文件中，并定义在 std 命名空间里，因此在试图创建该类型容器之前，程序中需包含以下 2 行代码： #include using namespace std; priority_queue-创建与初始化 创建一个空的 priority_queue 容器适配器，第底层采用默认的 vector 容器，排序方式也采用默认的 std::less 方法 std::priority_queue values; 可以使用普通数组或其它容器中指定范围内的数据，对 priority_queue 容器适配器进行初始化 //使用普通数组 int values[]{4,1,3,2}; std::priority_queuecopy_values(values,values+4);//{4,2,3,1} //使用序列式容器 std::arrayvalues{ 4,1,3,2 }; std::priority_queuecopy_values(values.begin(),values.end());//{4,2,3,1} 可以手动指定 priority_queue 使用的底层容器以及排序规则 int values[]{ 4,1,2,3 }; std::priority_queue, std::greater >copy_values(values, values+4);//{1,3,2,4} priority_queue-常用函数 priority_queue 提供的成员函数 成员函数 功能 empty() 如果 priority_queue 为空的话，返回 true；反之，返回 false。 size() 返回 priority_queue 中存储元素的个数。 top() 返回 priority_queue 中第一个元素的引用形式。 push(const T& obj) 根据既定的排序规则，将元素 obj 的副本存储到 priority_queue 中适当的位置。 push(T&& obj) 根据既定的排序规则，将元素 obj 移动存储到 priority_queue 中适当的位置。 emplace(Args&&… args) Args&&… args 表示构造一个存储类型的元素所需要的数据（对于类对象来说，可能需要多个数据构造出一个对象）。此函数的功能是根据既定的排序规则，在容器适配器适当的位置直接生成该新元素。 pop() 移除 priority_queue 容器适配器中第一个元素。 swap(priority_queue& other) 将两个 priority_queue 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 priority_queue 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。 2. 迭代器定义 常用的迭代器按功能强弱分为输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器 5 种。 前向迭代器（# iterator） 假设 p 是一个前向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 == 和 != 运算符进行比较。此外，两个正向迭代器可以互相赋值。 双向迭代器（bidirectional iterator） 双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 --p 或者 p-- 操作（即一次向后移动一个位置）。 随机访问迭代器（random access iterator） 随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作： p+=i：使得 p 往后移动 i 个元素。 p-=i：使得 p 往前移动 i 个元素。 p+i：返回 p 后面第 i 个元素的迭代器。 p-i：返回 p 前面第 i 个元素的迭代器。 p[i]：返回 p 后面第 i 个元素的引用。 此外，两个随机访问迭代器 p1、p2 还可以用 、= 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。 迭代器定义方式 迭代器定义方式 具体格式 正向迭代器 容器类名::iterator 迭代器名; 常量正向迭代器 容器类名::const_iterator 迭代器名; 反向迭代器 容器类名::reverse_iterator 迭代器名; 常量反向迭代器 容器类名::const_reverse_iterator 迭代器名; 反向迭代器和正向迭代器的区别在于： 对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素； 而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。 反向迭代器重载的运算符 重载运算符 功能 operator* 以引用的形式返回当前迭代器指向的元素。 operator+ 返回一个反向迭代器，其指向距离当前指向的元素之后 n 个位置的元素。此操作要求基础迭代器为随机访问迭代器。 operator++ 重载前置 ++ 和后置 ++ 运算符。 operator+= 当前反向迭代器前进 n 个位置，此操作要求基础迭代器为随机访问迭代器。 operator- 返回一个反向迭代器，其指向距离当前指向的元素之前 n 个位置的元素。此操作要求基础迭代器为随机访问迭代器。 operator– 重载前置 – 和后置 – 运算符。 operator-= 当前反向迭代器后退 n 个位置，此操作要求基础迭代器为随机访问迭代器。 operator-> 返回一个指针，其指向当前迭代器指向的元素。 operator[n] 访问和当前反向迭代器相距 n 个位置处的元素。 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/09-算法/02. STL使用/STL参考资料.html":{"url":"roccoshi_note/09-算法/02. STL使用/STL参考资料.html","title":"STL参考资料","keywords":"","body":"STL目录1. 容器1.1 序列式容器1.2 关联式容器1.3 无序关联式容器1.4 其他2. 迭代器定义STL https://blog.csdn.net/weixin_45761327/article/details/107561697 目录 1. 容器 1.1 序列式容器 1. 数组(array) 数组-使用前 数组-创建与初始化 数组-array容器成员函数汇总 数组-访问数组元素 2. 向量(vector) 向量-使用前 向量-创建与初始化 向量-vector 容器的成员函数 向量-访问向量元素 向量-insert语法格式 向量-删除元素 3. 双端队列 队列-使用前 队列-创建与初始化 队列-deque容器的成员函数 队列-访问队列中的元素 队列-insert() 成员函数语法格式 4. 双链表 双链表-使用前 双链表-创建与初始化 双链表-list容器的成员函数 双链表-访问链表中的元素 双链表-list添加（插入）元素 双链表-insert()语法格式 双链表-list splice()成员方法 双链表-list删除元素 5. 正向链表 单链表-使用前 单链表-创建与初始化 单链表- forward_list 容器可用的成员函数 6. array、vector 和 deque 容器的函数成员 7. list 和 forward_list 的函数成员 1.2 关联式容器 1. pair类模板 pair类的构造方法 2. map map-使用前 map-创建与初始化 map-map容器常用成员方法 map-map获取键对应值 map-map insert()插入数据 3. multimap容器 multimap-使用前 multimap-创建与初始化 multimap-multimap 容器常用成员方法 4. set set-使用前 set-创建与初始化 set-set 容器常用成员方法 set-set迭代器 set-insert()函数详解 set-set删除数据 5.multiset multiset-使用前 multiset-创建与初始化 multiset-multiset 容器常用成员方法 1.3 无序关联式容器 1. unordered_map unordered_map-使用前 unordered_map - 创建与初始化 unordered_map - unordered_map类模板成员方法 unordered_map - unordered_map获取元素 unordered_map -insert() unordered_map-unordered_map删除元素 2. unordered_multimap unordered_multimap-使用前 unordered_multimap-创建与初始化 unordered_multimap类模板成员方法 3. unordered_set unordered_set-使用前 unordered_set-创建与初始化 unordered_set - unordered_set 类模板成员方法 4. unordered_multiset unordered_multiset-使用前 unordered_multiset-创建与初始化 1.4 其他 1.String String - 创建与初始化 String - string 类的所有成员函数 2.栈 栈-使用前 栈-创建与初始化 栈-常用函数 3.queue queue- 使用前 queue-创建于初始化 queue-queue容器适配器支持的成员函数 4.priority_queue（优先队列） priority_queue-使用前 priority_queue-创建与初始化 priority_queue-常用函数 2. 迭代器定义 1. 容器 容器种类 功能 序列容器 主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。 之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。 将元素插入容器时，指定在什么位置，元素就会位于什么位置。 排序容器 包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。 排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。 哈希容器 C++ 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。 和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。 1.1 序列式容器 1. 数组(array) array（数组容器）：表示可以存储 N 个 T 类型的元素,元素个数固定。就是一个添加了一些成员函数和全局函数的数组，效率不降的情况下比普通数组更加安全。 数组-使用前 在使用数组容器之前，代码中需引入头文件，并默认使用 std 命令空间，如下所示： #include using namespace std; 数组-创建与初始化 array 容器有多种初始化方式，具体如下： 创建具有 4 个 int 类型元素的 array 容器： std::array values;//若已指定std命名空间，则可省略std:: 创建时将所有的元素初始化为 0 或者和默认元素类型等效的值： std::array values {}; 像创建常规数组那样对元素进行初始化 std::array values {0.5,1.0,1.5,2.0};//如同常规数组一样，初始化时未涉及的其余元素都会被初始化为0 数组-array容器成员函数汇总 重要的函数已加粗 成员函数 功能 begin() 返回指向容器中第一个元素的随机访问迭代器。 end() 返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。 rbegin() 返回指向最后一个元素的随机访问迭代器。 rend() 返回指向第一个元素之前一个位置的随机访问迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 size() 返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。 max_size() 返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。 empty() 判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。 at(n) 返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。 front() 返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。 back() 返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。 data() 返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能。 fill(val) 将 val 这个值赋值给容器中的每个元素。 array1.swap(array2) 交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。 部分函数使用示例 #include //需要引入 array 头文件 #include using namespace std; int main() { std::array values{}; //初始化 values 容器为 {0,1,2,3} for (int i = 0; i (values) 数组-访问数组元素 调用size()函数返回个数使用for循环遍历每个元素 array values{1,2,3,4,5}; //从下标 0 一直遍历到 size()-1 处 for (int i = 0; i 使用迭代器进行访问-利用begin()/end() 函数 array values{1,2,3,4,5}; for (auto first = values.begin(); first 如上示例，我们可使用at()函数，但同时也可使用[]+索引的方式 at()函数会检查越界，而索引的方式则不会进行检查 values.at (4) = values.at(3) + 2.O*values.at(1); values[4] = values[3] + 2.O*values[1]; 同理我们可使用get()函数和索引的方式获取元素值 2. 向量(vector) vector（向量容器）：用来存放 T 类型的元素，是一个长度可变的序列容器,长度不足时会自动申请内存空间以增长。在尾部增删效率为O(1)，但在其他位置增删效率为O(n) 向量-使用前 vector 容器以类模板 vector（ T 表示存储元素的类型）的形式定义在 头文件中，并位于 std 命名空间中。因此，在创建该容器之前，代码中需包含如下内容： #include using namespace std; 向量-创建与初始化 创建 vector 容器的方式有很多，大致可分为以下几种。 创建一个空的存储double类型的vector容器 std::vector values; 创建时初始化值 std::vector primes {2, 3, 5, 7, 11, 13, 17, 19}; 创建时指定元素个数 std::vector values(20);//这20个元素默认初始值都是0 创建时指定元素个数并指定默认初始值 std::vector values(20, 1.0);//这 20 个元素的初始值都是 1.0 通过存储元素类型相同的其它 vector 容器，可以创建新的 vector 容器 std::vectorvalue1(5, 'c'); std::vectorvalue2(value1); //若不想保存所有元素 int array[]={1,2,3}; std::vectorvalues(array, array+2);//values 将保存{1,2} std::vectorvalue1{1,2,3,4,5}; std::vectorvalue2(std::begin(value1),std::begin(value1)+3);//value2保存{1,2,3} 向量-vector 容器的成员函数 成员函数 功能 begin() 返回指向容器中第一个元素的迭代器。 end() 返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。 rbegin() 返回指向最后一个元素的迭代器。 rend() 返回指向第一个元素所在位置前一个位置的迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 size() 返回实际元素个数。 max_size() 返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。 resize() 改变实际元素的个数。 capacity() 返回当前容量。 empty() 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 reserve() 增加容器的容量。 shrink _to_fit() 将内存减少到等于当前元素实际所使用的大小。 operator[ ] 重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 at() 使用经过边界检查的索引访问元素。 front() 返回第一个元素的引用。 back() 返回最后一个元素的引用。 data() 返回指向容器中第一个元素的指针。 assign() 用新元素替换原有内容。 push_back() 在序列的尾部添加一个元素。 pop_back() 移出序列尾部的元素。 insert() 在指定的位置插入一个或多个元素。 erase() 移出一个元素或一段元素。 clear() 移出所有的元素，容器大小变为 0。 swap() 交换两个容器的所有元素。 emplace() 在指定的位置直接生成一个元素。 emplace_back() 在序列尾部生成一个元素。 对于空的 vector 容器来说，begin() 和 end() 成员函数返回的迭代器是相等的，即它们指向的是同一个位置。 所以，对于空的 vector 容器来说，可以通过调用 push_back() 或者借助 resize() 成员函数实现初始化容器的目的。 除此之外，vector 容器在申请更多内存的同时，容器中的所有元素可能会被复制或移动到新的内存地址，这会导致之前创建的迭代器失效。 注意：emplace_back() 和 push_back() 的虽然都是向容器尾部添加一个元素 ， 但两者底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。 因此emplace_back()的效率会更高， insert()和emplace()同理。 向量-访问向量元素 调用size()函数返回个数使用for循环遍历每个元素 vector values{1,2,3,4,5}; //从下标 0 一直遍历到 size()-1 处 for (int i = 0; i 使用迭代器进行访问-利用begin()/end() 函数 vector values{1,2,3,4,5}; for (auto first = values.begin(); first 如上示例，我们可使用at()函数，但同时也可使用[]+索引的方式 at()函数会检查越界，而索引的方式则不会进行检查 values.at (4) = values.at(3) + 2.O*values.at(1); values[4] = values[3] + 2.O*values[1]; 同理我们可使用get()函数和索引的方式获取元素值 我们可以调用front() 和 back()函数，它们分别返回 vector 容器中第一个和最后一个元素的引用，通过利用这 2 个函数返回的引用，可以访问（甚至修改）容器中的首尾元素。 我们也可以调用 data() 成员函数，该函数的功能是返回指向容器中首个元素的指针。通过该指针也可以访问甚至修改容器中的元素 vector values{1,2,3,4,5}; //输出容器中第 3 个元素的值 cout 向量-insert语法格式 语法格式 功能 iterator insert(pos,elem) 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。 iterator insert(pos,n,elem) 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。 iterator insert(pos,first,last) 在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。 iterator insert(pos,initlist) 在迭代器 pos指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。 iterator insert(pos,elem) 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。 std::vector demo{1,2}; //第一种格式用法 demo.insert(demo.begin() + 1, 3);//{1,3,2} iterator insert(pos,n,elem) 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。 //第二种格式用法 demo.insert(demo.end(), 2, 5);//{1,3,2,5,5} iterator insert(pos,first,last) 在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。 //第三种格式用法 std::arraytest{ 7,8,9 }; demo.insert(demo.end(), test.begin(), test.end());//{1,3,2,5,5,7,8,9} iterator insert(pos,initlist) 在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。 //第四种格式用法 demo.insert(demo.end(), { 10,11 });//{1,3,2,5,5,7,8,9,10,11} 向量-删除元素 删除 vector 容器元素的几种方式 函数 功能 pop_back() 删除 vector 容器中最后一个元素，该容器的大小（size）会减 1，但容量（capacity）不会发生改变。 erase(pos) 删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置元素的迭代器。该容器的大小（size）会减 1，但容量（capacity）不会发生改变。 swap(beg)、pop_back() 先调用 swap() 函数交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back() 删除该目标元素。 erase(beg,end) 删除 vector 容器中位于迭代器 [beg,end)指定区域内的所有元素，并返回指向被删除区域下一个位置元素的迭代器。该容器的大小（size）会减小，但容量（capacity）不会发生改变。 remove() 删除容器中所有和指定元素值相等的元素，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。 clear() 删除 vector 容器中所有的元素，使其变成空的 vector 容器。该函数会改变 vector 的大小（变为 0），但不是改变其容量。 3. 双端队列 deque（双端队列容器）：和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶； 注意，其实除此之外，stack 和 queue 本质上也属于序列容器，只不过它们都是在 deque 容器的基础上改头换面而成，通常更习惯称它们为容器适配器，有关它们的介绍，会放到后续章节中。 队列-使用前 deque 容器以模板类 deque（T 为存储元素的类型）的形式在 头文件中，并位于 std 命名空间中。因此，在使用该容器之前，代码中需要包含下面两行代码： #include using namespace std; 队列-创建与初始化 创建 deque 容器，根据不同的实际场景，可选择使用如下几种方式。 创建一个没有任何元素的空 deque 容器： std::deque d; 创建一个具有 n 个元素的 deque 容器，其中每个元素都采用对应类型的默认值： std::deque d(10); 创建一个具有 n 个元素的 deque 容器，并为每个元素都指定初始值，例如： std::deque d(10, 5) 在已有 deque 容器的情况下，可以通过拷贝该容器创建一个新的 deque 容器，例如： std::deque d1(5); std::deque d2(d1); 通过拷贝其他类型容器中指定区域内的元素（也可以是普通数组），可以创建一个新容器，例如： //拷贝普通数组，创建deque容器 int a[] = { 1,2,3,4,5 }; std::dequed(a, a + 5); //适用于所有类型的容器 std::arrayarr{ 11,12,13,14,15 }; std::dequed(arr.begin()+2, arr.end());//拷贝arr容器中的{13,14,15} 队列-deque容器的成员函数 重要函数已加粗标出 函数成员 函数功能 begin() 返回指向容器中第一个元素的迭代器。 end() 返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。 rbegin() 返回指向最后一个元素的迭代器。 rend() 返回指向第一个元素所在位置前一个位置的迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 size() 返回实际元素个数。 max_size() 返回容器所能容纳元素个数的最大值。这通常是一个很大的值，一般是 232-1，我们很少会用到这个函数。 resize() 改变实际元素的个数。 empty() 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 shrink _to_fit() 将内存减少到等于当前元素实际所使用的大小。 at() 使用经过边界检查的索引访问元素。 front() 返回第一个元素的引用。 back() 返回最后一个元素的引用。 assign() 用新元素替换原有内容。 push_back() 在序列的尾部添加一个元素。 push_front() 在序列的头部添加一个元素。 pop_back() 移除容器尾部的元素。 pop_front() 移除容器头部的元素。 insert() 在指定的位置插入一个或多个元素。 erase() 移除一个元素或一段元素。 clear() 移出所有的元素，容器大小变为 0。 swap() 交换两个容器的所有元素。 emplace() 在指定的位置直接生成一个元素。 emplace_front() 在容器头部生成一个元素。和 push_front() 的区别是，该函数直接在容器头部构造元素，省去了复制移动元素的过程。 emplace_back() 在容器尾部生成一个元素。和 push_back() 的区别是，该函数直接在容器尾部构造元素，省去了复制移动元素的过程。 关于empalace()函数和insert()的效率问题前面已经讨论 这里不再涉及 队列-访问队列中的元素 队列可以像普通数组一样采用索引的方式访问元素 dequed{ 1,2,3,4 }; cout 队列可以调用at()函数来访问元素 at() 成员函数会自行判定访问位置是否越界，如果越界则抛出std::out_of_range异常。 dequed{ 1,2,3,4 }; cout 队列可以调用front()和back()函数来访问队列的首尾元素 deque d{ 1,2,3,4,5 }; cout 注意，deque没有提供data()函数 队列-insert() 成员函数语法格式 语法格式 功能 iterator insert(pos,elem) 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。 iterator insert(pos,n,elem) 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。 iterator insert(pos,first,last) 在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。 iterator insert(pos,initlist) 在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。 std::deque d{ 1,2 }; //第一种格式用法 d.insert(d.begin() + 1, 3);//{1,3,2} //第二种格式用法 d.insert(d.end(), 2, 5);//{1,3,2,5,5} //第三种格式用法 std::arraytest{ 7,8,9 }; d.insert(d.end(), test.begin(), test.end());//{1,3,2,5,5,7,8,9} //第四种格式用法 d.insert(d.end(), { 10,11 });//{1,3,2,5,5,7,8,9,10,11} 注意:下图为vector的insert()函数语法格式,注意到两者是一致的! 4. 双链表 list（链表容器）：是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素。 实际场景中，如何需要对序列进行大量添加或删除元素的操作，而直接访问元素的需求却很少，这种情况建议使用 list 容器存储序列。 双链表-使用前 list 容器以模板类 list（T 为存储元素的类型）的形式在头文件中，并位于 std 命名空间中。因此，在使用该容器之前，代码中需要包含下面两行代码： #include using namespace std; 注意，std 命名空间也可以在使用 list 容器时额外注明，两种方式都可以。 双链表-创建与初始化 创建一个没有任何元素的空list容器 std::list values; 创建一个包含n个元素的list容器 std::list values(10);//注意:容积用小括号 创建一个包含n个元素的list容器并制定初始值 std::list values(10 , 5); 通过拷贝已有的list容器创建新的容器 std::list values1(10 , 5); std::list values2(values1); 通过拷贝已有的list容器中的部分元素创建新的容器 //拷贝普通数组，创建list容器 int a[] = { 1,2,3,4,5 }; std::list values(a, a+5); //拷贝其它类型的容器，创建 list 容器 std::arrayarr{ 11,12,13,14,15 }; std::listvalues(arr.begin()+2, arr.end());//拷贝arr容器中的{13,14,15} 双链表-list容器的成员函数 重要的函数已加粗标出 成员函数 功能 begin() 返回指向容器中第一个元素的双向迭代器。 end() 返回指向容器中最后一个元素的双向迭代器。 rbegin() 返回指向最后一个元素的反向双向迭代器。 rend() 返回指向第一个元素所在位置前一个位置的反向双向迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 empty() 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 size() 返回当前容器实际包含的元素个数。 max_size() 返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。 front() 返回第一个元素的引用。 back() 返回最后一个元素的引用。 assign() 用新元素替换容器中原有内容。 emplace_front() 在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。 push_front() 在容器头部插入一个元素。 pop_front() 删除容器头部的一个元素。 emplace_back() 在容器尾部直接生成一个元素。该函数和 push_back() 的功能相同，但效率更高。 push_back() 在容器尾部插入一个元素。 pop_back() 删除容器尾部的一个元素。 emplace() 在容器中的指定位置插入元素。该函数和 insert() 功能相同，但效率更高。 insert() 在容器中的指定位置插入元素。 erase() 删除容器中一个或某区域内的元素。 swap() 交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。 resize() 调整容器的大小。 clear() 删除容器存储的所有元素。 splice() 将一个 list 容器中的元素插入到另一个容器的指定位置。 remove(val) 删除容器中所有等于 val 的元素。 remove_if() 删除容器中满足条件的元素。 unique() 删除容器中相邻的重复元素，只保留一个。 merge() 合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的。 sort() 通过更改容器中元素的位置，将它们进行排序。 reverse() 反转容器中元素的顺序。 emplace()系列函数和insert()系列函数的效率问题,前者更高,原因在前面已经给出,这里不再讨论. 双链表-访问链表中的元素 访问 list 容器中存储元素的方式很有限，即要么使用 front() 和 back() 成员函数，要么使用 list 容器迭代器。 list 容器不支持随机访问，未提供下标操作符 [] 和 at() 成员函数，也没有提供 data() 成员函数。 除此之外，如果想访问 list 容存储的其他元素，就只能使用 list 容器的迭代器。 const std::list mylist{1,2,3,4,5}; auto it = mylist.begin(); cout 双链表-list添加（插入）元素 list 模板类中，与“添加或插入新元素”相关的成员方法有如下几个： push_front()：向 list 容器首个元素前添加新元素； push_back()：向 list 容器最后一个元素后添加新元素； emplace_front()：在容器首个元素前直接生成新的元素； emplace_back()：在容器最后一个元素后直接生成新的元素； emplace()：在容器的指定位置直接生成新的元素； insert()：在指定位置插入新元素； splice()：将其他 list 容器存储的多个元素添加到当前 list 容器的指定位置处。 双链表-insert()语法格式 语法格式 功能 iterator insert(pos,elem) 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。 iterator insert(pos,n,elem) 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。 iterator insert(pos,first,last) 在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。 iterator insert(pos,initlist) 在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。 std::list values{ 1,2 }; //第一种格式用法 values.insert(values.begin() , 3);//{3,1,2} //第二种格式用法 values.insert(values.end(), 2, 5);//{3,1,2,5,5} //第三种格式用法 std::arraytest{ 7,8,9 }; values.insert(values.end(), test.begin(), test.end());//{3,1,2,5,5,7,8,9} //第四种格式用法 values.insert(values.end(), { 10,11 });//{3,1,2,5,5,7,8,9,10,11} 注意！迄今为止，向量，队列，链表的insert()函数语法格式都是一致的 双链表-list splice()成员方法 和 insert() 成员方法相比，splice() 成员方法的作用对象是其它 list 容器，其功能是将其它 list 容器中的元素添加到当前 list 容器中指定位置处。 splice() 成员方法的语法格式有 3 种 语法格式 功能 void splice (iterator position, list& x); position 为迭代器，用于指明插入位置；x 为另一个 list 容器。 此格式的 splice() 方法的功能是，将 x 容器中存储的所有元素全部移动当前 list 容器中 position 指明的位置处。 void splice (iterator position, list& x, iterator i); position 为迭代器，用于指明插入位置；x 为另一个 list 容器；i 也是一个迭代器，用于指向 x 容器中某个元素。 此格式的 splice() 方法的功能是将 x 容器中 i 指向的元素移动到当前容器中 position 指明的位置处。 void splice (iterator position, list& x, iterator first, iterator last); position 为迭代器，用于指明插入位置；x 为另一个 list 容器；first 和 last 都是迭代器，[fist,last) 用于指定 x 容器中的某个区域。 此格式的 splice() 方法的功能是将 x 容器 [first, last) 范围内所有的元素移动到当前容器 position 指明的位置处。 //创建并初始化 2 个 list 容器 list mylist1{ 1,2,3,4 }, mylist2{10,20,30}; list::iterator it = ++mylist1.begin(); //指向 mylist1 容器中的元素 2 //调用第一种语法格式 mylist1.splice(it, mylist2); // mylist1: 1 10 20 30 2 3 4 // mylist2: // it 迭代器仍然指向元素 2，只不过容器变为了 mylist1 //调用第二种语法格式，将 it 指向的元素 2 移动到 mylist2.begin() 位置处 mylist2.splice(mylist2.begin(), mylist1, it); // mylist1: 1 10 20 30 3 4 // mylist2: 2 // it 仍然指向元素 2 //调用第三种语法格式，将 [mylist1.begin(),mylist1.end())范围内的元素移动到 mylist.begin() 位置处 mylist2.splice(mylist2.begin(), mylist1, mylist1.begin(),mylist1.end());//mylist1: //mylist2:1 10 20 30 3 4 2 双链表-list删除元素 实现 list 容器删除元素的成员函数 成员函数 功能 pop_front() 删除位于 list 容器头部的一个元素。 pop_back() 删除位于 list 容器尾部的一个元素。 erase() 该成员函数既可以删除 list 容器中指定位置处的元素，也可以删除容器中某个区域内的多个元素。 clear() 删除 list 容器存储的所有元素。 remove(val) 删除容器中所有等于 val 的元素。 unique() 删除容器中相邻的重复元素，只保留一份。 remove_if() 删除容器中满足条件的元素。 erase()函数可传入一个或两个迭代器的位置,分别为删除一个和一段的元素 若想根据元素的值来执行删除操作,则可使用remove操作,直接传入值即可 unique() 函数也可选择是否传入一个二元谓词函数,可自定义去重规则 remove_if()和unique()一致,可选择是否传入二元谓词函数 #include #include using namespace std; //二元谓词函数 bool demo(double first, double second) { return (int(first) == int(second)); } int main() { list mylist{ 1,1.2,1.2,3,4,4.5,4.6 }; //删除相邻重复的元素，仅保留一份 mylist.unique();//{1, 1.2, 3, 4, 4.5, 4.6} for (auto it = mylist.begin(); it != mylist.end(); ++it) cout 5. 正向链表 forward_list（正向链表容器）：和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。 单链表-使用前 由于 forward_list 容器以模板类 forward_list（T 为存储元素的类型）的形式被包含在头文件中，并定义在 std 命名空间中。因此，在使用该容器之前，代码中需包含下面两行代码： #include using namespace std; 单链表-创建与初始化 创建 forward_list 容器的方式，大致分为以下 5 种。 创建一个没有任何元素的空list容器 std::forward_list values; 创建一个包含n个元素的list容器 std::forward_list values(10);//注意:容积用小括号 创建一个包含n个元素的list容器并制定初始值 std::forward_list values(10 , 5); 通过拷贝已有的list容器创建新的容器 std::forward_list values1(10 , 5); std::forward_list values2(values1); 通过拷贝已有的list容器中的部分元素创建新的容器 //拷贝普通数组，创建list容器 int a[] = { 1,2,3,4,5 }; std::forward_list values(a, a+5); //拷贝其它类型的容器，创建 list 容器 std::arrayarr{ 11,12,13,14,15 }; std::forward_listvalues(arr.begin()+2, arr.end());//拷贝arr容器中的{13,14,15} 仔细观察,单链表和双链表的初始化方式都是一样的 单链表- forward_list 容器可用的成员函数 重要的函数已加粗标出 成员函数 功能 before_begin() 返回一个前向迭代器，其指向容器中第一个元素之前的位置。 begin() 返回一个前向迭代器，其指向容器中第一个元素的位置。 end() 返回一个前向迭代器，其指向容器中最后一个元素之后的位置。 cbefore_begin() 和 before_begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 empty() 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 max_size() 返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。 front() 返回第一个元素的引用。 assign() 用新元素替换容器中原有内容。 push_front() 在容器头部插入一个元素。 emplace_front() 在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。 pop_front() 删除容器头部的一个元素。 emplace_after() 在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。和 insert_after() 的功能相同，但效率更高。 insert_after() 在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。 erase_after() 删除容器中某个指定位置或区域内的所有元素。 swap() 交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。 resize() 调整容器的大小。 clear() 删除容器存储的所有元素。 splice_after() 将某个 forward_list 容器中指定位置或区域内的元素插入到另一个容器的指定位置之后。 remove(val) 删除容器中所有等于 val 的元素。 remove_if() 删除容器中满足条件的元素。 unique() 删除容器中相邻的重复元素，只保留一个。 merge() 合并两个事先已排好序的 forward_list 容器，并且合并之后的 forward_list 容器依然是有序的。 sort() 通过更改容器中元素的位置，将它们进行排序。 reverse() 反转容器中元素的顺序。 关于empalace()函数和insert()的效率问题前面已经讨论 这里不再涉及 通过表我们知道，forward_list 容器中是不提供 size() 函数的，但如果想要获取 forward_list 容器中存储元素的个数，可以使用头文件 中的 distance() 函数。举个例子 std::forward_list my_words{1,2,3,4}; int count = std::distance(std::begin(my_words), std::end(my_words)); cout 6. array、vector 和 deque 容器的函数成员 函数成员 函数功能 array vector deque begin() 返回指向容器中第一个元素的迭代器。 是 是 是 end() 返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。 是 是 是 rbegin() 返回指向最后一个元素的迭代器。 是 是 是 rend() 返回指向第一个元素所在位置前一个位置的迭代器。 是 是 是 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 是 是 是 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 是 是 是 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 是 是 是 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 是 是 是 assign() 用新元素替换原有内容。 - 是 是 operator=() 复制同类型容器的元素，或者用初始化列表替换现有内容。 是 是 是 size() 返回实际元素个数。 是 是 是 max_size() 返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。 是 是 是 capacity() 返回当前容量。 - 是 - empty() 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 是 是 是 resize() 改变实际元素的个数。 - 是 是 shrink _to_fit() 将内存减少到等于当前元素实际所使用的大小。 - 是 是 front() 返回第一个元素的引用。 是 是 是 back() 返回最后一个元素的引用。 是 是 是 operator 使用索引访问元素。 是 是 是 at() 使用经过边界检査的索引访问元素。 是 是 是 push_back() 在序列的尾部添加一个元素。 - 是 是 insert() 在指定的位置插入一个或多个元素。 - 是 是 emplace() 在指定的位置直接生成一个元素。 - 是 是 emplace_back() 在序列尾部生成一个元素。 - 是 是 pop_back() 移出序列尾部的元素。 - 是 是 erase() 移出一个元素或一段元素。 - 是 是 clear() 移出所有的元素，容器大小变为 0。 - 是 是 swap() 交换两个容器的所有元素。 是 是 是 data() 返回指向容器中第一个元素的指针。 是 是 - 7. list 和 forward_list 的函数成员 list 和 forward_list 容器彼此非常相似，forward_list 中包含了 list 的大部分成员函数，而未包含那些需要反向遍历的函数。表 3 展示了 list 和 forward_list 的函数成员。 函数成员 函数功能 list forward_list begin() 返回指向容器中第一个元素的迭代器 是 是 end() 返回指向容器最后一个元素所在位置后一个位置的迭代器。 是 是 rbegin() 返回指向最后一个元素的迭代器。 是 - rend() 返回指向第一个元素所在位置前一个位置的迭代器。 是 - cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 是 是 before_begin() 返回指向第一个元素前一个位置的迭代器。 - 是 cbefore_begin() 和 before_begin() 功能相同，只不过在其基础上，增加了 const 属性，即不能用该指针修改元素的值。 - 是 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 是 是 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 是 - crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 是 - assign() 用新元素替换原有内容。 是 是 operator=() 复制同类型容器的元素，或者用初始化列表替换现有内容。 是 是 size() 返回实际元素个数。 是 - max_size() 返回元素个数的最大值，这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。 是 是 resize() 改变实际元素的个数。 是 是 empty() 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 是 是 front() 返回容器中第一个元素的引用。 是 是 back() 返回容器中最后一个元素的引用。 是 - push_back() 在序列的尾部添加一个元素。 是 - push_front() 在序列的起始位置添加一个元素。 是 是 emplace() 在指定位置直接生成一个元素。 是 - emplace_after() 在指定位置的后面直接生成一个元素。 - 是 emplace_back() 在序列尾部生成一个元素。 是 - cmplacc_front() 在序列的起始位生成一个元索。 是 是 insert() 在指定的位置插入一个或多个元素。 是 - insert_after() 在指定位置的后面插入一个或多个元素。 - 是 pop_back() 移除序列尾部的元素。 是 - pop_front() 移除序列头部的元素。 是 是 reverse() 反转容器中某一段的元素。 是 是 erase() 移除指定位置的一个元素或一段元素。 是 - erase_after() 移除指定位置后面的一个元素或一段元素。 - 是 remove() 移除所有和参数匹配的元素。 是 是 remove_if() 移除满足一元函数条件的所有元素。 是 是 unique() 移除所有连续重复的元素。 是 是 clear() 移除所有的元素，容器大小变为 0。 是 是 swap() 交换两个容器的所有元素。 是 是 sort() 对元素进行排序。 是 是 merge() 合并两个有序容器。 是 是 splice() 移动指定位置前面的所有元素到另一个同类型的 list 中。 是 - splice_after() 移动指定位置后面的所有元素到另一个同类型的 list 中。 - 是 1.2 关联式容器 和序列式容器不同的是，关联式容器在存储元素时还会为每个元素在配备一个键，整体以键值对的方式存储到容器中。相比前者，关联式容器可以通过键值直接找到对应的元素，而无需遍历整个容器。另外，关联式容器在存储元素，默认会根据各元素键值的大小做升序排序。 相比其它类型容器，关联式容器查找、访问、插入和删除指定元素的效率更高。 弃用序列式容器，转而选用关联式容器存储元素，往往就是看中了关联式容器可以快速查找、读取或者删除所存储的元素，同时该类型容器插入元素的效率也比序列式容器高。 关联式容器所具备的这些特性，归咎于 STL 标准库在实现该类型容器时，底层选用了 「红黑树」这种数据结构来组织和存储各个键值对。 关联式容器，包括 map、multimap、set 以及 multiset 这 4 种容器。 关联式容器名称 特点 map 定义在 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根据各元素键的大小，默认进行升序排序（调用 std::less）。 set 定义在 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序（调用 std::less）。 multimap 定义在 头文件中，和 map 容器唯一的不同在于，multimap 容器中存储元素的键可以重复。 multiset 定义在 头文件中，和 set 容器唯一的不同在于，multiset 容器中存储元素的值可以重复（一旦值重复，则意味着键也是重复的）。 1. pair类模板 pair 类模板定义在头文件中，所以在使用该类模板之前，需引入此头文件。 C++ STL 标准库提供了 pair 类模板，其专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素 pair类的构造方法 #1) 默认构造函数，即创建空的 pair 对象 pair(); pair pair1; #2) 直接使用 2 个元素初始化成 pair 对象 pair (const first_type& a, const second_type& b); pair pair2(\"STL教程\",\"http://c.biancheng.net/stl/\"); #3) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象 template pair (const pair& pr); pair pair3(pair2); #4) 移动构造函数 template pair (pair&& pr); pair pair4(make_pair(\"C++教程\", \"http://c.biancheng.net/cplus/\")); #5) 使用右值引用参数，创建 pair 对象 template pair (U&& a, V&& b); pair pair5(string(\"Python教程\"), string(\"http://c.biancheng.net/python/\")); 头文件中除了提供创建 pair 对象的方法之外，还为 pair 对象重载了 、>=、==、!= 这 6 的运算符，其运算规则是：对于进行比较的 2 个 pair 对象，先比较 pair.first 元素的大小，如果相等则继续比较 pair.second 元素的大小。 2. map 作为关联式容器的一种，map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。其中，各个键值对的键和值可以是任意数据类型，包括 C++ 基本数据类型（int、double 等）、使用结构体或类自定义的类型。 map-使用前 map 容器定义在 头文件中，并位于 std 命名空间中。因此，如果想使用 map 容器，代码中应包含如下语句： #include using namespace std; map 容器的模板定义如下： template , // 指定排序规则 class Alloc = allocator > // 指定分配器对象的类型 > class map; 可以看到，map 容器模板有 4 个参数，其中后 2 个参数都设有默认值。大多数场景中，我们只需要设定前 2 个参数的值，有些场景可能会用到第 3 个参数，但最后一个参数几乎不会用到。 map-创建与初始化 创建一个空的map容器 std::mapmyMap; 在创建map容器的同时进行初始化 std::mapmyMap{ {\"C语言教程\",10},{\"STL教程\",20} }; std::mapmyMap{std::make_pair(\"C语言教程\",10),std::make_pair(\"STL教程\",20)}; 利用已有的map容器创建新的map容器 std::mapnewMap(myMap); 利用已有map容器中的部分键值对创建新的map容器 std::mapmyMap{ {\"C语言教程\",10},{\"STL教程\",20} }; std::mapnewMap(++myMap.begin(), myMap.end()); 在以上几种创建 map 容器的基础上，我们都可以手动修改 map 容器的排序规则。默认情况下，map 容器调用 std::less 规则，根据容器内各键值对的键的大小，对所有键值对做升序排序。 //以下两行等价 std::mapmyMap{ {\"C语言教程\",10},{\"STL教程\",20} }; std::map >myMap{ {\"C语言教程\",10},{\"STL教程\",20} }; 下面程序手动修改了 myMap 容器的排序规则，令其作降序排序： std::map >myMap{ {\"C语言教程\",10},{\"STL教程\",20} }; map-map容器常用成员方法 成员方法 功能 begin() 返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 end() 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 rbegin() 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 rend() 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 find(key) 在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 lower_bound(key) 返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 upper_bound(key) 返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 equal_range(key) 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。 empty() 若容器为空，则返回 true；否则 false。 size() 返回当前 map 容器中存有键值对的个数。 max_size() 返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。 operator[] map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。 at(key) 找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。 insert() 向 map 容器中插入键值对。 erase() 删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对。后续章节还会对该方法做重点讲解。 swap() 交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。 clear() 清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0。 emplace() 在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。 emplace_hint() 在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。 count(key) 在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。 map-map获取键对应值 map 容器的类模板中提供了以下 2 种方法，可直接获取 map 容器指定键对应的值。 map 类模板中对[ ]运算符进行了重载，这意味着，类似于借助数组下标可以直接访问数组中元素，通过指定的键，我们可以轻松获取 map 容器中该键对应的值。 注意，只有当 map 容器中确实存有包含该指定键的键值对，借助重载的 [ ] 运算符才能成功获取该键对应的值；反之，若当前 map 容器中没有包含该指定键的键值对，则此时使用 [ ] 运算符将不再是访问容器中的元素，而变成了向该 map 容器中增添一个键值对。 //创建并初始化 map 容器 std::mapmyMap{ {\"STL教程\",\"http://c.biancheng.net/stl/\"}, {\"C语言教程\",\"http://c.biancheng.net/c/\"}, {\"Java教程\",\"http://c.biancheng.net/java/\"} }; string cValue = myMap[\"C语言教程\"]; cout 除了借助 [ ] 运算符获取 map 容器中指定键对应的值，还可以使用 at() 成员方法。和前一种方法相比，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出 out_of_range 异常。 //创建并初始化 map 容器 std::mapmyMap{ {\"STL教程\",\"http://c.biancheng.net/stl/\"}, {\"C语言教程\",\"http://c.biancheng.net/c/\"}, {\"Java教程\",\"http://c.biancheng.net/java/\"} }; cout 如果以上方法都不适用，我们还可以遍历整个 map 容器，找到包含指定键的键值对，进而获取该键对应的值。 //创建并初始化 map 容器 std::mapmyMap{ {\"STL教程\",\"http://c.biancheng.net/stl/\"}, {\"C语言教程\",\"http://c.biancheng.net/c/\"}, {\"Java教程\",\"http://c.biancheng.net/java/\"} }; for (auto iter = myMap.begin(); iter != myMap.end(); ++iter) { //调用 string 类的 compare() 方法，找到一个键和指定字符串相同的键值对 if (!iter->first.compare(\"C语言教程\")) { cout first second map-map insert()插入数据 向map容器的指定位置插入新键值对 //以普通引用的方式传递 val 参数 iterator insert (const_iterator position, const value_type& val); //以右值引用的方式传递 val 键值对参数 template iterator insert (const_iterator position, P&& val); 其中 val 为要插入的键值对变量。注意，和第 1 种方式的语法格式不同，这里 insert() 方法返回的是迭代器，而不再是 pair 对象： 如果插入成功，insert() 方法会返回一个指向 map 容器中已插入键值对的迭代器； 如果插入失败，insert() 方法同样会返回一个迭代器，该迭代器指向 map 容器中和 val 具有相同键的那个键值对。 示例: //创建一个空 map 容器 std::map mymap; //创建一个真实存在的键值对变量 std::pair STL = { \"STL教程\",\"http://c.biancheng.net/stl/\" }; //指定要插入的位置 std::map::iterator it = mymap.begin(); //向 it 位置以普通引用的方式插入 STL auto iter1 = mymap.insert(it, STL); cout first second (\"C语言教程\", \"http://c.biancheng.net/c/\")); cout first second (\"STL教程\", \"http://c.biancheng.net/java/\")); 利用insert() 方法向当前 map 容器中插入其它 map 容器指定区域内的所有键值对 template void insert (InputIterator first, InputIterator last); 其中 first 和 last 都是迭代器，它们的组合可以表示某 map 容器中的指定区域。 示例: //创建并初始化 map 容器 std::mapmymap{ {\"STL教程\",\"http://c.biancheng.net/stl/\"}, {\"C语言教程\",\"http://c.biancheng.net/c/\"}, {\"Java教程\",\"http://c.biancheng.net/java/\"} }; //创建一个空 map 容器 std::mapcopymap; //指定插入区域 std::map::iterator first = ++mymap.begin(); std::map::iterator last = mymap.end(); //将区域内的键值对插入到 copymap 中 copymap.insert(first, last); 1234567891011 利用insert() 方法一次向 map 容器中插入多个键值对 void insert ({val1, val2, ...}); 其中，vali 都表示的是键值对变量。 示例: //创建空的 map 容器 std::mapmymap; //向 mymap 容器中添加 3 个键值对 mymap.insert({ {\"STL教程\", \"http://c.biancheng.net/stl/\"}, { \"C语言教程\",\"http://c.biancheng.net/c/\" }, { \"Java教程\",\"http://c.biancheng.net/java/\" } }); emplace(函数) 实现相同的插入操作，无论是用 emplace() 还是 emplace_hont()，都比 insert() 方法的效率高. 和 insert() 方法相比，emplace() 和 emplace_hint() 方法的使用要简单很多，因为它们各自只有一种语法格式。 template pair emplace (Args&&... args); 参数 (Args&&… args) 指的是，这里只需要将创建新键值对所需的数据作为参数直接传入即可，此方法可以自行利用这些数据构建出指定的键值对。 另外，该方法的返回值也是一个 pair 对象，其中 pair.first 为一个迭代器，pair.second 为一个 bool 类型变量： 当该方法将键值对成功插入到 map 容器中时，其返回的迭代器指向该新插入的键值对，同时 bool 变量的值为 true； 当插入失败时，则表明 map 容器中存在具有相同键的键值对，此时返回的迭代器指向此具有相同键的键值对，同时 bool 变量的值为 false。 示例: //创建并初始化 map 容器 std::mapmymap; //插入键值对 pair::iterator, bool> ret = mymap.emplace(\"STL教程\", \"http://c.biancheng.net/stl/\"); cout first second \" first second \" first second \" 3. multimap容器 multimap容器与map容器比较相似，multimap 容器也用于存储 pair 类型的键值对（其中 K 表示键的类型，T 表示值的类型），其中各个键值对的键的值不能做修改；并且，该容器也会自行根据键的大小对存储的所有键值对做排序操作。和 map 容器的区别在于，multimap 容器中可以同时存储多（≥2）个键相同的键值对。 multimap-使用前 和 map 容器一样，实现 multimap 容器的类模板也定义在头文件，并位于 std 命名空间中。因此，在使用 multimap 容器前，程序应包含如下代码： #include using namespace std; multimap-创建与初始化 创建一个空的map容器 std::multimapmymultimap; 在创建map容器的同时进行初始化 //创建并初始化 multimap 容器 multimapmymultimap{ {\"C语言教程\", \"http://c.biancheng.net/c/\"}, {\"Python教程\", \"http://c.biancheng.net/python/\"}, {\"STL教程\", \"http://c.biancheng.net/stl/\"} }; 利用已有的map容器创建新的map容器 multimapnewmultimap(mymultimap); 利用已有map容器中的部分键值对创建新的map容器 //创建并初始化 multimap 容器 multimapmymultimap{ {\"C语言教程\", \"http://c.biancheng.net/c/\"}, {\"Python教程\", \"http://c.biancheng.net/python/\"}, {\"STL教程\", \"http://c.biancheng.net/stl/\"} }; multimapnewmultimap(++mymultimap.begin(), mymultimap.end()); 在以上几种创建 map 容器的基础上，我们都可以手动修改 map 容器的排序规则。默认情况下，map 容器调用 std::less 规则，根据容器内各键值对的键的大小，对所有键值对做升序排序。 //以下两行等价 multimapmymultimap{ {'a',1},{'b',2} }; multimap>mymultimap{ {'a',1},{'b',2} }; 下面程序利用了 STL 模板库提供的std::greater排序函数，实现令 multimap 容器对存储的键值对做降序排序： multimap>mymultimap{ {'a',1},{'b',2} }; multimap-multimap 容器常用成员方法 成员方法 功能 begin() 返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 end() 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 rbegin() 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 rend() 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 find(key) 在 multimap 容器中查找首个键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 lower_bound(key) 返回一个指向当前 multimap 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 upper_bound(key) 返回一个指向当前 multimap 容器中第一个大于 key 的键值对的迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 equal_range(key) 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对。 empty() 若容器为空，则返回 true；否则 false。 size() 返回当前 multimap 容器中存有键值对的个数。 max_size() 返回 multimap 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。 insert() 向 multimap 容器中插入键值对。 erase() 删除 multimap 容器指定位置、指定键（key）值或者指定区域内的键值对。 swap() 交换 2 个 multimap 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。 clear() 清空 multimap 容器中所有的键值对，使 multimap 容器的 size() 为 0。 emplace() 在当前 multimap 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。 emplace_hint() 在本质上和 emplace() 在 multimap 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。 count(key) 在当前 multimap 容器中，查找键为 key 的键值对的个数并返回。 4. set 和 map、multimap 容器不同，使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。 set-使用前 值得一提的是，set 容器定义于头文件，并位于 std 命名空间中。因此如果想在程序中使用 set 容器，该程序代码应先包含如下语句： #include using namespace std; set 容器的类模板定义如下： template , // 指定 set 容器内部的排序规则 class Alloc = allocator // 指定分配器对象的类型 > class set; 注意，由于 set 容器存储的各个键值对，其键和值完全相同，也就意味着它们的类型相同，因此 set 容器类模板的定义中，仅有第 1 个参数用于设定存储数据的类型。 对于 set 类模板中的 3 个参数，后 2 个参数自带默认值，且几乎所有场景中只需使用前 2 个参数，第 3 个参数不会用到。 set-创建与初始化 创建空的set容器 std::set myset; 创建set容器的同时进行初始化 std::set myset{\"http://c.biancheng.net/java/\", \"http://c.biancheng.net/stl/\", \"http://c.biancheng.net/python/\"}; 利用已有set容器创建新的set容器(拷贝) std::set copyset(myset); //等同于 //std::set copyset = myset 利用已有set容器的部分元素创建新的set容器 std::set myset{ \"http://c.biancheng.net/java/\", \"http://c.biancheng.net/stl/\", \"http://c.biancheng.net/python/\" }; std::set copyset(++myset.begin(), myset.end()); 创建set容器的同时修改排序规则 std::set > myset{ \"http://c.biancheng.net/java/\", \"http://c.biancheng.net/stl/\", \"http://c.biancheng.net/python/\"}; set-set 容器常用成员方法 常用函数已加粗标出 成员方法 功能 begin() 返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 end() 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 rbegin() 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 rend() 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 find(val) 在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 lower_bound(val) 返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 upper_bound(val) 返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 equal_range(val) 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。 empty() 若容器为空，则返回 true；否则 false。 size() 返回当前 set 容器中存有元素的个数。 max_size() 返回 set 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。 insert() 向 set 容器中插入元素。 erase() 删除 set 容器中存储的元素。 swap() 交换 2 个 set 容器中存储的所有元素。这意味着，操作的 2 个 set 容器的类型必须相同。 clear() 清空 set 容器中所有的元素，即令 set 容器的 size() 为 0。 emplace() 在当前 set 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。 emplace_hint() 在本质上和 emplace() 在 set 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数 count(val) 在当前 set 容器中，查找值为 val 的元素的个数，并返回。注意，由于 set 容器中各元素的值是唯一的，因此该函数的返回值最大为 1。 emplace()系列函数比inser()系列函数效率更高,具体原因呢这里不再展开,看参考之前的讨论 set-set迭代器 和 map 容器不同，C++ STL 中的 set 容器类模板中未提供 at() 成员函数，也未对 [] 运算符进行重载。因此，要想访问 set 容器中存储的元素，只能借助 set 容器的迭代器。 值得一提的是，C++ STL 标准库为 set 容器配置的迭代器类型为双向迭代器。这意味着，假设 p 为此类型的迭代器，则其只能进行 ++p、p++、–p、p–、*p 操作，并且 2 个双向迭代器之间做比较，也只能使用 == 或者 != 运算符。 set-insert()函数详解 直接传值 //普通引用方式传参 pair insert (const value_type& val); //右值引用方式传参 pair insert (value_type&& val); 其中，val 表示要添加的新元素，该方法的返回值为 pair 类型。 以上 2 种格式的区别仅在于传递参数的方式不同，即第一种采用普通引用的方式传参，而第二种采用右值引用的方式传参。右值引用为 C++ 11 新添加的一种引用方式，可阅读《C++ 右值引用》一文做详细了解。 可以看到，以上 2 种语法格式的 insert() 方法，返回的都是 pair 类型的值，其包含 2 个数据，一个迭代器和一个 bool 值： 当向 set 容器添加元素成功时，该迭代器指向 set 容器新添加的元素，bool 类型的值为 true； 如果添加失败，即证明原 set 容器中已存有相同的元素，此时返回的迭代器就指向容器中相同的此元素，同时 bool 类型的值为 false。 示例: //创建并初始化set容器 std::set myset; //准备接受 insert() 的返回值 pair::iterator, bool> retpair; //采用普通引用传值方式 string str = \"http://c.biancheng.net/stl/\"; retpair = myset.insert(str); 将元素插入到指定位置 //以普通引用的方式传递 val 值 iterator insert (const_iterator position, const value_type& val); //以右值引用的方式传递 val 值 iterator insert (const_iterator position, value_type&& val); 以上 2 种语法格式中，insert() 函数的返回值为迭代器： 当向 set 容器添加元素成功时，该迭代器指向容器中新添加的元素； 当添加失败时，证明原 set 容器中已有相同的元素，该迭代器就指向 set 容器中相同的这个元素。 示例: //创建并初始化set容器 std::set myset; //准备接受 insert() 的返回值 set::iterator iter; //采用普通引用传值方式 string str = \"http://c.biancheng.net/stl/\"; iter = myset.insert(myset.begin(),str); //采用右值引用传值方式 iter = myset.insert(myset.end(),\"http://c.biancheng.net/python/\"); 向当前set容器插入其他set容器指定区域内的所有元素(两个set容器存储的元素类型要一致) template void insert (InputIterator first, InputIterator last); 其中 first 和 last 都是迭代器，它们的组合 [first,last) 可以表示另一 set 容器中的一块区域，该区域包括 first 迭代器指向的元素，但不包含 last 迭代器指向的元素。 示例: //创建并初始化set容器 std::set myset{ \"http://c.biancheng.net/stl/\", \"http://c.biancheng.net/python/\", \"http://c.biancheng.net/java/\" }; //创建一个同类型的空 set 容器 std::set otherset; //利用 myset 初始化 otherset otherset.insert(++myset.begin(), myset.end()); 一次向set容器中添加多个元素 void insert ( {E1, E2,...,En} ); 其中，Ei 表示新添加的元素。 示例: //创建并初始化set容器 std::set myset; //向 myset 中添加多个元素 myset.insert({ \"http://c.biancheng.net/stl/\", \"http://c.biancheng.net/python/\", \"http://c.biancheng.net/java/\" }); set-set删除数据 如果想删除 set 容器存储的元素，可以选择用 erase() 或者 clear() 成员方法。 set 类模板中，erase() 方法有 3 种语法格式，分别如下： //删除 set 容器中值为 val 的元素 size_type erase (const value_type& val); //删除 position 迭代器指向的元素 iterator erase (const_iterator position); //删除 [first,last) 区间内的所有元素 iterator erase (const_iterator first, const_iterator last); 其中，第 1 种格式的 erase() 方法，其返回值为一个整数，表示成功删除的元素个数；后 2 种格式的 erase() 方法，返回值都是迭代器，其指向的是 set 容器中删除元素之后的第一个元素。 注意，如果要删除的元素就是 set 容器最后一个元素，则 erase() 方法返回的迭代器就指向新 set 容器中最后一个元素之后的位置（等价于 end() 方法返回的迭代器）。 示例: //创建并初始化 set 容器 std::setmyset{1,2,3,4,5}; cout ::iterator iter = myset.erase(myset.begin()); //删除元素 1，myset={3,4,5} cout \" ::iterator iter2 = myset.erase(myset.begin(), --myset.end());//删除元素 3,4，myset={5} cout \" 如果需要删除 set 容器中存储的所有元素，可以使用 clear() 成员方法。该方法的语法格式如下： void clear(); 示例: //创建并初始化 set 容器 std::setmyset{1,2,3,4,5}; cout 5.multiset multiset-使用前 和 set 类模板一样，multiset 类模板也定义在头文件，并位于 std 命名空间中。这意味着，如果想在程序中使用 multiset 容器，该程序代码应包含如下语句： #include using namespace std; multiset 容器类模板的定义如下所示： template , // 指定容器内部的排序规则 class Alloc = allocator > // 指定分配器对象的类型 > class multiset; 显然，multiset 类模板有 3 个参数，其中后 2 个参数自带有默认值。值得一提的是，在实际使用中，我们最多只需要使用前 2 个参数即可，第 3 个参数不会用到。 multiset-创建与初始化 创建空的multiset容器 std::multiset mymultiset; 创建容器的同时进行初始化 std::multiset mymultiset{ \"http://c.biancheng.net/java/\", \"http://c.biancheng.net/stl/\", \"http://c.biancheng.net/python/\" }; 利用已有的multiset容器创建新的容器(拷贝) std::multiset copymultiset(mymultiset); //等同于 //std::multiset copymultiset = mymultiset; 利用已有的multiset容器的部分元素创建新的容器 std::multiset mymultiset{ \"http://c.biancheng.net/java/\", \"http://c.biancheng.net/stl/\", \"http://c.biancheng.net/python/\" }; std::set copymultiset(++mymultiset.begin(), mymultiset.end()); 创建容器的同时修改排序规则 std::multiset > mymultiset{ \"http://c.biancheng.net/java/\", \"http://c.biancheng.net/stl/\", \"http://c.biancheng.net/python/\" }; multiset-multiset 容器常用成员方法 重要方法已加粗标出 成员方法 功能 begin() 返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 end() 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 rbegin() 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 rend() 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 find(val) 在 multiset 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 lower_bound(val) 返回一个指向当前 multiset 容器中第一个大于或等于 val 的元素的双向迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 upper_bound(val) 返回一个指向当前 multiset 容器中第一个大于 val 的元素的迭代器。如果 multiset 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 equal_range(val) 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含所有值为 val 的元素。 empty() 若容器为空，则返回 true；否则 false。 size() 返回当前 multiset 容器中存有元素的个数。 max_size() 返回 multiset 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。 insert() 向 multiset 容器中插入元素。 erase() 删除 multiset 容器中存储的指定元素。 swap() 交换 2 个 multiset 容器中存储的所有元素。这意味着，操作的 2 个 multiset 容器的类型必须相同。 clear() 清空 multiset 容器中所有的元素，即令 multiset 容器的 size() 为 0。 emplace() 在当前 multiset 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。 emplace_hint() 本质上和 emplace() 在 multiset 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。 count(val) 在当前 multiset 容器中，查找值为 val 的元素的个数，并返回。 注意，虽然 multiset 容器和 set 容器拥有的成员方法完全相同，但由于 multiset 容器允许存储多个值相同的元素，因此诸如 count()、find()、lower_bound()、upper_bound()、equal_range()等方法，更常用于 multiset 容器。 1.3 无序关联式容器 和关联式容器一样，无序容器也使用键值对（pair 类型）的方式存储数据。不过，本教程将二者分开进行讲解，因为它们有本质上的不同： 关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构； 无序容器的底层实现采用的是哈希表的存储结构。 C++ STL 底层采用哈希表实现无序容器时，会将所有数据存储到一整块连续的内存空间中，并且当数据存储位置发生冲突时，解决方法选用的是“链地址法”（又称“开链法”）。 基于底层实现采用了不同的数据结构，因此和关联式容器相比，无序容器具有以下 2 个特点： 无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键， 和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。 无序容器种类 无序容器 功能 unordered_map 存储键值对 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。 unordered_multimap 和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。 unordered_set 不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。 unordered_multiset 和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。 注意:以上 4 种无序容器的名称，仅是在前面所学的 4 种关联式容器名称的基础上，添加了 “unordered_”。如果读者已经学完了 map、multimap、set 和 multiset 容器不难发现，以 map 和 unordered_map 为例，其实它们仅有一个区别，即 map 容器内存会对存储的键值对进行排序，而 unordered_map 不会。 针对有序容器和无序容器的使用选择，总的来说，实际场景中如果涉及大量遍历容器的操作，建议首选关联式容器；反之，如果更多的操作是通过键获取对应的值，则应首选无序容器。 1. unordered_map unordered_map-使用前 unordered_map 容器在头文件中，并位于 std 命名空间中。因此，如果想使用该容器，代码中应包含如下语句： #include using namespace std; unordered_map 容器模板的定义如下所示： template , //容器内部存储键值对所用的哈希函数 class Pred = equal_to, //判断各个键值对键相同的规则 class Alloc = allocator > // 指定分配器对象的类型 > class unordered_map; 以上 5 个参数中，必须显式给前 2 个参数传值，并且除特殊情况外，最多只需要使用前 4 个参数，各自的含义和功能如表 1 所示。 unordered_map - 创建与初始化 创建一个空的unordered_map容器 std::unordered_mapumap; 在创建unordered_map容器的同时进行初始化 std::unordered_mapumap{ {\"C语言教程\",10},{\"STL教程\",20} }; 利用已有的unordered_map容器创建新的map容器 std::unordered_mapumap2(umap); 利用已有map容器中的部分键值对创建新的map容器 std::unordered_mapumap{ {\"C语言教程\",10},{\"STL教程\",20} }; std::unordered_mapumap2(++umap.begin(), umap.end()); unordered_map - unordered_map类模板成员方法 unordered_map类模板成员方法 成员方法 功能 begin() 返回指向容器中第一个键值对的正向迭代器。 end() 返回指向容器中最后一个键值对之后位置的正向迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。 empty() 若容器为空，则返回 true；否则 false。 size() 返回当前容器中存有键值对的个数。 max_size() 返回容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。 operator[key] 该模板类中重载了 [] 运算符，其功能是可以向访问数组中元素那样，只要给定某个键值对的键 key，就可以获取该键对应的值。注意，如果当前容器中没有以 key 为键的键值对，则其会使用该键向当前容器中插入一个新键值对。 at(key) 返回容器中存储的键 key 对应的值，如果 key 不存在，则会抛出 out_of_range 异常。 find(key) 查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。 count(key) 在容器中查找以 key 键的键值对的个数。 equal_range(key) 返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。 emplace() 向容器中添加新键值对，效率比 insert() 方法高。 emplace_hint() 向容器中添加新键值对，效率比 insert() 方法高。 insert() 向容器中添加新键值对。 erase() 删除指定键值对。 clear() 清空容器，即删除容器中存储的所有键值对。 swap() 交换 2 个 unordered_map 容器存储的键值对，前提是必须保证这 2 个容器的类型完全相等。 bucket_count() 返回当前容器底层存储键值对时，使用桶（一个线性链表代表一个桶）的数量。 max_bucket_count() 返回当前系统中，unordered_map 容器底层最多可以使用多少桶。 bucket_size(n) 返回第 n 个桶中存储键值对的数量。 bucket(key) 返回以 key 为键的键值对所在桶的编号。 load_factor() 返回 unordered_map 容器中当前的负载因子。负载因子，指的是的当前容器中存储键值对的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。 max_load_factor() 返回或者设置当前 unordered_map 容器的负载因子。 rehash(n) 将当前容器底层使用桶的数量设置为 n。 reserve() 将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。 hash_function() 返回当前容器使用的哈希函数对象。 unordered_map - unordered_map获取元素 使用重载运算符[ ] unordered_map umap{ {\"Python教程\",\"http://c.biancheng.net/python/\"}, {\"Java教程\",\"http://c.biancheng.net/java/\"}, {\"Linux教程\",\"http://c.biancheng.net/linux/\"} }; //获取 \"Java教程\" 对应的值 string str = umap[\"Java教程\"]; cout 注意:若当前容器中并没有存储以 [ ] 运算符内指定的元素作为键的键值对，则此时 [ ] 运算符的功能将转变为：向当前容器中添加以目标元素为键的键值对。 使用at函数 unordered_map umap{ {\"Python教程\",\"http://c.biancheng.net/python/\"}, {\"Java教程\",\"http://c.biancheng.net/java/\"}, {\"Linux教程\",\"http://c.biancheng.net/linux/\"} }; //获取指定键对应的值 string str = umap.at(\"Python教程\"); cout 注意:和使用 [ ] 运算符一样，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出out_of_range异常。 使用find()函数 //创建 umap 容器 unordered_map umap{ {\"Python教程\",\"http://c.biancheng.net/python/\"}, {\"Java教程\",\"http://c.biancheng.net/java/\"}, {\"Linux教程\",\"http://c.biancheng.net/linux/\"} }; //查找成功 unordered_map::iterator iter = umap.find(\"Python教程\"); cout first second ::iterator iter2 = umap.find(\"GO教程\"); if (iter2 == umap.end()) { cout 通过 find() 方法得到的是一个正向迭代器，该迭代器的指向分以下 2 种情况： 当 find() 方法成功找到以指定元素作为键的键值对时，其返回的迭代器就指向该键值对； 当 find() 方法查找失败时，其返回的迭代器和 end() 方法返回的迭代器一样，指向容器中最后一个键值对之后的位置。 通过迭代器遍历整个容器 //创建 umap 容器 unordered_map umap{ {\"Python教程\",\"http://c.biancheng.net/python/\"}, {\"Java教程\",\"http://c.biancheng.net/java/\"}, {\"Linux教程\",\"http://c.biancheng.net/linux/\"} }; //遍历整个容器中存储的键值对 for (auto iter = umap.begin(); iter != umap.end(); ++iter) { //判断当前的键值对是否就是要找的 if (!iter->first.compare(\"Java教程\")) { cout second unordered_map -insert() insert() 方法可以将 pair 类型的键值对元素添加到 unordered_map 容器中 //以普通方式传递参数 pair insert ( const value_type& val ); //以右值引用的方式传递参数 template pair insert ( P&& val ); 参数 val 表示要添加到容器中的目标键值对元素；该方法的返回值为 pair类型值，内部包含一个 iterator 迭代器和 bool 变量： 当 insert() 将 val 成功添加到容器中时，返回的迭代器指向新添加的键值对，bool 值为 True； 当 insert() 添加键值对失败时，意味着当前容器中本就存储有和要添加键值对的键相等的键值对，这种情况下，返回的迭代器将指向这个导致插入操作失败的迭代器，bool 值为 False。 示例: //创建一个空 map 容器 std::map mymap; //创建一个真实存在的键值对变量 std::pair STL = { \"STL教程\",\"http://c.biancheng.net/stl/\" }; //指定要插入的位置 std::map::iterator it = mymap.begin(); //向 it 位置以普通引用的方式插入 STL auto iter1 = mymap.insert(it, STL); cout first second (\"C语言教程\", \"http://c.biancheng.net/c/\")); cout first second (\"STL教程\", \"http://c.biancheng.net/java/\")); insert() 方法还可以指定新键值对要添加到容器中的位置 //以普通方式传递 val 参数 iterator insert ( const_iterator hint, const value_type& val ); //以右值引用方法传递 val 参数 template iterator insert ( const_iterator hint, P&& val ); 其中 first 和 last 都是迭代器，它们的组合可以表示某 map 容器中的指定区域。 示例: //创建空 umap 容器 unordered_map umap; //构建要添加的键值对 std::pairmypair(\"STL教程\", \"http://c.biancheng.net/stl/\"); //创建接收 insert() 方法返回值的迭代器类型变量 unordered_map::iterator iter; //调用第一种语法格式 iter = umap.insert(umap.begin(), mypair); //调用第二种语法格式 iter = umap.insert(umap.begin(),std::make_pair(\"Python教程\", \"http://c.biancheng.net/python/\")); insert() 方法还支持将某一个 unordered_map 容器中指定区域内的所有键值对，复制到另一个 unordered_map 容器中 void insert ({val1, val2, ...}); 其中，vali 都表示的是键值对变量。 示例: //创建空的 map 容器 std::mapmymap; //向 mymap 容器中添加 3 个键值对 mymap.insert({ {\"STL教程\", \"http://c.biancheng.net/stl/\"}, { \"C语言教程\",\"http://c.biancheng.net/c/\" }, { \"Java教程\",\"http://c.biancheng.net/java/\" } }); insert() 方法还支持一次向 unordered_map 容器添加多个键值对，其语法格式如下： void insert ( initializer_list il ); 参数 (Args&&… args) 指的是，这里只需要将创建新键值对所需的数据作为参数直接传入即可，此方法可以自行利用这些数据构建出指定的键值对。 另外，该方法的返回值也是一个 pair 对象，其中 pair.first 为一个迭代器，pair.second 为一个 bool 类型变量： 当该方法将键值对成功插入到 map 容器中时，其返回的迭代器指向该新插入的键值对，同时 bool 变量的值为 true； 当插入失败时，则表明 map 容器中存在具有相同键的键值对，此时返回的迭代器指向此具有相同键的键值对，同时 bool 变量的值为 false。 示例: //创建空的 umap 容器 unordered_map umap; //向 umap 容器同时添加多个键值对 umap.insert({ {\"STL教程\",\"http://c.biancheng.net/stl/\"}, {\"Python教程\",\"http://c.biancheng.net/python/\"}, {\"Java教程\",\"http://c.biancheng.net/java/\"} }); unordered_map-unordered_map删除元素 C++ STL 标准库为了方便用户可以随时删除 unordered_map 容器中存储的键值对，unordered_map 容器类模板中提供了以下 2 个成员方法： erase()：删除 unordered_map 容器中指定的键值对； clear()：删除 unordered_map 容器中所有的键值对，即清空容器。 erase()函数 erase() 方法可以接受一个正向迭代器，并删除该迭代器指向的键值对。该方法的语法格式如下 iterator erase ( const_iterator position ); 示例: cout ::iterator ret; //删除容器中第一个键值对 ret = umap.erase(umap.begin()); 我们还可以直接将要删除键值对的键作为参数直接传给 erase() 方法，该方法会自行去 unordered_map 容器中找和给定键相同的键值对，将其删除。 size_type erase ( const key_type& k ); int delNum = umap.erase(\"Python教程\"); 除了支持删除 unordered_map 容器中指定的某个键值对，erase() 方法还支持一次删除指定范围内的所有键值对 iterator erase ( const_iterator first, const_iterator last ); //创建 umap 容器 unordered_map umap{ {\"STL教程\", \"http://c.biancheng.net/stl/\"}, {\"Python教程\", \"http://c.biancheng.net/python/\"}, {\"Java教程\", \"http://c.biancheng.net/java/\"} }; //first 指向第一个键值对 unordered_map::iterator first = umap.begin(); //last 指向最后一个键值对 unordered_map::iterator last = --umap.end(); //删除[fist,last)范围内的键值对 auto ret = umap.erase(first, last); 2. unordered_multimap unordered_multimap-使用前 STL 标准库中实现 unordered_multimap 容器的模板类并没有定义在以自己名称命名的头文件中，而是和 unordered_map 容器一样，定义在头文件，且位于 std 命名空间中。因此，在使用 unordered_multimap 容器之前，程序中应包含如下 2 行代码： #include using namespace std; unordered_multimap 容器模板的定义如下所示： template , //底层存储键值对时采用的哈希函数 class Pred = equal_to, //判断各个键值对的键相等的规则 class Alloc = allocator > // 指定分配器对象的类型 > class unordered_multimap; 以上 5 个参数中，必须显式给前 2 个参数传值，且除极个别的情况外，最多只使用前 4 个参数 unordered_multimap-创建与初始化 创建一个空的unordered_multimap容器 std::unordered_multimapmyummap; 在创建unordered_multimap容器的同时进行初始化 std::unordered_multimapumap{ {\"C语言教程\",10},{\"STL教程\",20} }; 利用已有的unordered_multimap容器创建新的map容器 std::unordered_mapmyummap2(myummap); 利用已有unordered_multimap容器中的部分键值对创建新的map容器 std::unordered_multimapmyummap{ {\"C语言教程\",10},{\"STL教程\",20} }; std::unordered_multimapmyummap2(++myummap.begin(), umap.end()); unordered_multimap类模板成员方法 成员方法 功能 begin() 返回指向容器中第一个键值对的正向迭代器。 end() 返回指向容器中最后一个键值对之后位置的正向迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。 empty() 若容器为空，则返回 true；否则 false。 size() 返回当前容器中存有键值对的个数。 max_size() 返回容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。 find(key) 查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。 count(key) 在容器中查找以 key 键的键值对的个数。 equal_range(key) 返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。 emplace() 向容器中添加新键值对，效率比 insert() 方法高。 emplace_hint() 向容器中添加新键值对，效率比 insert() 方法高。 insert() 向容器中添加新键值对。 erase() 删除指定键值对。 clear() 清空容器，即删除容器中存储的所有键值对。 swap() 交换 2 个 unordered_multimap 容器存储的键值对，前提是必须保证这 2 个容器的类型完全相等。 bucket_count() 返回当前容器底层存储键值对时，使用桶（一个线性链表代表一个桶）的数量。 max_bucket_count() 返回当前系统中，unordered_multimap 容器底层最多可以使用多少桶。 bucket_size(n) 返回第 n 个桶中存储键值对的数量。 bucket(key) 返回以 key 为键的键值对所在桶的编号。 load_factor() 返回 unordered_multimap 容器中当前的负载因子。负载因子，指的是的当前容器中存储键值对的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。 max_load_factor() 返回或者设置当前 unordered_multimap 容器的负载因子。 rehash(n) 将当前容器底层使用桶的数量设置为 n。 reserve() 将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。 hash_function() 返回当前容器使用的哈希函数对象。 3. unordered_set unordered_set-使用前 实现 unordered_set 容器的模板类定义在头文件，并位于 std 命名空间中。这意味着，如果程序中需要使用该类型容器，则首先应该包含如下代码： #include using namespace std; unordered_set 容器的类模板定义如下： template , //确定元素存储位置所用的哈希函数 class Pred = equal_to, //判断各个元素是否相等所用的函数 class Alloc = allocator //指定分配器对象的类型 > class unordered_set; 可以看到，以上 4 个参数中，只有第一个参数没有默认值，这意味着如果我们想创建一个 unordered_set 容器，至少需要手动传递 1 个参数。事实上，在 99% 的实际场景中最多只需要使用前 3 个参数（各自含义如表 1 所示），最后一个参数保持默认值即可。 unordered_set-创建与初始化 创建一个空的unordered_set 容器 std::unordered_set uset; 在创建unordered_set 容器的同时进行初始化 std::unordered_set uset{ \"http://c.biancheng.net/c/\", \"http://c.biancheng.net/java/\", \"http://c.biancheng.net/linux/\" }; 利用已有的unordered_set 容器创建新的unordered_set 容器 std::unordered_set uset2(uset); 利用已有unordered_set 容器中的部分键值对创建新的unordered_set 容器 //传入 2 个迭代器， std::unordered_set uset2(++uset.begin(),uset.end()); unordered_set - unordered_set 类模板成员方法 成员方法 功能 begin() 返回指向容器中第一个元素的正向迭代器。 end(); 返回指向容器中最后一个元素之后位置的正向迭代器。 cbegin() 和 begin() 功能相同，只不过其返回的是 const 类型的正向迭代器。 cend() 和 end() 功能相同，只不过其返回的是 const 类型的正向迭代器。 empty() 若容器为空，则返回 true；否则 false。 size() 返回当前容器中存有元素的个数。 max_size() 返回容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。 find(key) 查找以值为 key 的元素，如果找到，则返回一个指向该元素的正向迭代器；反之，则返回一个指向容器中最后一个元素之后位置的迭代器（如果 end() 方法返回的迭代器）。 count(key) 在容器中查找值为 key 的元素的个数。 equal_range(key) 返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中值为 key 的元素所在的范围。 emplace() 向容器中添加新元素，效率比 insert() 方法高。 emplace_hint() 向容器中添加新元素，效率比 insert() 方法高。 insert() 向容器中添加新元素。 erase() 删除指定元素。 clear() 清空容器，即删除容器中存储的所有元素。 swap() 交换 2 个 unordered_map 容器存储的元素，前提是必须保证这 2 个容器的类型完全相等。 bucket_count() 返回当前容器底层存储元素时，使用桶（一个线性链表代表一个桶）的数量。 max_bucket_count() 返回当前系统中，unordered_map 容器底层最多可以使用多少桶。 bucket_size(n) 返回第 n 个桶中存储元素的数量。 bucket(key) 返回值为 key 的元素所在桶的编号。 load_factor() 返回 unordered_map 容器中当前的负载因子。负载因子，指的是的当前容器中存储元素的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。 max_load_factor() 返回或者设置当前 unordered_map 容器的负载因子。 rehash(n) 将当前容器底层使用桶的数量设置为 n。 reserve() 将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。 hash_function() 返回当前容器使用的哈希函数对象。 4. unordered_multiset unordered_multiset-使用前 实现 unordered_multiset 容器的模板类并没有定义在以该容器名命名的文件中，而是和 unordered_set 容器共用同一个头文件，并且也位于 std 命名空间。因此，如果程序中需要使用该类型容器，应包含如下代码： #include using namespace std; unordered_multiset 容器类模板的定义如下： 纯文本复制 template , //确定元素存储位置所用的哈希函数 class Pred = equal_to, //判断各个元素是否相等所用的函数 class Alloc = allocator //指定分配器对象的类型 > class unordered_multiset; 需要说明的是，在 99% 的实际场景中，最多只需要使用前 3 个参数（各自含义如表 1 所示），最后一个参数保持默认值即可。 unordered_multiset-创建与初始化 创建一个空的unordered_multiset 容器 std::unordered_multiset umset; 在创建unordered_multiset 容器的同时进行初始化 std::unordered_multiset umset{ \"http://c.biancheng.net/c/\", \"http://c.biancheng.net/java/\", \"http://c.biancheng.net/linux/\" }; 利用已有的unordered_multiset 容器创建新的unordered_multiset 容器 std::unordered_multiset umset2(umset); 利用已有unordered_set 容器中的部分键值对创建新的unordered_set 容器 //传入 2 个迭代器， std::unordered_multiset umset2(++umset.begin(), umset.end()); unordered_set 类模板成员方法 成员方法 功能 begin() 返回指向容器中第一个元素的正向迭代器。 end(); 返回指向容器中最后一个元素之后位置的正向迭代器。 cbegin() 和 begin() 功能相同，只不过其返回的是 const 类型的正向迭代器。 cend() 和 end() 功能相同，只不过其返回的是 const 类型的正向迭代器。 empty() 若容器为空，则返回 true；否则 false。 size() 返回当前容器中存有元素的个数。 max_size() 返回容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。 find(key) 查找以值为 key 的元素，如果找到，则返回一个指向该元素的正向迭代器；反之，则返回一个指向容器中最后一个元素之后位置的迭代器（如果 end() 方法返回的迭代器）。 count(key) 在容器中查找值为 key 的元素的个数。 equal_range(key) 返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中值为 key 的元素所在的范围。 emplace() 向容器中添加新元素，效率比 insert() 方法高。 emplace_hint() 向容器中添加新元素，效率比 insert() 方法高。 insert() 向容器中添加新元素。 erase() 删除指定元素。 clear() 清空容器，即删除容器中存储的所有元素。 swap() 交换 2 个 unordered_multimap 容器存储的元素，前提是必须保证这 2 个容器的类型完全相等。 bucket_count() 返回当前容器底层存储元素时，使用桶（一个线性链表代表一个桶）的数量。 max_bucket_count() 返回当前系统中，容器底层最多可以使用多少桶。 bucket_size(n) 返回第 n 个桶中存储元素的数量。 bucket(key) 返回值为 key 的元素所在桶的编号。 load_factor() 返回容器当前的负载因子。所谓负载因子，指的是的当前容器中存储元素的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。 max_load_factor() 返回或者设置当前 unordered_map 容器的负载因子。 rehash(n) 将当前容器底层使用桶的数量设置为 n。 reserve() 将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。 hash_function() 返回当前容器使用的哈希函数对象。 1.4 其他 1.String String - 创建与初始化 构造 string strs ;//生成空字符串 string s(str);//生成字符串str的复制品 string s(str, stridx) ; //将字符串str中始于stridx的部分作为构造函数的初值 string s(str, strbegin, strlen); //将字符串str中始于strbegin、长度为strlen的部分作为字符串初值 string s(cstr);//以C_string类型cstr作为字符串s的初值 string s(cstr,char_len);//以C_string类型cstr的前char_len个字符串作为字符串s的初值 string s(num, c);//生成一个字符串，包含num个c字符 string s(strs, beg, end) ;//以区间[beg, end]内的字符作为字符串s的初值 析构 ~string() ; //销毁所有内存，释放内存 String - string 类的所有成员函数 函数名称 功能 构造函数 产生或复制字符串 析构函数 销毁字符串 =，assign 赋以新值 Swap 交换两个字符串的内容 + =，append( )，push_back() 添加字符 insert () 插入字符 erase() 删除字符 clear () 移除全部字符 resize () 改变字符数量 replace() 替换字符 + 串联字符串 ==，！ =，，>=，compare() 比较字符串内容 size()，length() 返回字符数量 max_size () 返回字符的最大可能个数 empty () 判断字符串是否为空 capacity () 返回重新分配之前的字符容量 reserve() 保留内存以存储一定数量的字符 [],at() 存取单一字符 >>，getline() 从 stream 中读取某值 将值写入 stream copy() 将内容复制为一个 C - string c_str() 将内容以 C - string 形式返回 data() 将内容以字符数组形式返回 substr() 返回子字符串 find() 搜寻某子字符串或字符 begin( )，end() 提供正向迭代器支持 rbegin()，rend() 提供逆向迭代器支持 get_allocator() 返回配置器 2.栈 栈-使用前 由于 stack 适配器以模板类 stack（其中 T 为存储元素的类型，Container 表示底层容器的类型）的形式位于头文件中，并定义在 std 命名空间里。因此，在创建该容器之前，程序中应包含以下 2 行代码： #include using namespace std; 栈-创建与初始化 创建一个不包含任何元素的 stack 适配器，并采用默认的 deque 基础容器 std::stack values; stack 模板类提供了 2 个参数，通过指定第二个模板类型参数，我们可以使用出 deque 容器外的其它序列式容器，只要该容器支持 empty()、size()、back()、push_back()、pop_back() 这 5 个成员函数即可。 std::stack> values; 可以用一个基础容器来初始化 stack 适配器，只要该容器的类型和 stack 底层使用的基础容器类型相同即可。 std::list values {1, 2, 3}; std::stack> my_stack (values); 可以用一个 stack 适配器来初始化另一个 stack 适配器，只要它们存储的元素类型以及底层采用的基础容器类型相同即可。 std::list values{ 1, 2, 3 }; std::stack> my_stack1(values); std::stack> my_stack=my_stack1; //std::stack> my_stack(my_stack1); 栈-常用函数 stack容器适配器支持的成员函数 成员函数 功能 empty() 当 stack 栈中没有元素时，该成员函数返回 true；反之，返回 false。 size() 返回 stack 栈中存储元素的个数。 top() 返回一个栈顶元素的引用，类型为 T&。如果栈为空，程序会报错。 push(const T& val) 先复制 val，再将 val 副本压入栈顶。这是通过调用底层容器的 push(T&& obj) 以移动元素的方式将其压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。 pop() 弹出栈顶元素。 emplace(arg…) arg… 可以是一个参数，也可以是多个参数，但它们都只用于构造一个对象，并在栈顶直接生成该对象，作为新的栈顶元素。 swap(stack & other_stack) 将两个 stack 适配器中的元素进行互换，需要注意的是，进行互换的 2 个 stack 适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。 3.queue queue- 使用前 queue 容器适配器以模板类 queue（其中 T 为存储元素的类型，Container 表示底层容器的类型）的形式位于头文件中，并定义在 std 命名空间里。因此，在创建该容器之前，程序中应包含以下 2 行代码： #include using namespace std; queue-创建与初始化 创建一个空的 queue 容器适配器，其底层使用的基础容器选择默认的 deque 容器 std::queue values; 手动指定 queue 容器适配器底层采用的基础容器类型 作为 queue 容器适配器的基础容器，其必须提供 front()、back()、push_back()、pop_front()、empty() 和 size() 这几个成员函数，符合条件的序列式容器仅有 deque 和 list。 可以用基础容器来初始化 queue 容器适配器，只要该容器类型和 queue 底层使用的基础容器类型相同即可。 std::deque values{1,2,3}; std::queue my_queue(values); 可以直接通过 queue 容器适配器来初始化另一个 queue 容器适配器，只要它们存储的元素类型以及底层采用的基础容器类型相同即可。 std::deque values{1,2,3}; std::queue my_queue1(values); std::queue my_queue(my_queue1); //或者使用 //std::queue my_queue = my_queue1; queue-queue容器适配器支持的成员函数 成员函数 功能 empty() 如果 queue 中没有元素的话，返回 true。 size() 返回 queue 中元素的个数。 front() 返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 back() 返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 push(const T& obj) 在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。 emplace() 在 queue 的尾部直接添加一个元素。 push(T&& obj) 以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。 pop() 删除 queue 中的第一个元素。 swap(queue &other_queue) 将两个 queue 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 queue 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。 4.priority_queue（优先队列） priority_queue 容器适配器模拟的也是队列这种存储结构，即使用此容器适配器存储元素只能“从一端进（称为队尾），从另一端出（称为队头）”，且每次只能访问 priority_queue 中位于队头的元素。 但是，priority_queue 容器适配器中元素的存和取，遵循的并不是 “First in,First out”（先入先出）原则，而是“First in，Largest out”原则。直白的翻译，指的就是先进队列的元素并不一定先出队列，而是优先级最大的元素最先出队列。 priority_queue-使用前 由于 priority_queue 容器适配器模板位于头文件中，并定义在 std 命名空间里，因此在试图创建该类型容器之前，程序中需包含以下 2 行代码： #include using namespace std; priority_queue-创建与初始化 创建一个空的 priority_queue 容器适配器，第底层采用默认的 vector 容器，排序方式也采用默认的 std::less 方法 std::priority_queue values; 可以使用普通数组或其它容器中指定范围内的数据，对 priority_queue 容器适配器进行初始化 //使用普通数组 int values[]{4,1,3,2}; std::priority_queuecopy_values(values,values+4);//{4,2,3,1} //使用序列式容器 std::arrayvalues{ 4,1,3,2 }; std::priority_queuecopy_values(values.begin(),values.end());//{4,2,3,1} 可以手动指定 priority_queue 使用的底层容器以及排序规则 int values[]{ 4,1,2,3 }; std::priority_queue, std::greater >copy_values(values, values+4);//{1,3,2,4} priority_queue-常用函数 priority_queue 提供的成员函数 成员函数 功能 empty() 如果 priority_queue 为空的话，返回 true；反之，返回 false。 size() 返回 priority_queue 中存储元素的个数。 top() 返回 priority_queue 中第一个元素的引用形式。 push(const T& obj) 根据既定的排序规则，将元素 obj 的副本存储到 priority_queue 中适当的位置。 push(T&& obj) 根据既定的排序规则，将元素 obj 移动存储到 priority_queue 中适当的位置。 emplace(Args&&… args) Args&&… args 表示构造一个存储类型的元素所需要的数据（对于类对象来说，可能需要多个数据构造出一个对象）。此函数的功能是根据既定的排序规则，在容器适配器适当的位置直接生成该新元素。 pop() 移除 priority_queue 容器适配器中第一个元素。 swap(priority_queue& other) 将两个 priority_queue 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 priority_queue 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。 2. 迭代器定义 常用的迭代器按功能强弱分为输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器 5 种。 前向迭代器（# iterator） 假设 p 是一个前向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 == 和 != 运算符进行比较。此外，两个正向迭代器可以互相赋值。 双向迭代器（bidirectional iterator） 双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 --p 或者 p-- 操作（即一次向后移动一个位置）。 随机访问迭代器（random access iterator） 随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作： p+=i：使得 p 往后移动 i 个元素。 p-=i：使得 p 往前移动 i 个元素。 p+i：返回 p 后面第 i 个元素的迭代器。 p-i：返回 p 前面第 i 个元素的迭代器。 p[i]：返回 p 后面第 i 个元素的引用。 此外，两个随机访问迭代器 p1、p2 还可以用 、= 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。 迭代器定义方式 迭代器定义方式 具体格式 正向迭代器 容器类名::iterator 迭代器名; 常量正向迭代器 容器类名::const_iterator 迭代器名; 反向迭代器 容器类名::reverse_iterator 迭代器名; 常量反向迭代器 容器类名::const_reverse_iterator 迭代器名; 反向迭代器和正向迭代器的区别在于： 对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素； 而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。 反向迭代器重载的运算符 重载运算符 功能 operator* 以引用的形式返回当前迭代器指向的元素。 operator+ 返回一个反向迭代器，其指向距离当前指向的元素之后 n 个位置的元素。此操作要求基础迭代器为随机访问迭代器。 operator++ 重载前置 ++ 和后置 ++ 运算符。 operator+= 当前反向迭代器前进 n 个位置，此操作要求基础迭代器为随机访问迭代器。 operator- 返回一个反向迭代器，其指向距离当前指向的元素之前 n 个位置的元素。此操作要求基础迭代器为随机访问迭代器。 operator– 重载前置 – 和后置 – 运算符。 operator-= 当前反向迭代器后退 n 个位置，此操作要求基础迭代器为随机访问迭代器。 operator-> 返回一个指针，其指向当前迭代器指向的元素。 operator[n] 访问和当前反向迭代器相距 n 个位置处的元素。 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/09-算法/常用的模板.html":{"url":"roccoshi_note/09-算法/常用的模板.html","title":"常用的模板","keywords":"","body":"常用的算法模板头文件埃拉托斯特尼筛法快速幂大数模拟大数加法大数阶乘GCDLCM全排二分搜索并查集KruskalPrimDijkstraSPFAfloyd二分图染色法背包LIS最长上升子序列LCS最长公共子序列计算几何向量基本用法求多边形面积判断线段相交求三角形外心极角排序字符串kmp扩展kmp字典树AC自动机线段树点更新区间更新树状数组中国剩余定理常用的算法模板 头文件 #define _CRT_SBCURE_NO_DEPRECATE #include #include #include #include #include #include #include #include #include #include #include #include using namespace std; const int maxn = 110; const int INF = 0x3f3f3f3f; 埃拉托斯特尼筛法 /* |埃式筛法| |快速筛选素数| |16/11/05ztx| */ int prime[maxn]; bool is_prime[maxn]; int sieve(int n){ int p = 0; for(int i = 0; i 快速幂 /* |埃式筛法| |快速筛选素数| |16/11/05ztx| */ int prime[maxn]; bool is_prime[maxn]; int sieve(int n){ int p = 0; for(int i = 0; i 大数模拟 大数加法 /* |大数模拟加法| |用string模拟| |16/11/05ztx, thanks to caojiji| */ string add1(string s1, string s2) { if (s1 == \"\" && s2 == \"\") return \"0\"; if (s1 == \"\") return s2; if (s2 == \"\") return s1; string maxx = s1, minn = s2; if (s1.length() = 0; --i){ maxx[a--] += minn[i] - '0'; // a一直在减 ， 额外还要减个'0' } for (int i = maxx.length()-1; i > 0;--i){ if (maxx[i] > '9'){ maxx[i] -= 10;//注意这个是减10 maxx[i - 1]++; } } if (maxx[0] > '9'){ maxx[0] -= 10; maxx = '1' + maxx; } return maxx; } 大数阶乘 /* |大数模拟加法| |用string模拟| |16/11/05ztx, thanks to caojiji| */ string add1(string s1, string s2) { if (s1 == \"\" && s2 == \"\") return \"0\"; if (s1 == \"\") return s2; if (s2 == \"\") return s1; string maxx = s1, minn = s2; if (s1.length() = 0; --i){ maxx[a--] += minn[i] - '0'; // a一直在减 ， 额外还要减个'0' } for (int i = maxx.length()-1; i > 0;--i){ if (maxx[i] > '9'){ maxx[i] -= 10;//注意这个是减10 maxx[i - 1]++; } } if (maxx[0] > '9'){ maxx[0] -= 10; maxx = '1' + maxx; } return maxx; } GCD /* |辗转相除法| |欧几里得算法| |求最大公约数| |16/11/05ztx| */ int gcd(int big, int small) { if (small > big) swap(big, small); int temp; while (small != 0){ // 辗转相除法 if (small > big) swap(big, small); temp = big % small; big = small; small = temp; } return(big); } LCM /* |辗转相除法| |欧几里得算法| |求最小公倍数| |16/11/05ztx| */ int gcd(int big, int small) { if (small > big) swap(big, small); int temp; while (small != 0){ // 辗转相除法 if (small > big) swap(big, small); temp = big % small; big = small; small = temp; } return(big); } 全排 /* |求1到n的全排列, 有条件| |16/11/05ztx, thanks to wangqiqi| */ void Pern(int list[], int k, int n) { // k表示前k个数不动仅移动后面n-k位数 if (k == n - 1) { for (int i = 0; i 二分搜索 /* |二分搜索| |要求：先排序| |16/11/05ztx, thanks to wangxiaocai| */ // left为最开始元素, right是末尾元素的下一个数，x是要找的数 int bsearch(int *A, int left, int right, int x){ int m; while (left = x) right = m; else left = m + 1; // 如果要替换为 upper_bound, 改为:if (A[m] 并查集 /* |合并节点操作| |16/11/05ztx, thanks to chaixiaojun| */ int father[maxn]; // 储存i的father父节点 void makeSet() { for (int i = 0; i Kruskal /* |合并节点操作| |16/11/05ztx, thanks to chaixiaojun| */ int father[maxn]; // 储存i的father父节点 void makeSet() { for (int i = 0; i Prim /* |合并节点操作| |16/11/05ztx, thanks to chaixiaojun| */ int father[maxn]; // 储存i的father父节点 void makeSet() { for (int i = 0; i Dijkstra /* |Dijkstra算法| |适用于边权为正的有向图或者无向图| |求从单个源点出发，到所有节点的最短路| |优化版：时间复杂度 O(elbn)| |16/11/05ztx, thanks to chaixiaojun| */ struct node { int v, len; node(int v = 0, int len = 0) :v(v), len(len) {} bool operator a.len; } }; vectorG[maxn]; bool vis[maxn]; int dis[maxn]; void init() { for (int i = 0; iQ; Q.push(node(s, 0)); // 加入队列并排序 dis[s] = 0; while (!Q.empty()) { node now = Q.top(); // 取出当前最小的 Q.pop(); int v = now.v; if (vis[v]) continue; // 如果标记过了, 直接continue vis[v] = true; for (int i = 0; i dis[v] + len) { dis[v2] = dis[v] + len; Q.push(node(v2, dis[v2])); } } } return dis[e]; } SPFA /* |SPFA算法| |队列优化| |可处理负环| */ vector G[maxn]; bool inqueue[maxn]; int dist[maxn]; void Init() { for(int i = 0 ; i Q; memset(inqueue,false,sizeof(inqueue)); // 标记是否在队列中 memset(cnt,0,sizeof(cnt)); // 加入队列的次数 dist[s] = 0; Q.push(s); // 起点加入队列 inqueue[s] = true; // 标记 while(!Q.empty()){ v1 = Q.front(); Q.pop(); inqueue[v1] = false; // 取消标记 for(int i = 0 ; i dist[v1] + weight){ // 松弛操作 dist[v2] = dist[v1] + weight; if(inqueue[v2] == false){ // 再次加入队列 inqueue[v2] = true; //cnt[v2]++; // 判负环 //if(cnt[v2] > n) return -1; Q.push(v2); } } } } return dist[e]; } /* 不断的将s的邻接点加入队列，取出不断的进行松弛操作，直到队列为空 如果一个结点被加入队列超过n-1次，那么显然图中有负环 */ floyd /* |Floyd算法| |任意点对最短路算法| |求图中任意两点的最短距离的算法| */ for (int i = 0; i 二分图染色法 /* |交叉染色法判断二分图| |16/11/05ztx| */ int bipartite(int s) { int u, v; queueQ; color[s] = 1; Q.push(s); while (!Q.empty()) { u = Q.front(); Q.pop(); for (int i = 0; i 背包 /* |01背包| |完全背包| |多重背包| |16/11/05ztx| */ // 01背包： void bag01(int cost,int weight) { for(i = v; i >= cost; --i) dp[i] = max(dp[i], dp[i-cost]+weight); } // 完全背包： void complete(int cost, int weight) { for(i = cost ; i = v) complete(cost, weight); else{ k = 1; while (k = c; --v) { dp[v] = max(dp[v], dp[v - c] + c); } } void multiplePack(int c, int m） { if (m * c > sum / 2) CompletePack(c); else{ int k = 1; while (k LIS最长上升子序列 /* |最长上升子序列| |状态转移| |16/11/05ztx| */ /* 状态转移dp[i] = max{ 1.dp[j] + 1 }; j LCS最长公共子序列 /* |求最长公共子序列| |递推形式| |16/11/05ztx| */ void solve() { for (int i = 0; i 计算几何 向量基本用法 /* |16/11/06ztx| */ struct node { double x; // 横坐标 double y; // 纵坐标 }; typedef node Vector; Vector operator + (Vector A, Vector B) { return Vector(A.x + B.x, A.y + B.y); } Vector operator - (Point A, Point B) { return Vector(A.x - B.y, A.y - B.y); } Vector operator * (Vector A, double p) { return Vector(A.x*p, A.y*p); } Vector operator / (Vector A, double p) { return Vector(A.x / p, A.y*p); } double Dot(Vector A, Vector B) { return A.x*B.x + A.y*B.y; } // 向量点乘 double Length(Vector A) { return sqrt(Dot(A, A)); } // 向量模长 double Angle(Vector A, Vector B) { return acos(Dot(A, B) / Length(A) / Length(B)); } // 向量之间夹角 double Cross(Vector A, Vector B) { // 叉积计算 公式 return A.x*B.y - A.y*B.x; } Vector Rotate(Vector A, double rad) // 向量旋转 公式 { return Vector(A.x*cos(rad) - A.y*sin(rad), A.x*sin(rad) + A.y*cos(rad)); } Point getLineIntersection(Point P, Vector v, Point Q, Vector w) { // 两直线交点t1 t2计算公式 Vector u = P - Q; double t = Cross(w, u) / Cross(v, w); // 求得是横坐标 return P + v*t; // 返回一个点 } 求多边形面积 /* |16/11/06ztx| */ node G[maxn]; int n; double Cross(node a, node b) { // 叉积计算 return a.x*b.y - a.y*b.x; } int main() { while (scanf(\"%d\", &n) != EOF && n) { for (int i = 0; i 判断线段相交 /* |16/11/06ztx| */ node P[35][105]; double Cross_Prouct(node A,node B,node C) { // 计算BA叉乘CA return (B.x-A.x)*(C.y-A.y)-(B.y-A.y)*(C.x-A.x); } bool Intersect(node A,node B,node C,node D) { // 通过叉乘判断线段是否相交； if(min(A.x,B.x) 求三角形外心 /* |16/11/06ztx| */ Point circumcenter(const Point &a, const Point &b, const Point &c) { //返回三角形的外心 Point ret; double a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1*a1 + b1*b1) / 2; double a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2*a2 + b2*b2) / 2; double d = a1*b2 - a2*b1; ret.x = a.x + (c1*b2 - c2*b1) / d; ret.y = a.y + (a1*c2 - a2*c1) / d; return ret; } 极角排序 /* |16/11/06ztx| */ double cross(point p1, point p2, point q1, point q2) { // 叉积计算 return (q2.y - q1.y)*(p2.x - p1.x) - (q2.x - q1.x)*(p2.y - p1.y); } bool cmp(point a, point b) { point o; o.x = o.y = 0; return cross(o, b, o, a) 字符串 kmp /* |kmp算法| |字符串匹配| |17/1/21ztx| */ void getnext(char str[maxn], int nextt[maxn]) { int j = 0, k = -1; nextt[0] = -1; while (j 扩展kmp /* |16/11/06ztx| */ #include #include using namespace std; const int MM=100005; int next[MM],extand[MM]; char S[MM],T[MM]; void GetNext(const char *T) { int len = strlen(T),a = 0; next[0] = len; while(a = p) { int j = (p - k + 1) > 0 ? (p - k + 1) : 0; while(k + j = p) { int j = (p - k + 1) > 0 ? (p - k + 1) : 0; while(k + j > S >> T) { GetExtand(S,T); show(next,strlen(T)); show(extand,strlen(S)); } return 0; } 字典树 /* |16/11/06ztx| */ struct Trie{ int cnt; Trie *next[maxn]; Trie(){ cnt = 0; memset(next,0,sizeof(next)); } }; Trie *root; void Insert(char *word) { Trie *tem = root; while(*word != '\\0') { int x = *word - 'a'; if(tem->next[x] == NULL) tem->next[x] = new Trie; tem = tem->next[x]; tem->cnt++; word++; } } int Search(char *word) { Trie *tem = root; for(int i=0;word[i]!='\\0';i++) { int x = word[i]-'a'; if(tem->next[x] == NULL) return 0; tem = tem->next[x]; } return tem->cnt; } void Delete(char *word,int t) { Trie *tem = root; for(int i=0;word[i]!='\\0';i++) { int x = word[i]-'a'; tem = tem->next[x]; (tem->cnt)-=t; } for(int i=0;inext[i] = NULL; } int main() { int n; char str1[50]; char str2[50]; while(scanf(\"%d\",&n)!=EOF) { root = new Trie; while(n--) { scanf(\"%s %s\",str1,str2); if(str1[0]=='i') { Insert(str2); }else if(str1[0] == 's') { if(Search(str2)) printf(\"Yes\\n\"); else printf(\"No\\n\"); }else { int t = Search(str2); if(t) Delete(str2,t); } } } return 0; } AC自动机 /* |16/11/06ztx| */ #include #include #include #include using namespace std; #define N 1000010 char str[N], keyword[N]; int head, tail; struct node { node *fail; node *next[26]; int count; node() { //init fail = NULL;// 默认为空 count = 0; for(int i = 0; i next[temp] == NULL) p->next[temp] = new node(); p = p->next[temp]; } p->count++; } void build_ac() { // 初始化fail指针，BFS 数组模拟队列： q[tail++] = root; while(head != tail) { node *p = q[head++]; // 弹出队头 node *temp = NULL; for(int i = 0; i next[i] != NULL) { if(p == root) { // 第一个元素fail必指向根 p->next[i]->fail = root; }else { temp = p->fail; // 失败指针 while(temp != NULL) { // 2种情况结束：匹配为空or找到匹配 if(temp->next[i] != NULL) { // 找到匹配 p->next[i]->fail = temp->next[i]; break; } temp = temp->fail; } if(temp == NULL) // 为空则从头匹配 p->next[i]->fail = root; } q[tail++] = p->next[i]; // 入队 } } } } int query() // 扫描 { int index, len, result; node *p = root; // Tire入口 result = 0; len = strlen(str); for(int i = 0; i next[index] == NULL && p != root) // 跳转失败指针 p = p->fail; p = p->next[index]; if(p == NULL) p = root; node *temp = p; // p不动，temp计算后缀串 while(temp != root && temp->count != -1) { result += temp->count; temp->count = -1; temp = temp->fail; } } return result; } int main() { int num; head= tail = 0; root = new node(); scanf(\"%d\", &num); getchar(); for(int i = 0; i 线段树 点更新 /* |16/12/07ztx| */ struct node { int left, right; int max, sum; }; node tree[maxn > 1; build(m > 1; if (a > 1; if (r mid){ return querySum(m > 1; if (r mid){ return queryMax(m 区间更新 /* |16/11/06ztx| */ typedef long long ll; const int maxn = 100010; int t,n,q; ll anssum; struct node{ ll l,r; ll addv,sum; }tree[maxn= tree[id].r) return ; tree[id].sum = tree[id= tree[id].r) return ; if(tree[id].addv){ int tmp = tree[id].addv; tree[id>1; build(id= l && tree[id].r >1; if(l = l && tree[id].r >1; if(l 树状数组 /* |16/11/06ztx| */ typedef long long ll; const int maxn = 100010; int t,n,q; ll anssum; struct node{ ll l,r; ll addv,sum; }tree[maxn= tree[id].r) return ; tree[id].sum = tree[id= tree[id].r) return ; if(tree[id].addv){ int tmp = tree[id].addv; tree[id>1; build(id= l && tree[id].r >1; if(l = l && tree[id].r >1; if(l 中国剩余定理 /* |16/11/06ztx| */ int CRT(int a[],int m[],int n) { int M = 1; int ans = 0; for(int i=1; i Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/10-微机原理/":{"url":"roccoshi_note/10-微机原理/","title":"10-微机原理","keywords":"","body":" 8086, 汇编语言 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/10-微机原理/01. 汇编语言-王爽/":{"url":"roccoshi_note/10-微机原理/01. 汇编语言-王爽/","title":"01. 汇编语言-王爽","keywords":"","body":" 王爽《汇编语言》学习笔记 资源地址 : 《汇编语言(第3版) 》王爽著.pdf 其他计算机书籍资源 : https://cutt.ly/computerBooks Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/10-微机原理/01. 汇编语言-王爽/1.1 寄存器.html":{"url":"roccoshi_note/10-微机原理/01. 汇编语言-王爽/1.1 寄存器.html","title":"1.1 寄存器","keywords":"","body":"1.1 寄存器1 | 通用寄存器2 | 物理地址3 | 段寄存器CS和IP修改CS和IP代码段4 | Debug程序的使用常用的Debug功能5 | 寄存器 ( 内存访问 )P47例题mov,add,sub指令数据段栈1.1 寄存器 1 | 通用寄存器 8086CPU一共有14个寄存器，所有的寄存器都是16位的，可以存放两个字节。 AX、BX、CX、DX这四个寄存器通常用来存放一般性的数据，被称为通用寄存器。由于8086CPU的上一代CPU中寄存器都是8位，为了保证兼容，8086CPU的四个通用寄存器都可以分为两个可独立使用的8位寄存器来使用。 2 | 物理地址 8086CPU有20位地址总线, 16位数据总线 物理地址采用如下方式得出 : 物理地址 = 段地址X16 + 偏移地址的方式合成得到。 3 | 段寄存器 8086CPU一共有4个段寄存器：CS、DS、SS、ES CS和IP CS：代码段寄存器 IP：指令指针寄存器 表述： 8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行 修改CS和IP 可以使用指令jmp修改CS和IP的值 使用jmp指令 代码段 用来存放代码的一段内存 4 | Debug程序的使用 Debug是DOS, Windows都提供的实模式程序的调试工具. 使用它可以查看CPU各种寄存器中的内容, 内存的情况和在机器码级跟踪程序的运行. 常用的Debug功能 命令 功能 R 查看, 改变CPU寄存器的内容 D 查看内存中的内容 E 改写内存中的内容 U 将内存中的机器指令翻译成汇编指令 T 执行一条机器指令 A 以汇编指令的格式在内存中写入一条机器指令 5 | 寄存器 ( 内存访问 )P47 例题 现有代码如下 : mov ax,1000H mov ds,ax mov ax,11316 mov [0],ax mov bx,[0] mov bx,[2] mov [2],[bx] 目前内存结构如下 : [34] -- 10000H [2c] -- 10001H [12] -- 10002H [1b] -- 10003H 结束后的内存和寄存器结构如下 : ax = 2C34H ds = 1000H bx = 2c34H - 1122H = 1b12H [34] -- 10000H [2c] -- 10001H [12] -- 10002H [1b] -- 10003H mov,add,sub指令 mov指令有如下几种形式 mov 寄存器,数据 // mov ax,8 mov 寄存器,寄存器 // mov ax,bx mov 寄存器,内存单元 // mov ax,[0] mov 内存单元,寄存器 // mov [0],ax mov 段寄存器,寄存器 // mov ds,ax add和sub指令和mov指令一样, 都有两个操作对象 数据段 将一段内存当作数据段, 是我们在编程时的一种安排, 可以在具体操作的时候, 用ds存放数据段的段地址, 再根据需要, 用相关指令访问数据段中的具体单元. 比如, 将123B0H~123B9H的内存单元定义为数据段. 现在要累加这个数据段中的前3个单元中的数据, 代码如下 : mov ax,123BH mov ds,ax mov al,0 add al,[0] add al,[1] add al,[2] 栈 下面一张图展示了8086CPU的PUSH和POP的过程示意图 8086的栈操作 在任意时刻, SS:SP指向栈顶元素, push指令和pop指令执行时, CPU从SS和SP中得到栈 顶的地址 push指令的执行过程 关于栈溢出 push造成的溢出 pop造成的溢出 由于8086CPU缺乏记录栈上限和下限的寄存器, 故8086CPU不保证我们对栈的操作不会越界, 8086仅仅知道栈顶在何处 ( 由SS:SP指示 ), 而不知道我们安排的栈空间有多大. 这就好像CPU只知道当前要执行的指令在何处 ( CS:IP指示 ), 而不知道要执行的指令有多少. Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/10-微机原理/01. 汇编语言-王爽/1.2 第一个程序.html":{"url":"roccoshi_note/10-微机原理/01. 汇编语言-王爽/1.2 第一个程序.html","title":"1.2 第一个程序","keywords":"","body":"1.2 第一个程序1 | 一个汇编语言程序从写出到执行的过程2 | 源程序2.1 | 伪指令2.2 | 源程序中的“程序”2.3 | 标号2.4 | 程序的结构1.2 第一个程序 1 | 一个汇编语言程序从写出到执行的过程 一个汇编语言程序从写出到执行的过程 编写汇编源程序 对源程序进行编译链接 使用汇编语言编译程序对源程序文件中的源程序进行编译, 产生目标文件, 再用链接程序对目标文件进行链接, 生成可执行文件, 可执行文件包含两部分内容 程序和数据 相关的描述信息 执行可执行文件中的程序 2 | 源程序 2.1 | 伪指令 在汇编语言源程序中, 包含两种指令, 一种是汇编指令, 一种是伪指令. 汇编指令是有对应的机器码的指令, 可以被编译为机器指令, 最终为cpu所执行. 而伪指令没有对应的机器指令, 最终不被cpu执行 编译器执行伪指令, 编译器根据伪指令来进行相关的编译工作 如下程序 ;程序1 assume cs:codesg codesg segment ;定义一个段, 段名为\"codesg\", 这个段由此开始 mov ax,0123H mov bx,0456H add ax,bx add ax,ax mov ax,4c00H int 21H codesg ends ;名称为\"codesg\"的段到此结束 end 程序1中的伪指令 : XXX segment和XXX ends : segment和ends是一对成对使用的伪指令, 这是在写可被编译器编译的汇编程序时必须使用的一对伪指令. segment和ends的功能是定义一个段, segment说明一个段开始, ends说明一个段结束. 一个段必须有一个名称来标识, 使用格式为 : 段名 segment . . 段名 ends 一个汇编程序是由多个段组成的, 这些段被用来存放代码, 数据或当作栈空间来使用. 一个有意义的汇编程序至少要有一个段, 这个段被用来存放代码 end end是一个汇编程序的结束标记, 编译器在编译汇编程序的过程中, 如果碰到了伪指令end, 就结束对源程序的编译. 如果在程序结束时候不加end, 编译器就无法知道程序在何处结束. assume 这条伪指令的含义为“假设” 它假设某一段寄存器和程序中的某一个用segment...ends定义的段相关联, 通过assume说明这种关联, 在需要的情况下, 编译程序可以将段寄存器和某一个具体的段相联系 2.2 | 源程序中的“程序” 源程序包括伪指令和汇编程序, 伪指令由编译器处理, 这里所说的程序就是指源程序中最终由计算机执行, 处理的指令或数据 程序最先以汇编指令的形式存在源程序中, 经编译, 链接之后转变为机器码, 存储在可执行文件中, 如下图所示 程序经编译连接后变成机器码 2.3 | 标号 汇编源程序中, 除了汇编指令和伪指令外, 还有一些标号, 比如“codesg”, 一个标号指代了一个地址, 比如codesg在segment的前面, 作为一个段的名称, 这个段的名称最终将被编译, 连接程序处理为一个段的段地址 2.4 | 程序的结构 2^3编程流程 程序返回 一个程序结束后把CPU的控制权交还给使他得以运行的程序, 这个过程称之为: 程序返回 mov ax,4c00H int 21H 这两条指令所实现的功能就是程序返回 几个和结束相关的内容 汇编程序从写出到执行的过程 汇编程序从写出到执行 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/10-微机原理/01. 汇编语言-王爽/1.3 [BX]和loop指令.html":{"url":"roccoshi_note/10-微机原理/01. 汇编语言-王爽/1.3 [BX]和loop指令.html","title":"1.3 [BX]和loop指令","keywords":"","body":"1.3 [BX]和loop指令loop指令1.3 [BX]和loop指令 loop指令 CPU执行loop指令的时候, 要进行两步操作 (cx)=(cx)-1 判断cx的值, 不为0则跳转至标号处执行程序 下面示例程序计算了2^12的值 : assume cs:code code segment mov ax,2 mov cx,11 s: add ax,ax loop s mov ax,4c00h int 21h code ends end 循环的执行过程 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/10-微机原理/02. 作业记录/":{"url":"roccoshi_note/10-微机原理/02. 作业记录/","title":"02. 作业记录","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/10-微机原理/02. 作业记录/第三章课后作业-1.html":{"url":"roccoshi_note/10-微机原理/02. 作业记录/第三章课后作业-1.html","title":"第三章课后作业-1","keywords":"","body":"第三章课后作业-116位8086汇编语言编程P106 3.1P107 3.14 -- 举例P106 3.8P107 3.13第三章课后作业-1 16位8086汇编语言编程 P106 3.1 p106 3.1 填空 A C D B F G P107 3.14 -- 举例 P107 3.14 assume cs:codesg codesg segment start: mov dx, 4000H mov ds, dx ; ds:data segment -> init the data segment 40000H mov cx, 16*1024 ; we want to find 'A' in 16K units, so we must init cx as 16K, cause in every loop needs cx-1, when the cx minus to 0, the loop ends. mov si, 0 ; source index mov dx, 0 find: mov al,[si] cmp al,'a' jne next ; not equal -> jump inc dx next: inc si loop find codesg ends end P106 3.8 P106 3.8 P107 3.13 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/10-微机原理/03. masm的使用方法.html":{"url":"roccoshi_note/10-微机原理/03. masm的使用方法.html","title":"03. masm的使用方法","keywords":"","body":"03. masm的使用方法03. masm的使用方法 命令：masm name 得到目标程序文件即obj文件 命令：link name 生成可执行文件即exe文件 命名：name.exe 运行该程序，有结果就输入，若需要查看存储器和寄存器情况，就需要进行debug模式了 对指定程序进行debug 命令：debug name.exe 不特定 命令：debug 根据不同的debug命令进行想要的操作 常用命令 debug模式下： -g ：执行完name.exe文件显示运行结果 -a ：编写汇编命令 -t ：单步执行 -p ：直接执行完不是单步执行 -u ：反编译 -r ：查看修改寄存器的值 -d ：查看内存单元 -e ：修改内存单元 -? ：查看指令帮助 最近使用的常用命令的详细说明： -d： -d 查看128个内存单元内容。 -d 段地址:偏移地址 查看指定地址128个内存单元的内容。 -d 段地址:偏移地址1 偏移地址2 查看指定地址1 到 指定地址2 内存单元的内容。 -d 段地址:偏移地址 位移量 查看指定地址开始的位移量个长度的内存单元内容 -t： 单步执行每条指令，每执行一条指令就显示寄存器内容和逻辑地址还有执行的指令。 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/11-数据库/":{"url":"roccoshi_note/11-数据库/","title":"11-数据库","keywords":"","body":" 数据库学习笔记 DBMS ( 不是全部 ) 课件: https://cutt.ly/GgqenTl Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/11-数据库/01. 关系模型/":{"url":"roccoshi_note/11-数据库/01. 关系模型/","title":"01. 关系模型","keywords":"","body":"01. 关系模型1 | 数据模型的种类 :2 | 关系模型中的一些概念 :3 | 完整性约束1 - Domain Integrity ( 域完整性 )2 - Entitiy Integrity ( 实体完整性 )3 - Referential Integrity ( 参照完整性 )4 - User-defined Integrity ( 用户定义完整性 )01. 关系模型 关系模型 + 关系代数 1 | 数据模型的种类 : Hierarchical Data Model 层次性数据模型 Network Data Model 网状数据模型 Relational Data Model 关系型数据模型 2 | 关系模型中的一些概念 : 名称 含义 attribute ( 属性 ) 每一列 tuple ( 元组 ) 每一行 relation ( 关系 ) = table ( 一张表 ) primary key ( 主键 ) - 任意两行的主键值不同- 包含主键值的列从不修改或更新- 主键值不能重用- 使用PRIMARY KEY进行标识- 「主键是候选键中的一个」 candidate key ( 候选键 ) 不含有多余属性的超键, 「最小超键」, 如果再去掉候选键中的任何一个属性就不是超键了 superkey ( 超键 ) 唯一确定一个元组的一组属性值 ( 如身份证 + 学号, 姓名 + 学号, 不唯一) foreign key ( 外键 ) 表中的一列, 其值必须在另一个表的主键中 3 | 完整性约束 1 - Domain Integrity ( 域完整性 ) 保证指定列的数据具有正确的数据类型, 数据格式和有效的数据范围 2 - Entitiy Integrity ( 实体完整性 ) 一个具有主键的关系, 主键不允许为空 3 - Referential Integrity ( 参照完整性 ) 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。参照完整性又称引用完整性。 4 - User-defined Integrity ( 用户定义完整性 ) 由用户定义的完整性 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/11-数据库/01. 关系模型/1.1 关系代数.html":{"url":"roccoshi_note/11-数据库/01. 关系模型/1.1 关系代数.html","title":"1.1 关系代数","keywords":"","body":"1.1 关系代数1 | 关系代数的五个基本操作关系完备2 | 五个基本操作的例子展示投影选择并, 差笛卡尔积3 | Join 连接4 | Division 除法用基本操作表示除法1.1 关系代数 1 | 关系代数的五个基本操作 关系代数的五个基本操作 五个基本操作 Selection : 选择 Projection : 投影 Cross-product : 笛卡尔积 Set-difference : 差 Union : 并 关系完备 一个关系数据语言可以表示上述五个基本操作, 就称它是关系完备的 其他所有的操作 ( join, div... ) 都可以用这五个基本操作经组合得到 2 | 五个基本操作的例子展示 水手-船 表 投影 投影操作 投影理论上需要消除重复元组 但是实际的数据库产品并不会消除重复元组 选择 选择操作 并, 差 并,交,差 用集合的并, 差表示集合的交: A∩B=A∪B−(A−B)∪(B−A) A\\cap B=A\\cup B-\\left( A-B \\right) \\cup \\left( B-A \\right) A∩B=A∪B−(A−B)∪(B−A) 并,交,差需要满足并兼容的条件: 属性个数相同 对应属性的类型相同 笛卡尔积 笛卡尔积 S1 X R1 问题 : S1和R1中都有sid笛卡尔乘积后会导致重复 解决 : rename重命名 3 | Join 连接 连接的分类 : 条件连接 ( Condition-Join ) 等值连接 ( Equal-Join ) : 在条件连接中条件为相等 自然连接 (Natural-Join) : 「去掉重复列的等值连接」 4 | Division 除法 除法 A/B={⟨x⟩∣∃⟨x,y⟩∈A∀⟨y⟩∈B} \\text{除法 }A / B=\\{\\langle x\\rangle \\mid \\exists\\langle x, y\\rangle \\in A \\quad \\forall\\langle y\\rangle \\in B\\} 除法 A/B={⟨x⟩∣∃⟨x,y⟩∈A∀⟨y⟩∈B} 除法举例 用基本操作表示除法 A/B=πx(A)−πx((πx(A)×B)−A) A/B=\\pi _x\\left( A \\right) -\\pi _x\\left( \\left( \\pi _x\\left( A \\right) \\times B \\right) -A \\right) A/B=π​x​​(A)−π​x​​((π​x​​(A)×B)−A) create table Congshu ( Ygbh int, Gsbh int, Kssj datetime, Cxsj timeduration, Gz int check(Gz>10000), primary key(Ygbh, Gsbh), foreign key(Ygbh) references Yuangong(Ygbh), foreign key(Gsbh) references Gongsi(Gsbh) ) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/11-数据库/01. 关系模型/1.2 关系演算.html":{"url":"roccoshi_note/11-数据库/01. 关系模型/1.2 关系演算.html","title":"1.2 关系演算","keywords":"","body":"1.2 关系演算1 | 关系演算的类型2 | 域关系演算 DRC绑定和自由变量3 | 元组关系演算 TRC元组关系演算的例子上课老师讲的几个元组关系演算的例子1.2 关系演算 关系代数和关系演算的区别 : 关系代数是过程化的表达, 关系演算是非过程化的表达. 1 | 关系演算的类型 Tuple relational calculus 元组关系演算 ( TRC ) Domain relational calculus 域关系演算 ( DRC ) 2 | 域关系演算 DRC Query has the form : {x1,x2,...,xn>∣P(x1,x2,...,xn,...,xn+m)} \\left\\{ | P\\left( x_1,x_2,...,x_n,...,x_{n+m} \\right) \\right\\} {x​1​​,x​2​​,...,x​n​​>∣P(x​1​​,x​2​​,...,x​n​​,...,x​n+m​​)} x1, x2, ... , xn+m : domain variables (域变量) 绑定和自由变量 Free and Bound Variables 3 | 元组关系演算 TRC Query has the form : {t[attributelist>]∣P(t)} \\left\\{ t\\left[ \\right] \\,\\,| \\,\\,P\\left( t \\right) \\right\\} {t[attributelist>]∣P(t)} 其中 : t是一个元组, t[x,x,x,...]中的每一个x是一个属性 元组关系演算的例子 元组关系演算 上课老师讲的几个元组关系演算的例子 元组关系演算_1 元组关系演算_2 mark : 数据模型 ( 九 ) 暂时跳过 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/11-数据库/02. SQL语言/":{"url":"roccoshi_note/11-数据库/02. SQL语言/","title":"02. SQL语言","keywords":"","body":"基本的查询语句BASIC SQL QUERY执行的过程mysql的登录方法作业5基本的查询语句 BASIC SQL QUERY SELECT [DISTINCT] target-list FROM relation-list WHERE qualification 执行的过程 计算各个表的笛卡尔乘积 进行筛选 投影 如果[DISTINCT], 则去重 mysql的登录方法 mysql -u root -p -- 登录, 输入用户密码 show databases; -- 显示所有数据库 use xxx; -- 切换数据库 show tables; -- 显示所有表 作业5 正确代码1 select j.jno from j where not exists ( select * from spj, s, p where spj.jno = j.jno and spj.sno = s.sno and spj.pno = p.pno and s.city = '天津' and p.color = '红' ); 正确代码2 select j.jno from j where j.jno not in ( select j.jno from s, j, p, spj sp where j.jno = sp.jno and sp.sno = s.sno and p.pno = sp.pno and s.city = '天津' and p.color='红' ); 求至少使用了供应商S1所供应的全部零件的工程号 对于一个工程X, 不存在这样一个零件Y, 供应商S1供应了而X没有用 select jno from j -- 一个工程x where not exists -- 不存在 ( select * from spj sp1 -- 这样一个零件Y where sp1.sno = 'S1' and not exists -- S1供应了而x没有用 ( select * from spj sp2 where sp2.pno = sp1.pno and sp2.jno = j.jno ) ); 查询至少选修了学号为“200215121”的学生所选全部课程的学生学号 对于一个学生X, 不存在这样一门课程Y, 学号200215121的学生选了而X没有选 select sx.sno from student sx where not exists ( select * from sc scy where scy.sno = 200215121 and not exists ( select * from sc scz where scy.cno = scz.cno and scz.sno = sx.sno ) ); Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/11-数据库/02. SQL语言/01. 基础查询语句.html":{"url":"roccoshi_note/11-数据库/02. SQL语言/01. 基础查询语句.html","title":"01. 基础查询语句","keywords":"","body":"01. 基础查询语句表的例子基本查询1 | 找到预定了103号船的水手姓名2 | 找到至少预定了一条船的水手编号3 | 使用别名和模糊查询4 | 查找定过红船或者绿船的水手的编号5 | 查找预定了红船和绿船的水手的编号嵌套查询1 | 查询定了103号船的水手的姓名 -- 非关联嵌套子查询2 | 查询定了103号船的水手的姓名 -- 关联嵌套子查询3 | 查找只有一个水手预定过的船4 | 找到rating值比lubber高的水手SQL中的除法1 | 查找预定了所有船的水手01. 基础查询语句 表的例子 这里我们用到如下几个表作为之后的例子 Reserves Sailors Boats S2 基本查询 1 | 找到预定了103号船的水手姓名 mysql> select S.sname -> from Sailors S, Reserves R -> where S.sid = R.sid AND R.bid = 103; +-------+ | sname | +-------+ | rusty | +-------+ 2 | 找到至少预定了一条船的水手编号 mysql> select s.sid -> from sailors s, reserves r -> where s.sid = r.sid; +-----+ | sid | +-----+ | 22 | | 58 | +-----+ 2 rows in set (0.00 sec) 3 | 使用别名和模糊查询 mysql> select s.age, 2*s.age as age1, sname as name -> from sailors s -> where s.sname like 'l_%r'; +------+-------+--------+ | age | age1 | name | +------+-------+--------+ | 55.5 | 111.0 | lubber | +------+-------+--------+ 1 row in set (0.00 sec) 4 | 查找定过红船或者绿船的水手的编号 第一种方法 mysql> select s.sid -> from sailors s, boats b, reserves r -> where s.sid=r.sid and r.bid=b.bid -> and (b.color='red' or b.color='green'); +-----+ | sid | +-----+ | 22 | | 58 | +-----+ 2 rows in set (0.02 sec) 第二种 ( 使用union ) mysql> select s.sid -> from sailors s, boats b, reserves r -> where s.sid = r.sid and r.bid = b.bid -> and b.color = 'green' -> UNION -> select s.sid -> from sailors s, boats b, reserves r -> where s.sid = r.sid and r.bid = b.bid -> and b.color = 'red'; +-----+ | sid | +-----+ | 58 | | 22 | +-----+ 2 rows in set (0.00 sec) 5 | 查找预定了红船和绿船的水手的编号 这里不能简单的把上一个例子的or改成and 方法 ( 查两次 ) mysql> select s.sid -> from sailors s, boats b1, reserves r1, boats b2, reserves r2 -> where s.sid = r1.sid and r1.bid = b1.bid -> and s.sid = r2.sid and r2.bid = b2.bid -> and (b1.color='red' and b2.color='green'); 嵌套查询 1 | 查询定了103号船的水手的姓名 -- 非关联嵌套子查询 非关联嵌套子查询 : 子查询和外部不相关 嵌套查询的方式 in mysql> select s.sname -> from sailors s -> where s.sid in -> (select r.sid -> from reserves r -> where r.bid = 103 ); +-------+ | sname | +-------+ | rusty | +-------+ 1 row in set (0.00 sec) 2 | 查询定了103号船的水手的姓名 -- 关联嵌套子查询 关联嵌套子查询 : 子查询和外部相关 方式 : exists mysql> select s.sname -> from sailors s -> where exists ( -> select * -> from reserves r -> where r.bid = 103 and s.sid = r.sid -> ); +-------+ | sname | +-------+ | rusty | +-------+ 1 row in set (0.00 sec) 3 | 查找只有一个水手预定过的船 mysql> select bid from reserves r1 -> where bid not in ( -- 该水手定的船不在其他水手定的船的集合内, 说明这条船只有这个水手预定了 -> select bid -> from reserves r2 -- 对reserves表做自连接 -> where r2.sid != r1.sid -- 其他水手所定的船的编号 -> ); +-----+ | bid | +-----+ | 101 | | 103 | +-----+ 2 rows in set (0.01 sec) 4 | 找到rating值比lubber高的水手 mysql> select * from sailors s -> where s.rating > any ( -> select s2.rating -> from sailors s2 -> where s2.sname = 'lubber' -> ); +-----+-------+--------+------+ | sid | sname | rating | age | +-----+-------+--------+------+ | 58 | rusty | 10 | 35.0 | +-----+-------+--------+------+ 1 row in set (0.00 sec) SQL中的除法 1 | 查找预定了所有船的水手 方法一 : (使用except ( 集合差 ) , mysql不支持) SELECT S.sname FROM Sailors S WHERE NOT EXISTS -- 该水手没有预定的船「不存在」, 说明该水手预定了全部船 ( ( SELECT B.bid FROM Boats B ) EXCEPT ( SELECT R.bid FROM Reserves R WHERE R.sid = S.sid ) ); 方法二 : mysql> select s.sname -> from sailors s -- Sailors S such that .. -> where not exists ( -- there is no boat B without ... -> select b.bid -> from boats b -> where not exists ( -- a Reserves tuple showing S reserved B -> select r.bid -> from reserves r -> where r.bid = b.bid -> and r.bid = s.sid)); 方法二的解释 : Sailors S such that .. there is no boat B without ... a Reserves tuple showing S reserved B. Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/11-数据库/02. SQL语言/02. 聚集函数和GROUP.html":{"url":"roccoshi_note/11-数据库/02. SQL语言/02. 聚集函数和GROUP.html","title":"02. 聚集函数和GROUP","keywords":"","body":"02. 聚集函数和GROUP1 | 聚集函数例子2 | 「分组」 GROUP BY 和 HAVING例子02. 聚集函数和GROUP 1 | 聚集函数 significant extension of relational algebra : COUNT(*) COUNT([DISTINCT] A) -- 求个数 SUM([DISTINCT] A) -- 求和 AVG([DISTINCT] A) -- 求平均值 MAX(A) MIN(A) 例子 mysql> select avg(s.age) from sailors s; -- avg +------------+ | avg(s.age) | +------------+ | 45.16667 | +------------+ 1 row in set (0.00 sec) mysql> select count(*) from sailors s; -- count(*) +----------+ | count(*) | +----------+ | 3 | +----------+ 1 row in set (0.01 sec) mysql> select max(s.age) as mage from sailors s; -- max() +------+ | mage | +------+ | 55.5 | +------+ 1 row in set (0.00 sec) 2 | 「分组」 GROUP BY 和 HAVING 完整的sql查询框架 : SELECT [DISTINCT] target-list FROM relation-list WHERE qualification GROUP BY grouping-list HAVING group-qualification 例子 1 | 在「各个级别的水手」中找到「年龄大于18岁的水手中」「最年轻的水手」, 并且这样的水手(年龄>=18)得有2个以上 SELECT S.rating, MIN(S.age) AS minage from Sailors S WHERE S.age >= 18 GROUP BY S.rating HAVING COUNT(*) > 1; 上述语句的执行过程 上述语句的执行过程 2 | 对每一条红船查找预定了它的人数 SELECT B.bid, COUNT(*) AS scount FROM Boats B, Reserves R WHERE R.bid = B.bid AND B.color = 'red' GROUP BY B.bid; 如果把B.color = 'red'去掉并在GROUP BY后加入HAVING B.color='red'会如何 ? 在逻辑上说得通, 但是报错--ERROR 1054 (42S22): Unknown column 'b.color' in 'having clause', 原因是数据库无法得知B.color是不是唯一的(虽然在这里是) --> 原则 : select和having里面的筛选属性必须是group by里属性分组的子集 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/11-数据库/02. SQL语言/03. 「复习」学校数据库ppt第三章sql语句.html":{"url":"roccoshi_note/11-数据库/02. SQL语言/03. 「复习」学校数据库ppt第三章sql语句.html","title":"03. 「复习」学校数据库ppt第三章sql语句","keywords":"","body":"03. SQL1 | 数据定义创建数据库创建基本表修改基本表2 | 查询where子句ORDER BY集函数嵌套查询集合查询3 | 数据更新3-1 | 插入数据3-2 | 修改数据3-3 | 删除数据4 | 视图4-1 | 建立视图03. SQL SQL与三级模式体系结构图: 1 | 数据定义 SQL提供了专门的语言定义数据库对象, 称为DDL(数据定义语言, Data Definition Language) 创建数据库 CREATE DATABASE 创建基本表 格式 CREATE TABLE ( , , ... ); 实例 create table S ( SNO int not null primary key, -- 列级完整性约束 SNAME char(10) not null, SA int not null, FNAME char(15) not null, CNO int not null, SD char(10), constraint fk_fname1 foreign key(FNAME) references F(FNAME), -- 表级完整性约束, 命名约束 foreign key(CNO) references C(CNO) -- 直接指定约束 (少了constraint xxx) ); 常用的完整性约束: 修改基本表 格式 ALTER TABLE ( ADD DROP ALTER ); 实例: -- 增加属性 alter table student add senroll date; -- 修改属性数据类型 alter table student alter sage smallint; -- 删除约束 alter table student drop unique(name); 2 | 查询 语法: where子句 -- 例子 where age between 20 and 23; -- 找年龄20-23岁的 where dept not in ('is', 'ma', 'cs'); --查询不是is, ma, cs系得 where name like '刘%'; -- 找姓刘的 where name like '__阳'; -- 找名字叫xx阳的 where cname like 'DB\\_Design' ESCAPE '\\'; -- escape定义转义字符, 出现在其后的第一个字符不是通配符而是字符本身 注意点: 涉及空值的查询时is NULL不能用 = NULL替代 ORDER BY 对属性列排序 asc为升序 desc为降序 默认为升序 -- 查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列。 SELECT * FROM Student ORDER BY Sdept , Sage DESC ; 集函数 COUNT SUM AVG MAX MIN 例子: select count(distinct sno) from sc; -- 查选了课程的学生人数 group by 和 having group by having 按指定的一列或者多列分组, 值相等的为一组, having子句作用于各个组之上 如果未对查询结果分组, 集函数作用于整个查询结果 对查询结果分组后, 集函数分别作用于各个组 使用group by子句后, select子句的列名表中只能出现分组属性和集函数, 不能出现在group by中没有出现的属性 例子: -- 查询各个课程号和相应的选课人数 select cno, count(sno) from sc group by cno; -- 查询有3门以上课程是90分以上的学生学号及其(90分以上的)课程数。 select sno, count(*) from sc where grade >= 90 group by sno having count(*) >= 3; 嵌套查询 分类: 相关子查询 : 子查询执行依赖于父查询条件 不相关子查询 : 子查询执行不依赖于父查询条件 例子: SELECT Sname -- 外层查询/父查询 FROM Student WHERE Sno IN ( SELECT Sno -- 内层查询/子查询 FROM SC WHERE Cno = 'c2' ) ; 带有any或者all谓词的子查询 例子: (为不相关子查询) 使用any/all谓词与集函数具有等价关系, 而用集函数查询通常比any/all查询效率高因为前者可以减少比较次数 带有EXISTS谓词的子查询 exists仅返回true/false, 故子查询通常只用select * 使用EXISTS子查询的效率要优于使用连接查询和IN查询 EXISTS通常引入的是相关子查询, 而IN更多的是不相关子查询 集合查询 集合操作命令 命令 UNION 并 INTERSECT 交 MINUS 差 3 | 数据更新 3-1 | 插入数据 插入单个结果 格式: INSERT INTO VALUES ; 如果不指定属性列, 则values必须以完整的元组插入, 且属性与表中属性顺序一致 举例: insert into sc(sno, cno) values ('95001', '1'); 插入子查询结果 INSERT INTO 子查询; 举例: INSERT INTO Deptage ( Sdept, Avgage ) SELECT Sdept, AVG(Sage) -- 属性个数要匹配 FROM Student GROUP BY Sdept ; 注意完整性约束 3-2 | 修改数据 格式: UPDATE SET = WHERE 举例: update student set sage = 22 where sno = '95001' -- 将所有学生年龄增加一岁 update student set sage = sage + 1 3-3 | 删除数据 格式: DELETE FROM WHERE ; 删除表中满足where指定条件的元组 例子: delete from student where sno = '95001'; -- 删除所有学生的选课记录 delete from sc; -- 删除CS系所有学生的选课记录 delete from sc where sno in ( select sno from student where student.sdept = 'CS' ); 删除时的参照完整性: 不允许被删除 级联删除 ( 通过CASCADE参数指定 ) 4 | 视图 数据库系统的三级模式: 外模式, 模式, 内模式 数据库系统的两级映像: 外模式-模式映像 模式-内模式映像 外模式-模式映像用途: 保证数据的逻辑独立性 模式-内模式映像用途: 保证数据的物理独立性 视图对应的就是三级模式/两级映像体系结构中的外模式和外模式/模式映像 4-1 | 建立视图 格式: CREATE VIEW AS [WITH CHECK OPTION]; DBMS执行create view语句时只是把视图的定义存入数据字典, 并不执行其中的select语句, 在对视图查询时, 按视图的定义从基本表中将数据查出 例子: create view IS_STUDENT as select sno, sname, sage from student where sdept = 'IS'; 若一个视图是从单个基本表导出的, 并且只去掉了基本表的某些行和某些列但保留了码, 则这类视图称为行列子集视图, 上例所建立的视图就是行列子集视图 DBMS实现视图查询的方法 实体化视图: 通过视图建立临时表, 查询后删除临时表 视图消解法: 根据视图定义将对视图的查询转换为对基本表的查询 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/11-数据库/03. 数据库安全-赋权.html":{"url":"roccoshi_note/11-数据库/03. 数据库安全-赋权.html","title":"03. 数据库安全-赋权","keywords":"","body":"03. 数据库安全-赋权1 | 授权GRANT语句所有权限一览表举例2 | 收回权限REVOKE语句举例3 | 视图机制03. 数据库安全-赋权 数据库的安全性控制通过授权机制来实现, 即通过赋予用户对数据库的使用权限来保证数据的安全 1 | 授权GRANT语句 将数据库中的某些对象的某些操作权限赋予某些用户 格式: Grant ON TO [WITH GRANT OPTION] DBA用于数据库操作的所有权限并可将权限赋予其他用户 建立数据库对象的用户称为OWNER, 他拥有对该对象的所有操作权限 接收权限的用户可以是一个或者多个具体用户, 也可以是全体用户PUBLIC WITH GRANT OPTION子句: 获得某种权限的用户还可以把这种权限再授予别的用户, 没有指定with grant option时, 获得某种权限的用户只能使用该权限, 不能传播该权限 所有权限一览表 举例 grant select on table student to user1; 把对sc表的全部权限授予全部用户 grant all priviliges on table sc to public; 把查询student表和修改学生学号的权限授予给用户3和用户4 grant update(sno), select on table student to user3, user4; 把对表sc的insert权限授予给user5用户, 并允许他再将此权限授予其他用户 grant insert on table sc to user5 with grant option; 把在数据库S_C中的建表权限授予用户8 grant createtab on database S_C to user8; 2 | 收回权限REVOKE语句 REVOKE ON FROM 举例 revoke update(sno) on table student from user4; revoke select on table sc from public; 收回权限时, 将收回自己所级联授予出的权限 如果存在多重授予, (从不同用户处得到的相同权限, 则仍然具有该权限), 只收回自己级联授予的权限 3 | 视图机制 公司(公司编号, 公司类型) // 主码公司编号 管理人员(公司编号, 员工编号, 姓名, 性别, 职位, 等级, 座机, 手机) // 主码(公司编号, 员工编号) 快递员(公司编号, 员工编号, 姓名, 性别, 电话, 身份证) // 主码(公司编号, 员工编号) 包裹(包裹编号, 员工编号, 派送时间, 送达时间, 接收人电话, 接收人地址) // 主码(包裹编号, 员工编号) ------------------- 函数依赖集: 公司(公司编号->公司类型) 管理人员(都完全依赖主码, 没有候选码) 快递员(略) 包裹(略) ------------------- 公司: BCNF 管理人员: BCNF 快递员: 由于身份证可以决定姓名, 性别, 电话, 所以为2NF 包裹: 接收人电话可以决定接收人地址, 2NF Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/11-数据库/04. 存储过程和触发器.html":{"url":"roccoshi_note/11-数据库/04. 存储过程和触发器.html","title":"04. 存储过程和触发器","keywords":"","body":"04. 存储过程和触发器1 | 存储过程2 | 触发器04. 存储过程和触发器 1 | 存储过程 创建存储过程: CREATE PROCEDURE 执行存储过程: EXECUTE PROCEDURE 修改存储过程: ALTER PROCEDURE 删除存储过程: DROP PROCEDURE 2 | 触发器 功能: 强化约束, 跟踪变化, 级联运行, 存储过程的调用 分类: 前触发器(INSTEAD OF), 后触发器 (AFTER) 创建: CREATE TRIGGER ON FOR AS -- 例子 create trigger reminder on titles for insert, update as sql_statements 在触发器的执行过程中，系统会自动建立和管理两个逻辑表：插入表(inserted)和删除表(deleted)。这两个表与触发器所对应的基本表有着完全相同的结构，但为只读表，驻留于内存之中，直到触发器执行完毕，系统会自动删除。这两个表是事务回滚的重要依据。 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/11-数据库/05. 数据库设计.html":{"url":"roccoshi_note/11-数据库/05. 数据库设计.html","title":"05. 数据库设计","keywords":"","body":"05. 数据库设计1 | 数据库设计的流程2 | ER图3 | ER图向关系模型的转换05. 数据库设计 1 | 数据库设计的流程 1-需求分析 2-概念结构设计 3-逻辑结构设计 4-物理结构设计 ER图 ER图->关系模型 2 | ER图 三种表示 表示方式 实体 矩形 属性 圆形 联系 菱形 三种不同的联系 一对一联系 一对多联系 多对多联系 3 | ER图向关系模型的转换 联系 转换 1 : 1 两实体任意一端添加另一端的主键 1 : N 在N端添加另一端的主键 N : M 将联系转化为实体, 并在实体中加入联系两端实体的主键 1 : 1 : N \\ N : M : P 同 1 : N \\ N : M (在N端添加另外两端主键 \\ 联系转化为实体添加三端实体主键) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/11-数据库/06. 关系数据理论.html":{"url":"roccoshi_note/11-数据库/06. 关系数据理论.html","title":"06. 关系数据理论","keywords":"","body":"06. 关系数据理论1 | 关系模式的存储异常2 | 函数依赖3 | 范式1NF2NF3NFBCNF4 | Armstrong公理系统六条推理规则函数依赖集的闭包06. 关系数据理论 关系模式的简记: R 其中U表示属性集, F表示数据依赖 1 | 关系模式的存储异常 不满足2NF, 3NF, BCNF范式的关系模式存在下列异常 数据冗余 更新异常 插入异常 删除异常 2 | 函数依赖 Functional Dependencies简写为FD 平凡函数依赖: ($\\text{X}->\\text{Y}, \\text{Y}\\subseteq \\text{X}$) 平凡函数依赖没什么用, 不研究 例如(sno, cno)->sno 非平凡函数依赖: ($\\text{X}->\\text{Y}, \\text{Y}\\nsubseteq \\text{X}$) 如果不特别声明, 我们总是讨论非平凡函数依赖 例如(sno, cno)->grade 完全函数依赖, 部分函数依赖 传递函数依赖: (A->B B->C), 则Z传递依赖于X, 注意Y$\\nrightarrow $X如果Y$\\rightarrow$X 则为直接依赖 3 | 范式 1NF 所有属性必须是原子的, 不允许表中套表 2NF 满足1NF且不存在属性对候选码的部分函数依赖 3NF 满足2NF且不存在属性对候选码的传递函数依赖 BCNF 对于R的每一个函数依赖X->Y, X必包含码 4 | Armstrong公理系统 六条推理规则 自反律 增广律 传递律 合并规则 分解规则 伪传递规则 函数依赖集的闭包 在关系模式R中为F所逻辑蕴含的函数依赖的全体叫做F的闭包, 记为$\\text{F}^+$ Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/12-机器学习/01. jupyter notebook的使用.html":{"url":"roccoshi_note/12-机器学习/01. jupyter notebook的使用.html","title":"01. jupyter notebook的使用","keywords":"","body":"01. jupyter notebook的使用运行代码编辑模式 (绿色)和命令模式 (蓝色)的切换切换到markdown模式常用快捷键魔法函数 %01. jupyter notebook的使用 内核: ipython 运行代码 运行全部代码: Cell - Run All 写完一行后按shift + enter即可运行当前行代码并且跳转到下一个代码块 ctrl + enter运行当前代码块 (不跳转到下一个代码块) alt + enter运行当前代码块并且在下方新建一个代码块 编辑模式 (绿色)和命令模式 (蓝色)的切换 编辑模式 -> 命令模式: Esc 命令模式 -> 编辑模式: Enter 切换到markdown模式 在命令模式下按m即可进入markdown模式 , 按y切换回代码单元格 常用快捷键 在命令模式下按h即可查看所有支持的快捷键 a: 在当前代码块上方创建代码块 b: 在当前代码块下方创建代码块 x: 删除当前代码块 c: 复制当前单元格 v: 黏贴复制的单元格 魔法函数 % 可以在jupyter中使用%lsmagic列出所有的魔法函数 %matplotlib inline可以让matplotlib画的图都内嵌在单元格中 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/13-OOP/":{"url":"roccoshi_note/13-OOP/","title":"13 OOP","keywords":"","body":" 大三上学期课程 -- 面向对象程序设计 主要内容为C++以及相关的面向对象内容1 1. 西安电子科技大学OOP课程 ↩ Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-28 14:30:16 "},"roccoshi_note/13-OOP/01. 初步知识.html":{"url":"roccoshi_note/13-OOP/01. 初步知识.html","title":"01. 初步知识","keywords":"","body":"01. C++初步知识1 | 命名空间namespace定义方式2 | 输入和输出3 | 用const定义常量const和define的区别4 | 函数原型声明5 | 函数模板6 | 有默认参数的函数7 | 引用关于返回值为引用8 | 内联函数9 | 作用域运算符::10 | 动态分配 / 撤销内存 (new / delete)01. C++初步知识 1 | 命名空间namespace C++标准库中的类和函数是在名字空间std中声明的 名字空间可以消除那些因重名而导致的命名冲突 能在名字空间以外声明或定义的实体，同样也能在名字空间之内声明或定义 定义方式 namespace ns1 { ...; } 无名的名字空间 c++允许使用没有名字的名字空间 namespace { ...; } 由于名字空间没有名字, 因此无法在其他文件中引用 无名名字空间内的成员作用域为本文件从声明无名名字空间的位置开始到本文件结束 2 | 输入和输出 运算符 名称 >> 流提取运算符 流插入运算符 在C++中: 输出操作可理解为将数据插入到输出流对象中 输入操作可理解为从输入流对象中提取数据 3 | 用const定义常量 #define定义的符号常量是在预编译时进行字符替换, 又称宏替换 const定义常量: const int maxl = 1000 用const定义标识符常量时, 一定要对其进行初始化, 在声明时进行初始化是对常量赋值的唯一方式 const和define的区别 const常量有数据类型而宏常量没有 有些集成调试工具可以对const常量进行调试而不能对宏常量进行调试 4 | 函数原型声明 在C++中，如果函数调用的位置在函数定义之前，则要求在函数调用之前必须对所调用的函数作函数原型声明。 函数原型声明的一般形式为: 函数类型 函数名 (参数表); 5 | 函数模板 定义方式: // 方式一 template // 方式二 template // 例子1 template T max(T a, T b) { return a > b ? a : b; } // 例子2 (多个类型参数) template T1 max(T1 a, T2 b) { return a > b ? a : (T1)b; // 进行类型转换, 因为返回值类型为T1 } 6 | 有默认参数的函数 C++可以给形参一个默认值，这样形参就不必一定要从实参取值。 如果有多个形参，可以指定任意个默认值。 实参与形参的结合是从左至右进行的，因此指定默认值的参数必须放在形参列表中的最右端。 必须在函数调用之前将默认值的信息通知编译系统。 当重载函数与默认参数函数共同使用时，要注意出现二义性问题。 7 | 引用 起别名 引用必须初始化，初始化后不能再称为其他变量的别名。 关于返回值为引用 返回值为引用, 即返回别名, 这种情况下函数可以作为左值。 例子: int a=4; int &f(int x) { a=a+x; return a; } int main() { int t=5; cout 8 | 内联函数 定义形式: inline 函数值类型 函数名 (参数表) { ...; } // e.g. inline void show () { cout 调用内联函数时，编译器首先检查调用是否正确（类型安全检查或者自动进行类型转换）。如果正确，则将内联函数的代码直接替换函数调用，并且用实参换形参，于是省去了函数调用的开销。因此，内联机制增加了空间开销而节约了时间开销。 attention: 使用内联函数可以节省运行时间，但却增加了目标程序的长度。 函数体内出现循环或递归等复杂的结构控制语句时，不适合定义为内联函数。 一个好的编译器将会根据函数的函数体，自动取消不值得的内联。 9 | 作用域运算符:: #include using namespace std; float a = 13.5; int main() { int a=5; cout 10 | 动态分配 / 撤销内存 (new / delete) 在C语言中利用malloc和free进行内存空间的分配和撤销 new运算从堆中分配一块与相适应的存储空间，若分配成功，将这块存储空间的起始地址存入。new的使用格式为： =new ; =new (); =new []; delete运算符用来释放指向的动态存储空间。使用格式如下： delete delete[] // 用于释放指针指向的连续存储空间, 即释放数组占用的空间 e.g. // e.g. int* p = new int; delete p; int* p = new int(3); delete p; int* p = new int[5]; delete[] p; Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/13-OOP/02. 类和对象的特性.html":{"url":"roccoshi_note/13-OOP/02. 类和对象的特性.html","title":"02. 类和对象的特性","keywords":"","body":"02. 类和对象的特性public, priavte和protected成员函数的两种实现方式在类外访问对象中的成员的方法02. 类和对象的特性 对象(软件): 将状态（数据）和行为（功能）捆绑在一起的软件结构/模块，这两个部分合起来表示实际（物理或概念）对象的抽象 类: 类是描述一组相似对象共有特征的抽象 每一个属于该类的对象的数据结构（也就是属性的名称和类型） 由这些对象执行的操作/函数 （如何命令对象执行这些操作，以及为了实际执行这些操作对象必须执行的后台动作） 对象和类的关系: 对象是类的一个具有特定属性值的具体实例 从一个类可以创建（实例化）多个对象 相同类的两个对象具有相同的属性和函数，但属性值不同 public, priavte和protected 名称 含义 作用 public 公有成员 - 公有成员在程序的任何地方都可以被访问，是类的对外接口。而且在类外只能访问类的公有成员(继承除外) private 私有成员 私有成员只能被本类中的成员函数和友元访问，而不能被类外调用。所谓类外指的是普通函数或其他类的成员函数 protected 保护成员 保护成员具有双重性，对其派生类而言，保护成员如同公有成员；对其他程序则表现得像私有成员。 成员函数的两种实现方式 在类中实现成员函数 在类外实现成员函数 一般在类中声明成员函数, 在类外具体实现成员函数 在类外声明成员函数的格式: 在类外访问对象中的成员的方法 在类外访问对象中的成员 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/13-OOP/03. 使用类和对象.html":{"url":"roccoshi_note/13-OOP/03. 使用类和对象.html","title":"03. 使用类和对象","keywords":"","body":"03. 使用类和对象1 | 构造函数和析构函数构造函数:析构函数:析构函数和构造函数的调用顺序对象的复制和复制构造函数2 | 类的静态成员静态数据成员静态成员函数3 | 对象指针4 | this指针5 | 成员函数指针6 | 常对象7 | 类的常成员常数据成员常成员函数8 | const和指针指向对象的常指针指向常对象的指针常引用9 | 对象数组10 | 对象成员11 | 类模板03. 使用类和对象 1 | 构造函数和析构函数 构造函数: 在定义对象时被编译系统自动调用来创建对象并初始化对象 定义: 如果在类中没有显式定义构造函数, 那么编译系统就会自动生成一个默认形式的构造函数, 这个构造函数的功能仅用于创建对象, 并不会对产生对象的数据成员赋初值, 即产生对象的数据成员的值是不确定的 只要显式定义了一个类的构造函数, 则编译器就不产生默认的构造函数 析构函数: 析构函数的功能是在对象的生存期即将结束的时刻，由编译系统自动调用来完成一些清理工作。 析构函数只是在生命周期末端完成一些清理工作，并不会回收空间。这个空间应该是系统管理释放。析构函数不能有参数，因此也不能被重载； 定义: 如果没有定义析构函数，同构造函数一样，编译系统会提供默认形式的析构函数 析构函数和构造函数的调用顺序 在一般情况下，调用构造函数与声明对象的顺序相同，而调用析构函数的次序正好与创建对象的顺序相反。 对象的复制和复制构造函数 赋值和复制 生成一个对象的副本有两种途径: 对象的赋值 = , 其中对象1, 2都是已经存在的对象 对象的复制 () = 前者是对一个已经存在的对象赋值, 而后者是从无到有地建立一个新对象 复制构造函数 一种特殊的构造函数, 它的功能是用一个已知的对象来初始化一个被定义的同类的对象 格式: // 复制构造函数只有一个参数，并且是对同类对象的引用。 (const & ) { ...; } 如果程序员没有显式定义复制构造函数, 编译系统会自动生成一个默认形式的复制构造函数, 其功能是把已知对象的每个值都复制到新创建的对象中, 而不做其他的处理 Box(); //无参构造函数 Box(int h,int w ,int len):height(h),width(w),length(len){} //带参构造函数 Box(const Box& b);//复制构造函数 2 | 类的静态成员 静态成员是类的所有对象共享的成员，而不是某个对象的成员，它在对象中不占存储空间，是属于整个类的成员。 静态数据成员 静态数据成员不随对象的建立而分配空间，也不随对象的撤销而释放。它是在程序编译时分配空间，到程序结束时才释放空间。 定义: static xxx 初始化: ::=; (初始化语句中不能加static) 访问: 在成员函数中直接访问 在类外必须使用成员访问运算符或者域运算符访问共有静态数据成员 对象名.静态数据成员 或者 类名::静态数据成员 静态成员函数 静态成员函数的作用是为了能处理静态数据成员 静态成员函数没有this指针 静态成员函数可以直接访问该类的静态成员, 但不能直接访问类中的非静态成员, 如果要使用非静态成员需要以参数传递的方式得到对象名然后通过对象名进行访问 3 | 对象指针 初始化: 通过对象指针访问对象成员: 4 | this指针 this指针是一种特殊的隐含指针, 它隐含于每一个成员函数中, 也就是说, 每一个成员函数都有一个this指针参数 this指针指向调用该函数的对象, 即this指针的值是当前被调用的成员函数所在对象的起始地址 但一个对象调用成员函数时, 编译系统先将对象的地址赋给this指针, 然后调用成员函数, 每次成员函数存取数据成员时则隐含使用this指针 通常不显式地使用this指针来调用数据成员 5 | 成员函数指针 6 | 常对象 常对象是其数据成员值在对象的整个生存期间内不能被改变的对象。 常对象的定义: // 方式一 const 　(); // 方式二 const (); 常对象不能调用普通的成员函数, 可以调用常成员函数 7 | 类的常成员 类的数据成员和成员函数可以声明为const, 分别为常数据成员和常成员函数 常数据成员 「只读」:在任何函数中都不允许对常数据成员赋值 只能通过构造函数的参数初始化表对常数据成员进行初始化 类的所有对象中的常数据成员值均不能改变, 但不同对象中的该值可以不同 class A { public: const int n = 10; // c++11之前的标准不支持, 所有数据成员都不能定义时初始化, 只能在初始化列表初始化, c++11之后可以定义时赋初值, 然后可以在构造函数中覆盖 A (int x): n(x) {} A (){} }; int main() { A a; A b(30); cout 常成员函数 () const; // 声明与定义时都要加const, 调用时不必加const //e.g. int show () const { cout 常成员函数不能更新对象的数据成员, 也不能调用该类中的非const成员函数 常对象只能调用它的常成员函数而不能调用其他成员函数 const关键字可以用于对重载函数的区分 8 | const和指针 指向对象的常指针 类名 * const 指针名 = 对象地址 表示指针不能改变指向 指向常对象的指针 const 类名 * 指针名 = 对象地址 如果存在一个常对象, 则只能用指向常对象的指针指向它 指向常对象的指针还可以指向非const的对象, 但是不能通过指针改变对象的值 即, 指向常对象的指针可以指向const和非const型的对象，而指向非const型对象的指针只能指向非const的对象。 常引用 9 | 对象数组 声明对象数组的格式[] 如果构造函数只有一个参数，在定义数组时可以直接在等号后面的大括号内提供实参。 student stud[3] = {60, 70, 78}; 如果构造函数有多个参数，在定义对象数组时在大括号中分别写出构造函数并指定实参。 Ex(int x=0, char c=‘c’); //声明构造函数 Ex z[2]={Ex(10,'a'),Ex(1,'d')}; //对象数组的初始化 10 | 对象成员 用类对象作为另一个类的成员, 这个成员成为对象成员或者子对象 对象成员的初始化: 在构造函数成员初始化表中初始化 在构造函数体内初始化 说明: 一般而言在类中出现了对象成员时, 创建本类对象既要对本类的数据成员进行初始化, 又要对对象成员进行初始化 构造函数的调用顺序: 先调用对象成员的构造函数再调用本类的构造函数, 析构函数的调用顺序则相反 如果调用本类默认形式的构造函数那么也只能调用对象成员默认形式的构造函数 11 | 类模板 类模板是对一批仅有成员数据类型不同的类的抽象 由类模板实例化生成的类叫模板类 注意: 在类模板外定义成员函数时, 每一个函数前均要加上template e.g. 在定义对象时需要带入实际的类型名 e.g. 类模板可以包含与通用类型相关的默认参数, 如果没有指定其他的数据类型就使用默认类型 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/13-OOP/04. 运算符重载和友元.html":{"url":"roccoshi_note/13-OOP/04. 运算符重载和友元.html","title":"04. 运算符重载和友元","keywords":"","body":"04. 运算符重载 | 友元1 | 友元1-1 友元函数1-2 友元类2 | 运算符重载为类的成员函数3 | 运算符重载为类的友元函数4 | 重载输入>>输出5 | 转换构造函数和类型转换函数5-1 转换构造函数5-2 类型转换函数04. 运算符重载 | 友元 1 | 友元 友元可以是一个全局函数, 另一个类的成员函数或者是一个类 友元类的所有成员函数都是友元函数, 可以访问被访问类的任何成员 友元声明以关键字friend开始, 出现在被访问类的定义中 友元函数不是类的成员函数 一个类的友元可以自由地使用该类中的所有成员 友元关系是单向的, 且不能传递 1-1 友元函数 友元函数近似于普通函数, 不带有this指针, 所以必须将对象名或对象引用作为友元函数的参数, 这样才能访问对象的成员 友元函数必须在类的定义中声明, 其函数体可以在类内或者类外定义 class A { void fun (B &); //是A的成员函数 } class B { friend void A::fun (B &); // 是B的友元函数, B是被访问类 } 1-2 友元类 class A { friend class B; // B是A类的友元 } class B { ... // B类中可以任意使用A类的成员 } 2 | 运算符重载为类的成员函数 重载双目运算符: // 与该类相加 A operator + (A &); // 与复数相加 A operator - (double a); 重载单目运算符++ --: // 重载++i A operator ++ (); // 重载i++ (约定放一个int参数表示为后置运算符) A operator ++ (int); 运算符重载为成员函数时最多有一个形参 重载双目运算符时, 只能带有一个参数, 参数可以是对象或者是对象的引用或者是其它类型的参数 运算符的左操作数为当前对象, 并且要用到隐含的this指针, 故运算符重载函数不能定义为静态成员函数, 因为静态成员函数没有this指针 3 | 运算符重载为类的友元函数 和重载成员函数的区别: 当运算符重载为类的成员函数时, 对于单目运算符, 操作数一定是对象本身, 对于双目运算符, 左操作数一定是对象 当运算符重载为友元函数时,参数中同样必须有一个是用户自定义类型的对象, 但不限定其必须是左操作数, 参与运算的对象全部成为函数参数 e.g. c = a + b; // 成员函数 c = a.operator+(b); // 友元函数 c = operator+(a, b); 友元重载双目运算符: // 第一个参数代表左操作数, 第二个参数代表右操作数 friend A operator + (A& , A&); 友元重载单目运算符++: // 类内声明 // ++i friend A operator ++(A &a); // i++ friend A operator ++(A &a, int n); //类外定义 A operator ++(A &a){} A operator ++(A &a, int n){} 4 | 重载输入>>输出运算符 >>和只能被重载为友元函数 返回值分别为istream和ostream的引用 // 类内声明 friend istream & operator >> (istream &, A&); friend ostream & operator > (istream &is, A& a){} ostream & operator e.g. // 一个实例 istream & operator >> (istream &is, A& a) { cout > a.x >> a.y; return is; } 5 | 转换构造函数和类型转换函数 5-1 转换构造函数 e.g. class B { int x; public: B(int a) { x = a; cout 5-2 类型转换函数 基本格式: operator () { ... return } e.g. class A { private: int i; public: A(int k) { i = k; } operator int () { return i; } }; int main() { A a(3); cout class a { private: int x; public: a(int x):x(x){} void show() const { cout Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/13-OOP/05. 继承与派生.html":{"url":"roccoshi_note/13-OOP/05. 继承与派生.html","title":"05. 继承与派生","keywords":"","body":"05. 继承与派生1 | 类的三种继承方式2 | 派生类的构造函数和析构函数构造函数和析构函数的调用顺序3 | 多继承和虚基类虚基类构造函数的调用顺序虚基类的初始化05. 继承与派生 1 | 类的三种继承方式 类有三种继承方式: public protected private 默认情况下为private继承 三种继承方式下基类成员的访问控制权限: 继承 成员 公有继承 私有继承 保护继承 公有成员 公有 私有 保护 私有成员 派生类成员不可访问 派生类成员不可访问 派生类成员不可访问 保护成员 保护 私有 保护 无论哪种继承方式, 基类的私有成员在派生类中都是不可访问的, 只有通过基类的成员函数访问基类的私有成员; 如果要在派生类中访问基类私有成员, 可以将派生类声明为基类的友元 2 | 派生类的构造函数和析构函数 不能在派生类的构造函数体中显式调用基类构造函数来初始化基类成员 解决办法: 使用成员初始化表调用基类构造函数 格式: 当基类没有显式定义构造函数或者定义无参构造函数时, 派生类可以省略对基类构造函数的调用 构造函数和析构函数的调用顺序 调用顺序为: 基类的构造函数 -> 对象成员构造函数 -> 派生类构造函数 析构函数顺序相反 (栈) 3 | 多继承和虚基类 当派生类有多个基类时成为多继承 在多继承时的构造函数调用顺序为定义派生类时所指定的基类顺序, 与派生类构造函数中所定义的成员初始化列表顺序无关 如果有多个成员类对象, 则构造函数的调用顺序是对象在类中被声明的顺序而不是它们出现在成员初始化表中的顺序 虚基类 为了避免对基类成员访问的二义性问题, 可以将直接基类的共同基类设置为虚基类, 这样共同基类在内存中只有一个副本存在 虚基类的定义格式为: class A: virtual public B; 应当在基类的所有派生类中声明为虚基类, 否则仍然会出现对基类的多次继承 构造函数的调用顺序 先调用虚基类的构造函数, 再调用非虚基类的构造函数 若同一层次中包含多个虚基类, 其调用顺序为定义时的顺序 若虚基类由非虚基类派生而来, 则仍按先调用基类构造函数再调用派生类构造函数的顺序 虚基类的初始化 如果在虚基类中只定义了带参数的构造函数, 则需要在其所有派生类中, 通过构造函数的初始化表对虚基类进行初始化 class base { public: base (int x) { cout Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/13-OOP/06. 多态和虚函数.html":{"url":"roccoshi_note/13-OOP/06. 多态和虚函数.html","title":"06. 多态和虚函数","keywords":"","body":"06. 多态和虚函数1 | 类型兼容规则2 | 多态联编3 | 虚函数访问派生类的同名函数:例子注意4 | 纯虚函数抽象类06. 多态和虚函数 1 | 类型兼容规则 类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。 「替代」 派生类的对象可以赋值给基类的对象 派生类的对象可以初始化基类的引用 派生类的对象地址可以赋值给基类的指针变量 2 | 多态 「多态(Polymorphism)」是指具有相似功能的不同函数用一个名称来实现, 从而可以使用相同的调用方式来调用这些具有不同功能的同名函数的特性 两类多态: 名称 实现方式 静态多态性 函数重载 动态多态性 虚函数 联编 c++采用联编技术来支持多态 联编: 把一个标识符名和一个存储地址联系在一起的过程, 在多态的实现过程中, 确定调用哪个同名函数的过程就是联编, 又称为绑定 联编的分类 (按照联编进行的阶段): 名称 含义 静态联编 在编译阶段完成的联编, 通常在重载时使用 -- 「编译时多态」 动态联编 在程序执行的过程中根据具体情况动态决定, 在运行阶段完成的联编 -- 「运行时多态」 3 | 虚函数 当不用虚函数时, 若一个基类指针指向派生类, 调用的同名函数还是基类的方法 虚函数的使用: 类之间应满足类型兼容规则 同名声明虚函数 通过指针和引用来访问虚函数 声明虚函数的格式如下: virtual () 虚函数为一个类簇中的所有派生类的同一行为提供了统一的接口, 使得程序按在使用一个类簇时只需记住一个接口即可 访问派生类的同名函数: 将基类中的同名函数定义为虚函数 将不同的派生类对象地址赋给基类的指针变量 例子 class base { public: virtual void show () { cout show(); // Im base basePtr = &c; basePtr->show(); // Im child return 0; } 注: 一个函数一旦被声明为虚函数，则无论声明它的类被继承了多少层，在每一层派生类中该函数都保持虚函数特性。因此，在派生类中重新定义该函数时，可以省略关键字virtual。 当虚函数的声明与实现分开时, virtual关键字只能用在虚函数的声明中而不能用在虚函数的实现中 class B { public: virtual void print (); // 声明 }; // error: 'virtual' outside class declaration virtual void B::print() { // 错误的方式 cout 注意 静态函数和友元函数不能声明为虚函数, 因为他们不属于某一个对象 内联成员函数不能声明为虚函数, 因为在编译时已经被替换 构造函数不能是虚函数, 析构函数可以是虚函数 当在派生类中定义了虚函数的重载函数，但并没有重新定义虚函数时，与虚函数同名的重载函数覆盖了派生类中的虚函数。此时试图通过派生类对象、指针、引用调用派生类的虚函数就会产生错误。 e.g. 4 | 纯虚函数 纯虚函数用virtual声明，没有任何实现、必须由派生类重新定义该函数提供实现 格式: virtual () = 0 纯虚函数不需要定义实现方法, 它的存在只是为了在派生类中被重新定义, 提供给一个多态的接口 抽象类 包含一个或者多个纯虚函数的类成为抽象类 如果派生类没有实现基类中所有的纯虚函数, 则派生类也是抽象类 抽象类无法实例化, 即无法创建抽象类的对象, 但是可以声明抽象类的指针或引用, 通过指针和引用来指向并访问派生类对象, 从而实现动态多态 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "},"roccoshi_note/13-OOP/07. 输入输出流.html":{"url":"roccoshi_note/13-OOP/07. 输入输出流.html","title":"07. 输入输出流","keywords":"","body":"07. 输入输出流输入输出的格式控制流成员函数设置输出宽度设置填充字符设置输出精度用流成员函数put输出字符用流成员函数get读取字符控制符文件读写07. 输入输出流 I/O类库的层次结构: I/O类库的头文件: >> : 流提取运算符 : 流插入运算符 cout : ostream流类的对象, 全局定义ostream cout(stdout); cin : istream流类的对象, 全局定义istream cin(stdin); 输入输出的格式控制 c++提供两种格式化输入/输出方式: 流对象有关成员函数进行格式化输入输出 专门的控制符格式化输入输出 流成员函数 流成员函数主要是通过对状态标志, 输出宽度, 填充字符以及输出精度的操作来完成输入/输出格式化 输入/输出的格式由各种状态标志来确定, 在ios类中定义为枚举量 枚举量定义在ios类中, 因此引用时必须包含ios::前缀, 使用时应该全部用符号名 setf设置状态标志: long ios::setf(long flags) unsetf清除状态标志: long ios::unsetf(long flags) flags 获取状态标志 long ios::flags() 返回当前状态标志 long ios::flags(long flag) 将流的状态标志值设置为flag并返回设置前的状态标志 调用示例: .(ios::) // 例子 cout.setf(ios::showpos); cout.setf(ios::showpos | ios::scientific); 设置输出宽度 int ios::width(int len); 设置输出宽度并返回原来的输出宽度 (默认宽度为0) int ios::width(); 返回当前输出宽度 设置填充字符 char ios::fill(char ch); 设置填充字符并返回设置前填充字符 char ios::fill() 返回当前填充字符 设置输出精度 int ios::precision(int p); int ios::precision(); 用流成员函数put输出字符 专用于输出单个字符的成员函数put cout.put('a'); 用流成员函数get读取字符 cin.get()从输入流提取一个字符(包括空白字符), 返回值就是这个字符 cin.get(ch)从输入流读取一个字符并赋值给字符变量ch cin.get(char*, n, 'e')从输入流读取n - 1个字符赋值给char* 或 char[]如果在读取n - 1个字符之前遇到指定的终止字符则提前读取结束 cin.getline()读取一行字符, 同样可以有三个参数 控制符 控制符不属于任何类成员 控制符 作用 setw(int) 设置输入输出宽度 (只对其后一项输出/输入有效) setfill(char) 设置填充字符, 到下一次填充前一直有效 setprecision(int) 设置输出的有效位数 文件读写 在输入文件流类中有关读指针的函数如下: 移动读指针函数seekg(streampos pos); 返回读指针当前指向的位置值tellg(); 移动写指针函数seekp(); 返回写指针当前指向的位置值tellp(); Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-12-31 17:55:15 "}}