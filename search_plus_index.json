{"./":{"url":"./","title":"Introduction","keywords":"","body":"roccoshi的个人笔记库roccoshi的个人笔记库 是一个同步和保存笔记的地方 页面发布在gh-pages即 https://github.roccoshi.top/mynote 采用github actions自动集成, 方案见 https://zlogs.net/gitbook-action/#source Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 15:42:19 "},"roccoshi_note/":{"url":"roccoshi_note/","title":"Roccoshi Note","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 16:18:26 "},"roccoshi_note/00-操作系统笔记/":{"url":"roccoshi_note/00-操作系统笔记/","title":"00-操作系统笔记","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/00-操作系统笔记/0. 作业管理 进程管理.html":{"url":"roccoshi_note/00-操作系统笔记/0. 作业管理 进程管理.html","title":"0. 作业管理 进程管理","keywords":"","body":"0. 作业管理 进程管理调度算法0. 作业管理 进程管理 1 | 系统调用是操作系统向上层提供的接口, 目态(用户态)即可执行 2 | 进程由程序段, 数据段和PCB三部分组成 3 | 进程的三种状态 : 4 | 线程 : 程序执行流的最小单位, 基本的CPU执行单元, 同一进程的不同线程共享进程的资源 5 | 处理机调度 : 高级调度-作业调度 中级调度-内存调度 低级调度-进程调度 6 | 调度算法的评价指标 调度算法 \\ Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/00-操作系统笔记/1. 信号量.html":{"url":"roccoshi_note/00-操作系统笔记/1. 信号量.html","title":"1. 信号量","keywords":"","body":"1. 信号量信号量的分类利用信号量实现同步与互斥同步互斥生产者-消费者问题吸烟者问题读-写者问题方案一方案二哲学家就餐问题方案一方案二方案三方案四1. 信号量 信号量 : 表示系统中某种资源的数量, 当它的值大于0时, 表示当前可用资源的数量; 当它的值小于0时, 其绝对值表示等待使用该资源的进程个数 P, V操作 : PV操作由P操作原语和V操作原语(不可中断)组成，针对信号量进行相应的操作. P操作相当于请求资源, V操作相当于释放资源 信号量的分类 整型信号量 本质就是一个数, 表示资源数量 int S = 1; // 整型信号量, 初始值为1, 表示系统中有一个资源 void P(int S){ // P操作 while(S 整型信号量的问题 : 存在\"忙等\", 即上述P操作时, 如果资源不够, 将一直执行while循环语句, 该进程会一直占用CPU, 为解决这个问题, 引入了记录型信号量 记录型信号量 除了记录资源数, 还加入了等待队列 定义如下: typedef struct{ int value; // 剩余资源数 struct process *L; // 等待队列 }semaphore; ​ 对应的P, V操作实现如下: void P(semaphore S){ S.value--; if(S.value 阻塞态 } // 如果剩余资源不够, 利用block原语使进程将进程挂起到S的等待队列(阻塞队列)中, 避免\"忙等\" } void V(semaphore S){ S.value++; if(S.value 就绪态 } // 释放资源后, 等待队列还有进程, 那么利用wakeup原语唤醒该进程 } 后文所使用的信号量均为semaphore即记录型信号量, 一般我们所说的信号量也均为记录型 利用信号量实现同步与互斥 同步 同步 : 保证\"一前一后\"执行两个操作 利用信号量实现同步 : semaphore S = 0; // 初始化信号量 = 0 P1(){ // P1进程 xx1; // 操作1 xx2; // 操作2 V(S); // 信号量++ } P2(){ P(S); xx3; // 操作3 xx4; // 操作4 } 总结就是 : 在\"前\"操作之后执行V操作, 在\"后\"操作之前执行P操作 互斥 互斥 : 实现对临界资源(一次只能供一个进程访问的资源)的访问 利用信号量实现互斥: semaphore mutex = 1; // 互斥信号量mutex, 初始化为1 P1(){ P(mutex); 访问临界区; V(mutex); } P2(){ P(mutex); 访问临界区; V(mutex); } 生产者-消费者问题 问题本质 : 实现对一个大小为n的缓冲区的互斥访问, 存取操作 问题描述: 生产者消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了两个共享固定大小缓冲区——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。 关键点 : 生产者消费者共享一个大小为n, 初始为空的缓冲区----缓冲区即临界资源 缓冲区未满时生产者才可以将产品放入----设置empty信号量 缓冲区不为空时消费者才可以将产品取出----设置full信号量 实现 : 信号量设置 : semaphore mutex = 1; // 互斥信号量, 实现对缓冲区的互斥访问 semaphore empty = n; // 同步信号量, 表示空闲缓冲区数(可放产品数) semaphore full = 0; // 同步信号量, 表示非空缓冲区数(放入产品数) 生产者消费者操作: producer(){ // 生产者 while(1){ P(empty); P(mutex); 产品放入缓冲区; V(mutex); V(full); } } consumer(){ // 消费者 while(1){ P(full); P(mutex); 取出产品; V(mutex); V(empty); } } tips : P(mutex)互斥操作必须在同步操作之后, 否则会引发\"死锁\": // 如果改变 P(mutex)和P(empty)顺序, 假设此时empty=0,即缓冲区已满 producer(){ // 生产者 while(1){ P(mutex); P(empty); 产品放入缓冲区; V(full); V(mutex); } } 比如我生产者先P(mutex)申请到了临界资源访问权限, 但是之后P(empty)时被阻塞, 此时消费者一方又由于mutex被生产者占有而无法取出产品, 导致互相等待对方释放资源, 即死锁 在此处, 如果缓冲区大小为1, 可以不设置mutex信号量(互斥可以由empty和full满足) 吸烟者问题 问题本质 : 可以生产多个产品的单生产者问题 问题描述 : 假设一个系统中有三个抽烟者进程，每个抽烟者不断地卷烟并抽烟。抽烟者卷起并抽掉一颗烟需要有三种材料：烟草、纸和胶水。一个抽烟者有烟草，一个有纸，另一个有胶水。系统中还有两个供应者进程，它们无限地供应所有三种材料，但每次仅轮流提供三种材料中的两种。得到缺失的两种材料的抽烟者在卷起并抽掉一颗烟后会发信号通知供应者，让它继续提供另外的两种材料。这一过程重复进行。 关键点 : 临界资源---桌子, 视为缓冲区, 大小为1 ---- 设置同步信号量finish 产品有3种不同的组合, 分别给3个不同的人使用 ---- 设置同步信号量offer1, offer2, offer3 生产者如何实现轮流生产3种产品 ---- for i in range(3)即可 注意这里不需要设置额外的互斥信号量mutex, 因为缓冲区大小为1 实现 : 信号量设置: semaphore offer1 = 0, offer2 = 0, offer3 = 0; semaphore finish = 0; // 抽烟是否完成 int i = 0; // 实现\"轮流生产\" provider(){ while(1){ if(i == 0) V(offer1); else if(i == 1) V(offer2); else if(i == 2) V(offer3); i = (i + 1) % 3; P(finish); // 注意由于finish初值为0,所以将P(finish)放在后面 } } smoker1(){ while(1){ P(offer1); // 拿烟,抽了 V(finish); // 完成抽烟,告诉生产者可以继续生产下一个了 } } smoker2(){ while(1){ P(offer2); // 拿烟,抽了 V(finish); // 完成抽烟,告诉生产者可以继续生产下一个了 } } smoker3(){ while(1){ P(offer3); // 拿烟,抽了 V(finish); // 完成抽烟,告诉生产者可以继续生产下一个了 } } 读-写者问题 问题本质 : 允许多个进程同时读缓冲区, 但是只允许一个进程写缓冲区 问题描述 : 一个共享文件, 可以有多个读者同时读文件, 或者一个写着向文件中写信息, 任一写者完成写操作前不允许其他读 / 写者工作, 写者执行写操作前所有的读者应当退出 关键点 : 实现多个读者同时读 实现读者-写者,写者-写者之间的互斥 实现 : 方案一 信号量设置 : semaphore rw = 1; // 实现对文件的互斥访问 int count = 0; // 记录读者的数目 semaphore mutex = 1; // 实现互斥 写者 : writer(){ while(1){ P(rw); write......... // 写文件 V(rw); } } 读者 : reader(){ while(1){ P(mutex); // 这里的mutex进用于实现count的互斥, 防止两个读者同时进入时出问题 if(count == 0) P(rw); // 第一个读者进来时将文件\"锁定\" count++; // 每来一个读者,count+1 V(mutex); read........ // 读文件 P(mutex) count--; if(count == 0) V(rw); // 最后一个读者退出时将文件权限释放 V(mutex); } } 方案一的问题 仔细分析后, 我们从上述方案中可以发现一个问题, 那就是如果读者源源不断的到来, 写者将一直被挂起\"饿死\", 这个方案实际上是不公平的, 具有\"读进程优先的特性\", 为了解决这个问题, 我们可以引入一个新的信号量w=1, 实现读者写者的公平性. 方案二 信号量设置 : semaphore rw = 1; int count = 0; semaphore mutex = 1; semaphore w = 1; // 方案一基础上增加 写者 : writer(){ while(1){ P(w); P(rw); write......... // 写文件 V(rw); V(w); } } 读者 : reader(){ while(1){ P(w); P(mutex); if(count == 0) P(rw); count++; V(mutex); V(w); //注意V(w)放在read之前 read........ P(mutex) count--; if(count == 0) V(rw); V(mutex); } } 分析 : 可以看到, 在方案二中, 如果读者读的过程中有写着想要访问, 那么该写者进程将挂在信号量w的等待队列上, 当该读者读完退出后, 写者即可以写, 当一个读者在读的时候, 它已经V(w)操作了, 也不会影响读者读的并行 哲学家就餐问题 问题本质 : 进程需持有多个临界资源才可以工作, 如何避免分配不当导致\"死锁\" 问题描述 : 哲学家就餐问题可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和筷子而不是意大利面和餐叉来描述，因为很明显，吃米饭必须用两根筷子。 由于有5只筷子, 相当于5个临界资源, 我们定义信号量数组chopstick[5]来表示这5个临界资源 semaphore chopstick[5] = {1,1,1,1,1} 同时为了方便描述, 我们给哲学家和筷子都编号 根据编号有如下定义: 哲学家i 号的左手筷子为chopstick[i] , 右手为chopstick[(i+1)%5] 我们很容易想到一种方式分配临界资源: 方案一 Pi(){ // Pi表示第i个哲学家进程 while(1){ P(chopstick[i]); // 拿左边筷子 P(chopstick[(i + 1) % 5]); // 拿右边筷子 eat...... // 吃饭 V(chopstick[i]); // 放下左边筷子 V(chopstick[(i + 1) % 5]); // 放下右边筷子 } } 这个方案有一个很明显的问题, 那就是如果五个哲学家同时拿筷子, 那么每个人都将拿起自己左手的筷子而等待右手的筷子 , 也就导致了\"死锁\"的局面, 如下图: 我们可以通过几种方式改变这种死锁局面, 核心思想均是防止所有人同时拿到1根筷子 : 方案二 描述 : 限制最多四人同时就餐 semaphore cnt = 4; // 限制4个人 semaphore chopstick[5] = {1,1,1,1,1}; semaphore Pi(){ // Pi表示第i个哲学家进程 while(1){ P(cnt); P(chopstick[i]); // 拿左边筷子 P(chopstick[(i + 1) % 5]); // 拿右边筷子 eat...... // 吃饭 V(chopstick[i]); // 放下左边筷子 V(chopstick[(i + 1) % 5]); // 放下右边筷子 V(cnt); } } 方案三 描述 : 奇数号先拿左手的筷子, 偶数号先拿右手的筷子 semaphore chopstick[5] = {1,1,1,1,1}; Pi(){ // Pi表示第i个哲学家进程 while(1){ if(i % 2 == 1){ // 奇数号 P(chopstick[i]); // 拿左边筷子 P(chopstick[(i + 1) % 5]); // 拿右边筷子 } else{ // 偶数号 P(chopstick[(i + 1) % 5]); // 拿右边筷子 P(chopstick[i]); // 拿左边筷子 } eat...... // 吃饭 V(chopstick[i]); // 放下左边筷子 V(chopstick[(i + 1) % 5]); // 放下右边筷子 } } 方案四 描述 : 互斥\"拿筷子\"这个动作 semaphore chopstick[5] = {1,1,1,1,1}; semaphore mutex = 1; Pi(){ // Pi表示第i个哲学家进程 while(1){ P(mutex); // 互斥 P(chopstick[i]); // 拿左边筷子 P(chopstick[(i + 1) % 5]); // 拿右边筷子 V(mutex); eat...... // 吃饭 V(chopstick[i]); // 放下左边筷子 V(chopstick[(i + 1) % 5]); // 放下右边筷子 } } 四种方法都很好理解, 总而言之就是不让五个哲学家都陷入等待的局面就ok啦~ 参考 https://www.bilibili.com/video/BV1YE411D7nH?p=26 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/00-操作系统笔记/2. 死锁的检测和解除.html":{"url":"roccoshi_note/00-操作系统笔记/2. 死锁的检测和解除.html","title":"2. 死锁的检测和解除","keywords":"","body":"2. 死锁的检测和解除资源分配图用资源分配图判断系统是否死锁方法 :e.x.死锁的解除资源剥夺法撤销进程法进程回退法2. 死锁的检测和解除 资源分配图 资源分配图是一种数据结构 : graph LR A[数据分配图] -->B[两种结点] A-->C[两种边] B-->D[进程结点:对应一个进程] B-->E[资源结点:对应一类资源,一类资源可能有多个] C-->F[进程结点->资源结点:表示进程想申请几个资源] C-->G[资源节点->进程结点:表示已经为进程分配了几个资源] 如图: 用资源分配图判断系统是否死锁 方法 : e.x. 没有死锁的资源分配图 : 死锁了的资源分配图 : 死锁的解除 资源剥夺法 挂起(暂时放在外存)某些 死锁 进程, 并抢占它的资源, 让这些资源分配给其他的死锁进程, 注意需要防止被挂起的进程长时间得不到资源而饥饿 撤销进程法 强制某些死锁进程, 并剥夺这些进程的资源. 优点 : 实现简单 缺点 : 代价大, 比如有些进程已经运行了很长时间甚至接近结束, 突然剥夺将功亏一篑 进程回退法 让一个或多个死锁进程回退到足以避免死锁的地步 缺点 : 不太容易实现--系统需要记录进程的历史信息并设置还原点 可以根据 : 进程优先级 已执行多长时间 还要多久能完成 已经使用了多少资源 等方式决定对那个死锁进程执行解除方案 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/00-操作系统笔记/3. 分页存储.html":{"url":"roccoshi_note/00-操作系统笔记/3. 分页存储.html","title":"3. 分页存储","keywords":"","body":"3. 分页存储基本分页存储管理页框和页面地址转换的实现3. 分页存储 内存管理学习笔记 : 操作系统---内存管理(上) 概念 覆盖交换技术 连续分配管理方式 操作系统---内存管理(中) 分页存储 操作系统---内存管理(下) 分段存储 段页式存储 虚拟内存 请求分页管理方式 本节笔记对应的课件下载地址 大纲 : 基本分页存储管理 页框和页面 思想 : 把内存分为一个个相等的小分区, 再按照分区大小把进程拆分成一个个小部分. 页框 : 页面 : 注意区分页框和页面的概念, 页框是针对内存的, 页面是针对进程的 地址转换的实现 特点 : 页面离散存放, 但是页面内部连续存放 访问逻辑地址A : ( 重点 ) 确定逻辑地址A的 \" 页号 \" P 找到P号页面在内存中的起始地址 ( 需要查找页表 ) 确定逻辑地址A的 \" 页内偏移 \" W 逻辑地址 Ａ的物理地址 = P号页面在内存中的起始地址 + 页内偏移量W 页号和页内偏移量 e.g. 为了方便计算页号和页内偏移量, 页面大小一般设置为2的整数幂( why ? ) : ( 妙啊 ) 页表 tips : 页表中的页号是\"隐含\"的, 可以不占用存储空间 e.g. 假设某系统物理内存大小为 4GB， 页面大小为 4KB， 则 每个页表项至少应该为多少字节？ 内存块大小=页面大小=4KB= 2122^{12}2​12​​B 4GB 的内存总共会被分为232212=220\\frac{2^{32}}{2^{12}} = 2^{20}​2​12​​​​2​32​​​​=2​20​​个内存块 内存块号的范围应该是 0 220−10 ~ 2^{20} -10 2​20​​−1 内存块号至少要用 20 bit 来表示 至少要用3B来表示块号(3*8=24bit) (但是, 为了方便页表的查询, 常常会让一个页表项占更多的字节, 使得每个页面恰好可以装得下整数个页表项) 如何理解 \"页号是隐含的\" : 基本地址变换机构 框图 : ( 重点 ! ) 步骤总结 : 根据逻辑地址计算出页号和页内偏移量 判断页号是否越界 查询页表, 找到页号对应的页表项, 确定页面存放的内存块号 用内存块号和页内偏移量得到物理地址 ( 页表长度*物理块号 + 页内偏移 = 物理地址 ( 计算机直接采用拼接物理块号和页内偏移的方式得到物理地址 ) ) 访问目标单元 ( 一共需要访问两次内存 : 第一次用来查页表, 第二次用于访问目标内存单元 ) 具有快表的地址变换机构 局部性原理 时间局部性 如果执行了程序中的某条指令, 那么不久之后这条指令很有可能再次执行; 如果某个数据被访问过, 不久之后该数据很可能再次被访问 ( 程序中存在大量的循环 ) 空间局部性 一旦程序访问了某个存储单元, 在不久之后, 其附近的存储单元也很有可能被访问到 ( 很多数据在内存中连续存放 ) 快表(TLB) 快表又成为联想寄存器(TLB), 是一种访问速度比内存块很多的高速缓冲存储器, 用来存放当前访问的若干页表项, 以加速地址变换的过程. 与此对应的, 内存中的页表常称为慢表. 步骤总结 : 快表与基本地址变换机构的比较 : tips : TLB 和 普通 Cache 的区别——TLB 中只有页表项的副本， 而普通 Cache 中可能会有其他各种数据的副本 两级页表 单级页表存在的问题 : 由于页号隐式表示, 所以要根据页号查询页表需要 : K 号页对应的页表项存放位置 = 页表始址 + K 4 要在*所有的页表项都连续存放的基础上才能用这种方法找到页表项 同时, 由局部性原理可知, 很多时候, 进程在一段时间内只需要访问某几个页面就可以正常运行了, 因此没有必要让整个页表都常驻内存 解决 : 把页表再分页并离散存储， 然后再建立一张页表记录页表各个部分的存放位置， 称为页目录表， 或称外层页表， 或称顶层页表. e.g. 关于页表常驻内存的解决 -- ( 虚拟存储技术 ) , 在页表项中增加一个标志位, 用于表示该页面是否已经调入内存 注意: 如果采用多级页表机制, 各级页表不能超过一个页面 两级页表的访存次数分析 : n级页表访存次数为n+1次: ( 以2级页表为例 ) 访问内存中的页目录表 ( 顶级页表 ) 访问内存中的二级页表 访问目标内存单元 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/00-操作系统笔记/4. 分段存储.html":{"url":"roccoshi_note/00-操作系统笔记/4. 分段存储.html","title":"4. 分段存储","keywords":"","body":"4. 分段存储基本分段存储管理方式分段系统的组成:段表查找过程分段和分页的对比段页式内存管理方式分页, 分段管理的优缺点分析段页式管理的结构段表, 页表查找过程虚拟内存传统存储管理方式的特征, 缺点请求分页管理方式页表机制缺页中断机构页面置换算法页面分配策略4. 分段存储 基本分段存储管理方式 分段 : 进程的地址空间会按照自身的逻辑关系划分为若干个段, 每个段都有一个段名, 每段从0开始编址 内存分配规则 : 以段为单位进行分配, 每个段在内存中占据连续空间, 但各段之间可以不相邻 分段系统的组成: 段号------ 段号的位数决定了每个进程最多可以分为几个段 段内地址------段内地址的位数决定了每个段的最大长度是多少 段表 程序分为多个段, 各个段离散地装入内存, 为了保证程序能正常运行, 就必须能从物理内存中找到各个逻辑段的存放位置. 为此, 需为每个进程建立一张段映射表, 简称 \" 段表 \" . 关于段表 : 每个段对应一个段表项, 记录着该段在内存中的起始位置 ( 基址 ) 和 段长 各个段表项的长度是相同的, 因此和页号一样, 段号是\" 隐含 \"的, 不占据存储空间 查找过程 分段和分页的对比 页是信息的物理单位, 分页的主要目的是为了实现离散分配, 提高内存利用率. 分页仅仅是系统管理上的需要, 完全是系统行为, 对用户是不可见的 段是信息的逻辑单位, 分段的主要目的是更好地满足用户需求. 一个段通常包含着一组属于一个逻辑模块的信息, 分段对用户是可见的, 用户编程时需要显式地给出段名 页的大小是固定且由系统决定, 段的长度却不固定, 决定于用户编写的程序 分页的用户进程地址空间是一维的, 分段的用户进程是二维的. 分段比分页更容易实现信息的共享和保护 段页式内存管理方式 分页, 分段管理的优缺点分析 优点 缺点 分页管理 内存空间利用率高. 不会产生外部碎片, 只有少量的内部碎片 不方便逻辑模块实现信息的共享与保护 分段管理 方便实现逻辑模块信息的共享与保护 如果段长过大, 为其分配很大的连续空间会很不方便, 并且段式管理会产生外部碎片 段页式管理的结构 先分段 , 再分页 段页式管理的逻辑地址结构 : 由段号, 页号, 页内偏移 组成 段号的位数决定了每个进程最多可以分为几个段 页号位数决定了每个段最大有多少页 页内偏移量决定了页面大小和内存块的大小 注意 : \"分段\"对用户是可见的, 而将各段\"分页\"对用户是不可见的, 系统会根据段内地址自动划分页号和段内偏移量, 因此段页式管理的地址结构是\"二维\"的. 段表, 页表 每一个进程对应一个段表, 每一个段又对应一个页表, 因此一个进程可能对应多个页表. 查找过程 由逻辑地址得到段号, 页号, 页内偏移 段号与段表寄存器的段长度比较, 检查是否越界 由段表始址, 段号找到对应段表项 ---- ( 一次访存) 根据段表中记录的页表长度, 检查页号是否越界 由段表中的页表地址, 页号得到查询页表, 找到相应页表项 ---- ( 二次访存) 由页面存放的内存块号, 页内偏移得到最终的物理地址 访问目标单元 ---- ( 三次访存) 虚拟内存 传统存储管理方式的特征, 缺点 一次性 : 作业必须一次性全部装入内存才能开始运行 作业很大时, 无法装入导致大作业无法运行 大量作业要求运行时内存无法容纳所有作业, 导致多道程序并发度下降 驻留性 : 一旦作业被装入内存, 就会一直驻留在内存中, 直到作业运行结束, 这样会导致内存中驻留大量的, 暂时用不到的数据, 浪费内存资源 虚拟内存---基于局部性原理 在程序装入时, 将程序中很快会用到的部分装入内存, 暂时用不到的部分留在外存, 就可以让程序开始执行. 在程序执行过程中, 当所访问的信息不在内存时, 由操作系统负责将所需信息由外存调入内存, 然后继续执行程序. 内存空间不够时, 操作系统负责将内存中暂时用不到的信息换出到外存 在用户看来, 就有一个比实际内存大很多的内存, 这就叫虚拟内存 注意 : 虚拟内存的最大容量是由计算机的地址结构 ( CPU的寻址范围 ) 确定的, 虚拟内存的实际容量 = $ min( 内存容量 + 外存容量, CPU寻址范围) $ 虚拟内存的实现 : 请求分页存储管理 请求分段存储管理 请求段页式存储管理 操作系统需要提供的功能 : 请求调页 ( 段 ) 页面置换 ( 段置换 ) 缺页时请求掉页不一定页面置换, 若还有可用的内存块, 就不用进行页面置换 请求分页管理方式 页表机制 缺页中断机构 在请求分页操作系统中, 每当要访问的页面不在内存时, 便产生一个缺页中断, 然后由操作系统的缺页中断处理程序处理中断 此时缺页的进程阻塞, 放入阻塞队列, 调页完成后再将其唤醒, 放回就绪队列 如果内存中有空闲块, 则为进程分配一个空闲块, 将所缺页面装入该块, 并修改页表中相应的页表项 如果内存中没有空闲块, 则由页面置换算法选择一个页面淘汰, 若该页面在内存期间被修改过, 则要将其写回外存, 未修改过的页面不用写回外存 缺页中断是因为当前执行的指令想要访问目标页面未调入内存而产生的, 因此属于内中断 : 页面置换算法 最佳置换算法OPT 每次选择淘汰的页面是以后永不使用或者在最长时间内不会使用的页面, 保证最低的缺页率 . 但是操作系统无法预判页面访问序列, 这种算法是无法实现的 先进先出置换算法 FIFO 每次淘汰的页面是最早进入内存的页面 实现 : 将调入内存的页面根据调入的先后顺序排成一个队列, 需要置换页面的时候选择队首的页面. 实现简单, 算法性能差, 不适应进程实际运行时的规律 最近最久未使用算法 LRU 当需要淘汰一个页面的时候, 选择现有页面中t值最大的, 即最近最久未使用的页面. 做题时的方法 : 需要淘汰页面时, 逆向检查此时在内存中的几个页面号, 最后一个出现的页号就是需要被淘汰的 LRU算法的特点 : 性能好, 但实现起来需要专门的硬件支持, 算法开销大 时钟置换算法 ( CLOCK ) / 最近未用算法 ( NRU ) 他们是同一种算法. 简单的CLOCK算法的实现方法 : 简单的时钟置换算法仅考虑到了一个页面最近是否被访问过, 但是事实上, 如果被淘汰的页面没有被修改过, 就不需要执行I/O操作写回外存. 只有被淘汰的页面被修改过时, 才需要写回外存------因此, 除了考虑一个页面最近有没有被访问过之外, 操作系统还应该考虑页面有没有被修改过. 在其他条件都相同时, 应该优先淘汰没有修改过的页面, 避免I/O操作, 这就是改进型的时钟置换算法的思想. 利用 (访问位R, 修改位M) 的形式表示各页面状态 对应页面 第一轮 : 找第一个 (0, 0)的帧用于替换 ( 不修改标志位 ) 最近没访问且没修改 第二轮 : 找第一个 (0, 1)的帧用于替换 ( 将所有扫描过的帧访问位设为0) 最近没访问但修改过 第三轮 : 找第一个 (1, 0)的帧用于替换 ( 不修改标志位 ) 最近访问过但没修改 第四轮 : 找第一个 (1, 1)的帧用于替换 最近访问过也修改过 特点 : 开销小, 性能也不错 页面分配策略 驻留集 请求分页存储管理器中给进程分配的物理块的集合. ( 系统给进程分配了n各物理块 ----的另一种表述 : 驻留集大小为n) 在采用虚拟存储技术的系统中, 驻留集的大小一般小于进程的总大小 如果驻留集太小, 会导致缺页频繁, 系统要花大量的时间来处理缺页, 实际用于进程推进的时间很少 如果驻留集太大, 会导致多道程序并发度下降, 资源利用率降低 几种分配策略 固定分配全局置换不存在, 因为进程物理块固定后不会再分配给别人 可变分配全局置换 : 只要缺页就给分配新物理块 可变分配局部置换 : 根据发生缺页的频率来动态地增加或减少进程的物理块 何时调入页面 预调页策略 请求调页策略 何处调入页面 文件区用于调入不会被修改的数据, 对换区用用于调入可能被修改的数据 抖动现象 工作集 一般来说 驻留集的大小不能小于工作集的大小, 否则进程运行过程中将频繁缺页. Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/00-操作系统笔记/5. 内存管理.html":{"url":"roccoshi_note/00-操作系统笔记/5. 内存管理.html","title":"5. 内存管理","keywords":"","body":"5. 内存管理大纲什么是内存存储单元逻辑地址和物理地址编译, 链接, 装入内存管理的概念内存空间的扩充覆盖与交换内存空间的分配和回收连续分配管理方式5. 内存管理 大纲 什么是内存 内存是用于存放数据的硬件 程序执行前需要先放到内存中才能被cpu处理 存储单元 如果计算机\"按字节编址\", 每个存储单元大小为8 bit 如果计算机\"按字编址\", 每个存储单元大小为16 bit 逻辑地址和物理地址 指令的编指一般采用逻辑地址, 即相对地址 物理地址 = 起始地址 + 逻辑地址 (理解) 编译, 链接, 装入 编译 : 由编译程序将用户源代码编译成若干个目标模块 链接 : 由连接程序将编译后形成的一组目标模块以及所需函数连接在一起, 形成一个完整的装入模块 链接的三种方式 : 静态链接-----装入模块不再拆开 装入时动态链接-----将各目标模块装入内存时, 边装入边链接的连接方式 运行时动态链接-----在程序执行中需要该目标模块时才对它进行链接 装入 : 由装入程序将装入模块装入内存运行 装入的三种方式: 绝对装入 静态重定位 动态重定位 绝对装入 : 在编译时, 如果知道程序将放到内存的哪个位置, 编译程序将产生绝对地址的目标代码, 装入程序按照装入模块中的地址, 将程序和数据装入内存 ------灵活性低, 只适合单道程序环境 静态重定位 : 又称为可重定位装入. 编译, 链接后的装入模块地址都是从0开始的, 指令中使用的地址和数据存放的地址都是相对于起始地址而言的逻辑地址. 可以根据内存的当前状况将装入模块装入到内存的适当位置. 装入时对地址进行\"重定位\", 逻辑地址变换为物理地址(地址变换是在装入时一次完成的). 动态重定位 : 装入程序把装入模块装入内存后不会立即把逻辑地址转换为物理地址, 而是把地址转换推迟到程序真正要执行时才进行. 因此装入内存后所有的地址依然是逻辑地址. 这种方式需要一个重定位寄存器(存放装入模块的起始位置)的支持 内存管理的概念 进程应该放在内存的哪里? 操作系统如何记录哪些内存区域已经被分配了, 哪些还空闲? 当进程运行结束之后, 如何将进程占用的内存空间释放? 操作系统负责内存空间的分配与回收 操作系统需要提供某种技术从逻辑上对内存空间进行扩充 操作系统需要实现地址转换功能, 负责程序的逻辑地址和物理地址的转换 操作系统需要提供内存保护功能, 保证各进程在各自存储空间内运行, 互不干扰 实现内存保护的两种方法: 在CPU设置一对上, 下限寄存器, 存放进程的上, 下限地址. 进程的指令要访问某个地址时, CPU检查是否越界 采用重定位寄存器(又叫基地址寄存器) 和界地址寄存器(又叫限长寄存器) 进行越界检查. 重定位寄存器中存放的是进程的起始物理地址, 界地址寄存器中存放的是进程的最大逻辑地址. 内存空间的扩充 覆盖与交换 覆盖, 交换, 虚拟存储技术常用于实现内存空间的扩充 覆盖技术 覆盖技术的思想 : 将程序分为多个段, 常用的段常驻内存, 不常用的段在需要的时候调入内存 内存中分为一个\"固定区\" 和若干个\"覆盖区\", 常用的段放在固定区, 不常用的段放在覆盖区 缺点 : 必须由程序员声明覆盖结构, 对用户不透明, 增加了用户的编程负担, 覆盖技术只用于早期的操作系统中. 交换技术 交换技术的思想 : 内存空间紧张时, 系统将内存中某些进程暂时换出外存, 把外存中某些已具备运行条件的进程换入内存(即进程在内存与磁盘间动态调度) 内存空间的分配和回收 连续分配管理方式 单一连续分配 在单一连续分配的方式中, 内存被分为系统区和用户区, 系统区用于存放操作系统的相关数据, 用户区用于存放用户进程的相关数据, 内存中只能有一道用户程序, 用户程序独占整个用户区空间. 优点 : 实现简单, 无外部碎片; 可以采用覆盖技术扩充内存; 不一定需要采取内存保护 缺点 : 只能用于单用户, 单任务的操作系统中; 有内部碎片; 存储器利用率极低 内部碎片 : 分配给某进程的内存区域有一部分没有用上, 即存在\" 内部碎片 \". 外部碎片 : 内存中的某些空闲分区由于太小而难以利用 固定分区分配 在产生了支持多道程序的系统后, 为了能在内存中装入多道程序而互相之间不产生干扰, 将整个用户区划分为若干个固定大小的分区(分区大小可以相等也可以不相等), 在每个分区中只能装入一道作业, 形成了最早的可运行多道程序的内存管理方式. 操作系统建立一个数据结构----分区说明表, 来实现各个分区的分配和回收, 每个表对应一个分区, 通常按分区大小排列. 每个表项包括对应分区的大小, 起始地址, 状态 优点 : 实现简单, 无外部碎片; 缺点 : 有内部碎片; 存储器利用率不高; 动态分区分配 动态分区分配又称为可变分区分配, 这种分配方式不会预先划分内存分区. 而是在进程装入内存时根据进程大小动态地建立分区, 并使得分区的大小正好适合进程的需要. 几个问题 : 系统用什么数据结构记录内存的使用情况? 当多个空闲分区都满足需求应该选择哪个分区进行分配? 如何进行分区的分配和回收操作? 常用的数据结构 : 空闲分区表, 空闲分区链 动态分配不会产生内部碎片, 而会产生外部碎片, 外部碎片可以通过\" 紧凑\"的方式解决(把基地址迁移) 四种动态分配的算法 首次适应算法 每次都从低地址开始查找, 找到第一个能满足大小的空闲分区 实现 : 把空闲分区按地址递增的次序排列. 每次分配内存时顺序地查找空闲分区链, 找到大小能满足要求的第一个空闲分区. 最佳适应算法 优先使用小的空闲分区 实现 : 空闲分区按容量递增次序链接. 每次分配内存时顺序查找空闲分区链, 找到大小能满足要求的第一个空闲分区 缺点 : 每次都选择最小的分区进行分配, 会留下越来越多的容量很小难以利用的内存块, 即产生很多的外部碎片 最坏适应算法 优先使用大的空闲分区 实现 : 空闲分区按容量递减次序链接 缺点 : 每次都选用最大的分区进行分配, 当较大的连续空闲区被小号之后, 如果有大进程到来则没有内存分区可以利用 邻近适应算法 在首次适应算法的基础上, 每次都从上次查找结束的位置开始查找空闲分区链(表), 找到大小能满足的第一个空闲分区 缺点 : 邻近适应算法导致无论低地址还是高地址的空闲分区都有相同的概率被使用, 也就导致了高地址部分的大分区更可能被使用划分为小分区, 最后导致没有大分区可用 综合来看, 首次适应算法的性能最好 算法开销大 : 最佳适应法, 最坏适应法 ( 需要经常排序) 算法开销小 : 首次适应算法, 邻近适应算法 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/00-操作系统笔记/6. 文件管理.html":{"url":"roccoshi_note/00-操作系统笔记/6. 文件管理.html","title":"6. 文件管理","keywords":"","body":"6. 文件管理文件的简介一个文件的属性文件的分类操作系统应该向上提供的功能文件的逻辑结构有结构文件文件目录文件控制块FCB单级目录结构两级目录结构多级目录结构 ( 树形目录结构 )无环图目录结构索引结点 ( FCB的改进 )文件的物理结构文件块和磁盘块文件分配方式---连续分配文件分配方式---链接分配文件分配方式---索引分配文件存储空间管理空闲表法空闲链表法位示图法成组链接法文件的基本操作创建文件删除文件打开文件关闭文件读文件, 写文件文件共享基于索引结点的共享方式 ( 硬链接 )基于符号链的共享方式 ( 软连接 )文件保护文件系统的层次结构6. 文件管理 文件的简介 一个文件的属性 文件名 标识符 类型 位置 大小 创建时间, 上次修改时间 文件所有者信息 保护信息 文件的分类 无结构文件 ( 流式文件) 如文本文件, 由一些二进制或字符流组成 有结构文件 ( 记录式文件 ) 如数据库表, 由一组相似的记录组成, 又称 \"记录式文件\" 记录 : 一组相关数据项的集合 操作系统应该向上提供的功能 创建文件---create系统调用 读文件---read系统调用 删除文件---delete系统调用 写文件---write系统调用 打开文件---open系统调用 关闭文件---close系统调用 文件的逻辑结构 graph LR A[文件的逻辑结构]---B[有结构文件] A---C[无结构文件] B---b1[顺序文件] B---b2[索引文件] B---b3[索引顺序文件] 这里重点讨论有结构文件 有结构文件 有结构文件由一组相似的记录组成, 又称记录式文件 . 每条记录又由若干个数据项组成, 如数据库表文件. 一般来说, 每条记录有一个数据项可作为关键字. 根据各条记录的长度是否相等, 可分为定长记录和可变长记录两种. 顺序文件 文件中的记录一个接一个地顺序排列( 逻辑上 ) , 记录可以是定长的或可变长的. 各个记录在物理上可以顺序存储或链式存储. 索引文件 索引顺序文件 索引顺序文件是索引文件和顺序文件思想的结合. 索引顺序文件中, 同样会为文件建立一张索引表, 但不同的是, 并不是每个记录都对应一个索引表, 而是一组记录对应一个索引表项 当记录过多的时候可以建立多级索引表 文件目录 文件控制块FCB 单级目录结构 早期的操作系统并不支持多级目录, 整个系统只建立一张目录表, 每个文件占一个目录项 单级目录实现了\"按名存取\", 但是不允许文件重名 单级目录不支持多用户操作系统 两级目录结构 早期的多用户操作系统采用两级目录结构, 分为主文件目录和用户文件目录. 多级目录结构 ( 树形目录结构 ) 理解 : 相对目录可以减少磁盘I/O操作次数 无环图目录结构 索引结点 ( FCB的改进 ) 将fcb除了文件名之外的所有信息放入索引结点存在外存, 只有找到对应的目录项时才将索引节点调入内存. 文件的物理结构 文件块和磁盘块 在内存管理中, 进程的逻辑地址空间被分为一个个的页面 同样的, 在外存管理中, 为了方便对文件数据的管理, 文件的逻辑地址空间也被分为了一个个的文件块 于是文件的逻辑地址也可以表示为 (逻辑块号, 块内地址)的形式 文件分配方式---连续分配 连续分配方式要求每个文件在磁盘上占有一组连续的块 操作系统可以直接算出逻辑块号对应的物理块号, 因此连续分配支持顺序访问和直接访问( 随机访问 ) 优点 : 连续分配的文件在顺序读/写时速度最快 缺点 : 采用连续分配的文件不方便拓展 存储利用率低, 会产生难以利用的磁盘碎片. ( 可以采用紧凑的方法来处理碎片, 但是需要耗费很大的时间代价 ) 文件分配方式---链接分配 隐式链接 采用隐式链接的链接分配方式, 很方便文件拓展 , 另外, 所有的空闲磁盘块都可以被利用, 不会有碎片问题, 外存利用率高 显式链接 文件分配方式---索引分配 文件离散地分配在各个磁盘块中, 系统为每个文件建立一张索引表, 索引表中记录了文件的各个逻辑块对应的物理块. 索引表存放的磁盘块称为索引块, 文件数据存放的磁盘块称为数据块 . 索引分配方式可以支持随机访问, 文件拓展也很容易实现, 但是索引表需要占用一定的存储空间 多层索引 K层索引访问一个数据块需要K+1次读磁盘操作 多层索引的各层索引大小不能超过一个磁盘块 会计算文件的长度 混合索引 混合索引是多种分配方式的结合 e.g. 一个文件的顶级索引表中既包含直接地址索引 , 又包含一级间接索引 ,还包含两级间接索引 ... 好处 : 对于小文件来说只需要很少的读磁盘操作 文件存储空间管理 空闲表法 空闲表记录空闲盘块号的起始地址和空闲块数 要求 : 连续的存储空间 如何分配磁盘块 : 与内存管理的动态分区类似, 为一个文件分配连续的存储空间. 同样可以采用首次适应 , 最佳适应 , 最坏适应等算法. 如何回收磁盘块 : 空闲链表法 空闲盘块链 空闲盘区链 位示图法 成组链接法 UNIX系统采用了成组链接法对空闲块进行管理 讲的很好的一篇图文结合博客 文件的基本操作 创建文件 使用 \"create系统调用\" 在外存中找到文件所需的时间 根据文件的存放路径的信息找到该目录对应的目录文件, 在目录中创建该文件对应的目录项 ( 目录项中包含了文件名, 文件在外存中的存放位置等信息 ) 删除文件 使用 \"delete系统调用\" 打开文件 打开文件表 读写指针 ：读 / 写操作进行到的位置记录 访问权限 : 只读 / 只写 / 可读可写.... 打开文件时不会把文件的数据直接读入内存 ( 读文件时才读入内存 ) 关闭文件 读文件, 写文件 文件共享 多个用户共享同一个文件, 意味着系统中只有 \"一份\" 文件数据 . 并且只要某个用户改了该文件的数据, 其他用户也可以看到文件数据的变化. 基于索引结点的共享方式 ( 硬链接 ) 删除 : 基于符号链的共享方式 ( 软连接 ) e.g. windows下的快捷方式 文件保护 口令保护 ( 口令放在系统中, 不太安全 ) 加密保护 ( 安全性高, 但加密 / 解密 需要耗费一定的时间 访问控制 文件系统的层次结构 e.g. Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/00-操作系统笔记/7. 磁盘.html":{"url":"roccoshi_note/00-操作系统笔记/7. 磁盘.html","title":"7. 磁盘","keywords":"","body":"7. 磁盘磁盘的结构磁盘, 磁道, 扇区数据的读写盘面, 柱面磁盘的分类磁盘调度算法 ( 寻道时间 )一次读 / 写操作所需要的时间先来先服务算法 FCFS最短寻找时间优先 SSTF扫描算法 SCAN ( 电梯算法 )总结减少磁盘 ( 延迟时间 ) 的办法交替编号错位命名磁盘地址结构的设计磁盘管理磁盘初始化磁盘的引导块坏块的管理7. 磁盘 磁盘的结构 磁盘, 磁道, 扇区 磁盘的表面由一些磁性物质组成, 可以用这些磁性物质来记录二进制数据 磁道 : 磁盘的盘面被划分成一个个磁道, 一个圈就是一个磁道 扇区 : 每一个磁道被划分成一个个扇区, 每个扇区就是一个个 \" 数据块 \", 各个扇区存放的数据量相同 ( 最内侧磁道上的扇区面积最小, 因此数据密度最大 ) 数据的读写 盘面, 柱面 如何根据地址读取一个块 : 磁盘的分类 根据磁头是否可以移动 : 活动头磁盘 固定头磁盘 根据盘片是否可以更换 : 固定盘磁盘 可换盘磁盘 磁盘调度算法 ( 寻道时间 ) 一次读 / 写操作所需要的时间 graph LR A[一次读/写操作所需要的时间]---B[寻道时间] A---C[延迟时间] A---D[传输时间] 寻找时间 (寻道时间) 在读 / 写数据之前, 把磁头移动到指定磁道所花的时间 启动磁头臂的时间 移动磁头的时间 延迟时间 通过旋转磁盘, 使磁头定位到目标扇区所需要的时间 传输时间 由磁盘读出 或 向磁盘写入数据所需要的时间 磁盘调度算法会直接影响寻道时间 先来先服务算法 FCFS 根据进程请求访问磁盘的先后顺序进行调度 最短寻找时间优先 SSTF ​ 可能产生 饥饿 现象 扫描算法 SCAN ( 电梯算法 ) SSTF算法产生饥饿的原因 : 磁头可能会在一个小区域内来回移动 SCAN : 只有磁头移动到最外侧磁道的时候才能往内移动, 移动到最内侧磁道的时候才能往外移动 LOOK调度算法 ( SCAN的改进 ) 在扫描算法的基础上增加 : 如果在磁头移动方向上已经没有别的请求, 就可以立即改变磁头移动方向 循环扫描算法 C-SCAN SCAN算法对于各个位置磁道的响应频率不平均, C-SCAN算法就是为了解决这个问题, 规定只有磁头朝特定方向移动时才处理磁道访问请求, 而返回时 直接快速移动至起始端而不处理任何情况 C-LOOK 调度算法 C-LOOK = C-SCAN + LOOK 总结 减少磁盘 ( 延迟时间 ) 的办法 延迟时间 : 把目标扇区转动到磁头下所花的时间 由于磁头读入一个扇区数据后需要一小段时间处理, 如果逻辑上相邻的扇区在物理上也相邻, 则读入几个连续的逻辑扇区, 可能需要很长的 \" 延迟时间 \". 交替编号 采用交替编号的策略, 让逻辑上相邻的扇区在物理上有一定的间隔, 可以使读取连续的逻辑扇区所需要的延迟时间更小 错位命名 将盘面之间的扇区不同样按顺序编号 而是使用0号盘面的1号扇区下是1号盘面的4号扇区....这样的方式 这样使得读取完磁盘块之后还有一段时间处理, 从而减少了延迟时间 磁盘地址结构的设计 采用 ( 柱面号, 盘面号, 扇区号 )--- 三维, 二维, 一维 磁盘管理 磁盘初始化 进行低级格式化 ( 物理格式化 ), 将磁盘的各个磁道划分为扇区, 一个扇区通常可分为头, 数据区, 尾三个部分. 管理扇区所需要的各种数据结构 ( 校验码等 )一般存放在头, 尾两个部分 将磁盘分区 , 每个分区由若干柱面组成 进行逻辑格式化, 创建文件系统. 包括创建文件系统的根目录, 初始化 磁盘的引导块 计算机开机时需要进行一系列初始化的工作, 这些初始化工作是通过执行初始化程序 (自举程序) 完成的. 初始化程序 ( 自举程序 ) 如果直接放在ROM中, 会很不方便, 因为ROM中的数据无法更改, 解决方法 : ROM中只存放很小的 \" 自举装入程序 \" 开机时计算机先运行 \" 自举装入程序 \", 通过执行该程序就可以找到引导块, 并将完整的\" 自举程序 \" 读入内存, 完成初始化 坏块的管理 对于简单的磁盘 ,可以在逻辑格式化时, 对磁盘进行坏块检查, 表明哪些扇区是坏扇区. 这种处理方式中, 坏块对操作系统不透明 对于复杂的磁盘 , 磁盘控制器 ( 磁盘设备内部的一个硬件部件 ) 会维护一个坏块链表. 在磁盘出厂前进行低级格式化时就将坏块链进行初始化. 会保留一些 \" 备用扇区 \" 用于替换坏块. 这种方案称为扇区备用 . 这种处理方式中, 坏块对操作系统透明. Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/00-操作系统笔记/8. 设备管理.html":{"url":"roccoshi_note/00-操作系统笔记/8. 设备管理.html","title":"8. 设备管理","keywords":"","body":"8. 设备管理IO设备IO控制器IO控制器的功能IO控制器的组成IO控制方式程序直接控制方式中断驱动方式DMA方式通道控制方式总结IO软件层次结构I/O核心子系统假脱机技术 ( SPOOLing )设备的分配与回收缓冲区管理缓冲区的概念缓冲区有什么作用 ?单缓冲双缓冲循环缓冲区缓冲池8. 设备管理 IO设备 I/O : Input / output I/O设备就是可以将数据输入到计算机或者可以接收计算机输出数据的外部设备， 属于计算机中的硬件部件 UNIX系统将外部设备抽象为一种特殊的文件， 用户可以使用与文件操作相同的方式对外部设备进行操作 Write : 向外部设备写出数据 Read : 向外部设备读入数据 IO设备的分类 IO控制器 CPU无法直接控制I/O设备的机械部件, 因此I/O设备还要有一个电子部件作为CPU和I/O设备机械部分之间的 \"中介\", 用于实现CPU对设备的控制 这个机械部件就是 I / O控制器, 又称设备控制器. CPU可控制I/O控制器, 又由I/O控制器来控制IO设备的机械部件 IO控制器的功能 接受和识别CPU发出的命令 向CPU报告设备的状态 数据交换 地址识别 IO控制器的组成 CPU与控制器的接口 : 用于实现CPU与控制器之间的通信, CPU通过控制线发出命令, 通过地址线指明要操作的设备, 通过数据线来取出输入数据, 或放入输出数据 IO逻辑 : 负责接收和识别CPU的各种命令, 并负责对设备发出命令 控制器与设备的接口 : 用于实现控制器与设备之间的通信 IO控制方式 程序直接控制方式 通过 轮询 实现 优点 : 实现简单. 缺点 : CPU的干预很频繁, 在IO操作开始之前, 完成之后都需要CPU的介入, 并且等待IO完成的过程中CPU需要不断地轮询检查, CPU长期处于\"忙等\" 状态, CPU利用率低 中断驱动方式 引入中断机制, 由于IO设备速度很慢, 因此在CPU发出读/写命令后, 可将等待IO的进程阻塞, 先切换到别的进程执行 CPU只需要在每次IO开始之前和完成之后介入, 解决了程序直接控制方式中CPU需要不停轮询的特点, CPU的利用率得到明显提升. 缺点 : 每个字在I/O设备与内存之间的传输都需要经过CPU, 而频繁的中断处理会消耗较多的CPU时间. DMA方式 与 \" 中断驱动方式 \" 相比, DMA方式有这样几个改进 : 数据的传送单位是 \" 块 \" 数据的流向是从设备直接放入内存, 或者从内存直接到设备, 不需要CPU作为中介 仅在传送一个或多个数据块的开始和结束时才需要CPU的干预 DMA控制器 : DMA的优缺点 : 通道控制方式 通道 : 一种硬件, 通道可以识别并执行一系列通道指令 总结 IO软件层次结构 设备驱动程序 : 直接涉及到硬件具体细节且与中断无关的操作 设备独立性软件 : 不涉及硬件且对各种设备都需要进行的管理工作 I/O核心子系统 I/O调度 : 比如磁盘调度 ( 先来先服务, SCAN, LOOK...) 设备保护 : UNIX中设备被看作文件, 每个设备也会有对应的FCB ( 文件控制块 ). 当用户请求访问某个设备时, 系统根据FCB中记录的信息来判断用户是否有相应的访问权限, 以此实现 \" 设备保护\" 的功能. 假脱机技术 ( SPOOLing ) 假脱机技术 ( SPOOLing技术 ) 是用软件的方式模拟脱机技术. SPOOLing系统的组成如下 : 独占式设备 : 只允许各个进程串行使用的设备 共享设备 : 允许多个进程 \" 同时 \" 使用的设备 打印机是一种 \" 独占式设备 \" , 但是可以用SPOOLing技术改造成 \" 共享设备 \" e.g. 共享打印机原理分析 设备的分配与回收 从进程运行的安全性上考虑, 设备分配有两种方式 : 安全分配方式 : 为进程分配一个设备后就将进程阻塞, 本次I/O完成后才将进程唤醒. 不安全分配方式 : 进程发出I/O请求后, 系统为其分配I/O设备, 进程可继续执行, 之后还可以发出新的I/O请求. 只有某个I/O请求得不到满足时才将进程阻塞. 安全分配方式破坏了死锁的\"请求与保持\"条件, 不会死锁, 但是对于一个进程来说, CPU和I/O设备只能串行工作 不安全分配方式下进程的计算任务和I/O任务可以并行处理, 使进程迅速推进, 但是可能发生死锁 设备分配管理中的数据结构 设备, 控制器, 通道之间的关系 : 设备控制表 ( DCT ) : 系统为每个设备配置一张DCT, 用于记录设备情况 控制器控制表 ( COCT ) : 系统根据COCT对控制器进行操作和管理 通道控制表 ( CHCT ) : 系统根据CHCT的信息对通道进行操作和管理 系统设备表 ( SDT ) : 记录了系统中全部设备的情况, 每个设备对应一个表目 设备分配的步骤 根据进程请求的物理设备名查找SDT 根据SDT找到DCT, 若设备忙碌则将进程PCB挂到设备等待队列中, 不忙碌则将设备分配给进程 根据DCT找到COCT, 若控制器忙碌则将进程PCB挂到控制器等待队列中, 不忙碌则将控制器分配给进程 根据COCT找到CHCT, 若通道忙碌则将PCB挂到通道等待队列中, 不忙碌则将通道分配给进程 只有设备, 控制器, 通道三者都分配成功时, 这次设备分配才算成功, 之后便可启动I/O设备进行数据传送 可改进处 : 第一步中,可以通过LUT ( 逻辑设备表 )实现逻辑设备名到物理设备名的映射, 用户编程时只需要使用逻辑设备名申请设备而不必记忆物理设备名. 缓冲区管理 缓冲区的概念 缓冲区是一个存储区域, 可以由专门的硬件寄存器组成, 也可以利用内存作为缓冲区. 使用硬件作为缓冲区的成本较高, 容量较小, 一般仅用在对速度要求非常高的场合. 比如联想寄存器 ( 快表 ) 就是硬件作为缓冲区 一般情况下, 更多的是利用内存作为缓冲区 缓冲区有什么作用 ? 缓和CPU与IO设备之间速度不匹配的矛盾 减少对CPU的中断频率, 放宽对CPU中断相应时间的限制 解决数据粒度不匹配的问题 提高CPU与IO设备之间的并行性 单缓冲 假设设备把缓冲区充满的时间为$T$ , CPU处理工作区数据的时间为$C$, 缓冲区向工作区传送的时间为$M$, 则采用单缓冲策略每处理一块数据平均耗时为 : >Max(C,T)+M> > Max(C,T) + M > >Max(C,T)+M> 双缓冲 循环缓冲区 缓冲池 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/":{"url":"roccoshi_note/01-计算机网络笔记/","title":"01-计算机网络笔记","keywords":"","body":"考纲考纲 1-10 11-19 20-23 24-25 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/1. 物理层/":{"url":"roccoshi_note/01-计算机网络笔记/1. 物理层/","title":"1. 物理层","keywords":"","body":"物理层物理层 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/1. 物理层/1.1 码元 波特 速率 带宽.html":{"url":"roccoshi_note/01-计算机网络笔记/1. 物理层/1.1 码元 波特 速率 带宽.html","title":"1.1 码元 波特 速率 带宽","keywords":"","body":"1.1 码元, 波特, 速率, 带宽1.1 码元, 波特, 速率, 带宽 名词 解释 码元 M进制码元 : 有M种高低不同的信号波形 ( M种离散状态 ) 速率 分为 码元传输速率 和 信息传输速率 码元传输速率 : 单位是波特 ( baud ), 一波特表示每秒钟传输一个码元 信息传输速率 : 又叫比特率, 单位是比特/秒 ( bit/s ) 带宽 网络中一点到另一点所能通过的最高数据率 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/1. 物理层/1.2 奈奎斯特定理和香农定理.html":{"url":"roccoshi_note/01-计算机网络笔记/1. 物理层/1.2 奈奎斯特定理和香农定理.html","title":"1.2 奈奎斯特定理和香农定理","keywords":"","body":"1.2 奈奎斯特定理和香农定理奈奎斯特定理 :香农定理 :1.2 奈奎斯特定理和香农定理 奈奎斯特定理 : 在理想低通条件下, 为了避免码间串扰, 极限码元传输速率为 2W Baud , 其中W为信道带宽, 单位是HZ 理想低通信道下的极限数据传输率 = ( V是码元的种类数 ) 2W×log2V(b/s) 2W\\times \\log _2V\\,\\,\\left( b/s \\right) 2W×log​2​​V(b/s) 香农定理 : 信噪比 : 信噪比=信号平均功率噪声平均功率,常记为SN,并用分贝(db)作为度量单位 \\text{信噪比} = \\frac{\\text{信号平均功率}}{\\text{噪声平均功率}}, \\text{常记为} \\frac{S}{N}, \\text{并用分贝(db)作为度量单位} 信噪比=​噪声平均功率​​信号平均功率​​,常记为​N​​S​​,并用分贝(db)作为度量单位 信噪比(db)=10log10(SN) \\text{信噪比}(db) = 10 log _{10} (\\frac{S}{N}) 信噪比(db)=10log​10​​(​N​​S​​) 香农定理 : 在带宽有限且有噪声的信道中, 为不产生误差, 信息的数据传输速率的上限值为 : Wlog2(1+SN)(b/s) W\\log _2\\left( 1+\\frac{S}{N} \\right) (b/s) Wlog​2​​(1+​N​​S​​)(b/s) 香农定理和奈奎斯特定理都是限制了数据传输速率, 不同的是前者是无噪声条件下, 后者是有噪声条件下 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/1. 物理层/1.3 编码与调制.html":{"url":"roccoshi_note/01-计算机网络笔记/1. 物理层/1.3 编码与调制.html","title":"1.3 编码与调制","keywords":"","body":"1.3 编码与调制数字数据编码为数字信号数字数据调制为模拟信号模拟数据编码为数字信号1.3 编码与调制 数字数据编码为数字信号 1. 非归零编码---NRZ 高1低0, 编码易实现但是没有检错功能 2. 归零编码---RZ 信号电平在一个码元之内需要恢复到0的编码方式 3. 反向不归零编码 (NRZI) 信号电平翻转表示0, 信号电平不变表示1 4. 曼彻斯特编码 用间隔的高低电平表示0, 1 优点 : 具有自同步功能 缺点 : 曼彻斯特编码的频率要比NRZ高一倍，传输等量数据所需的带宽大一倍 5. 差分曼彻斯特编码 在曼彻斯特编码的基础上采用码间的同或异来表示0, 1 同1异0 6. 4B/5B编码 用5bit来表示4bit的数据, 编码效率80% 数字数据调制为模拟信号 方法 缩写 调幅 ( 幅移键控 ) 2ASK 调频 ( 频移键控 ) 2FSK 调相 ( 相移键控 ) 2PSK 调幅 + 调相 QAM 模拟数据编码为数字信号 抽样 f采>=2f信号最高频率 f _\\text{采} >= 2f _\\text{信号最高频率} f​采​​>=2f​信号最高频率​​ 量化 编码 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/1. 物理层/1.4 传输介质和物理层设备.html":{"url":"roccoshi_note/01-计算机网络笔记/1. 物理层/1.4 传输介质和物理层设备.html","title":"1.4 传输介质和物理层设备","keywords":"","body":"1.4 传输介质 物理层设备传输介质物理层设备中继器集线器1.4 传输介质 物理层设备 传输介质 导向性传输介质 非导向性传输介质 导向性传输介质 : 双绞线 --- 可以传输模拟和数字信号 ( 有屏蔽双绞线STP, 无屏蔽双绞线UTP ) 同轴电缆 --- 只能传输数字信号 光纤 物理层设备 中继器 由于存在损耗, 在线路上传输的信号功率会逐渐衰减, 衰减到一定程度时会造成信号失真, 导致接收错误 中继器对信号进行再生和还原, 对衰减的信号进行放大, 保持与原数据相同, 以增加信号传输的距离, 延长 网络的长度 集线器 集线器对信号进行再生放大转发, 对衰减的信号进行放大, 接着转发到其他所有处于工作状态的端口上, 以增加信号传输的距离, 延长网络的长度 集线器不具备信号的定向传送能力, 是一个共享式设备 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/","title":"2. 数据链路层","keywords":"","body":"数据链路层数据链路层 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.5 流量控制和可靠传输/":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.5 流量控制和可靠传输/","title":"2.5 流量控制和可靠传输","keywords":"","body":"流量控制与可靠传输流量控制的方法---自动重传请求( ARQ )流量控制与可靠传输 关于数据链路层和传输层的流量控制手段 : 数据链路层的流量控制手段 : 接收方收不下就不回复确认 传输端的流量控制手段 : 接收端给发送端一个窗口公告 可靠传输的解释 : 发送端发送的内容接收端要确保收到 流量控制的解释 : 控制发送速率, 使接收方有足够的缓冲空间来接收每一个帧 流量控制的方法---自动重传请求( ARQ ) 自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。 停止-等待ARQ协议 每发送完一个帧就停止发送, 等待对方的确认, 在收到确认后再发送下一个帧 发送窗口大小 = 1, 接收窗口大小 = 1 滑动窗口协议 后退N帧ARQ协议 ( GBN ) 发送窗口大小 > 1, 接收窗口大小 = 1 选择重传ARQ协议 ( SR ) 发送窗口大小 > 1, 接收窗口大小 > 1 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.5 流量控制和可靠传输/2.5.1 停止-等待协议.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.5 流量控制和可靠传输/2.5.1 停止-等待协议.html","title":"2.5.1 停止-等待协议","keywords":"","body":"2.5.1 停止-等待协议停止等待协议的性能分析2.5.1 停止-等待协议 每发送完一个帧就停止发送, 等待对方的确认, 在收到确认后再发送下一个帧 当数据帧丢失或者检测到帧出错 RTT : 往返时延 (Round-trip delay time ) 帧一去 + 一回 = 1个RTT 一般采用超时计时器的方式, 每次发送一个帧就启动一次计时器, 当计时器到时间没有收到确认就再发送一次, 计时器的时间设置要大于RTT 注意 : 发完一个帧后需要保留副本 数据帧和确认帧必须编号 当ACK丢失 ack丢失后会触发超时重传机制, 由于数据帧有编号, 所以接收方收到第二次同编号数据帧时会重传确认帧并丢弃重复的帧 当ACK迟到 由于1帧已经发送, 0帧的确认收到后不做处理, 直接丢弃即可 停止等待协议的性能分析 优点 : 简单 缺点 : 信道利用率太低 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.5 流量控制和可靠传输/2.5.2 后退N帧协议GBN.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.5 流量控制和可靠传输/2.5.2 后退N帧协议GBN.html","title":"2.5.2 后退N帧协议GBN","keywords":"","body":"2.5.2 后退N帧协议GBN后退N帧协议中的滑动窗口累计确认超时事件接收方要做的事滑动窗口的长度例题GBN的性能分析优点不足2.5.2 后退N帧协议GBN 后退N帧协议中的滑动窗口 发送窗口 : 大小>1 接收窗口 : 大小=1 接收窗口收到帧后发送一个ack, 发送窗口收到这个ack后向前滑动一格 累计确认 在GBN协议中, 对n号帧采用累积确认的方式, 表明接收方已经收到n号帧以及它之前的全部帧 注意 : 帧的编号是循环的如 0 1 2 3 0 1 2 3 0 1...... 超时事件 在GBN协议中, 如果出现超时, 发送方将重传所有已发送但未被确认的帧 接收方要做的事 当正确收到了n号帧 ( 按序 ) : 为n号帧发送一个ACK (累计确认), 并且将该帧中的数据部分发送给上层 其余情况 : 均丢帧 , 并为最近按序接收的所有帧重新发送ACK, 接收方无需缓存任何失序帧, 只需要维护一个信息---预期下一个按序接收的帧序号 滑动窗口流程 滑动窗口的长度 若采用n个比特对帧编号, 那么滑动窗口发送的尺寸应当满足 1=WT=2n−1 1 1=W​T​​=2​n​​−1 因为如果滑动窗口尺寸过大, 就会使得接收方无法取别新帧和旧帧 比如用2个bit对帧编号, 则帧为0 1 2 3 0 1 2 3 .... 那么滑动窗口的大小这时候应该是 1~3 , 若更大则无法取别新帧和旧帧 例题 例题 GBN的性能分析 优点 因连续发送数据帧而提高了信道的利用率 不足 在重传时必须把原来已经正确传送的数据帧重传, 使得传输效率降低 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.5 流量控制和可靠传输/2.5.3 选择重传协议SR.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.5 流量控制和可靠传输/2.5.3 选择重传协议SR.html","title":"2.5.3 选择重传协议SR","keywords":"","body":"2.5.3 选择重传协议SR选择重传协议中的滑动窗口发送方接收方运行中的SR流程滑动窗口长度总结与例题例题 :2.5.3 选择重传协议SR preview : GBN采用累计确认 + 批量重传的方式, 导致接收方会在某一帧出错时丢弃后面大量未出错的帧, 那么是否有一种方法可以只重传出错的帧 ? 解决方法 : 设置单个确认, 同时加大接收窗口, 设置接收缓存, 缓存乱序到达的帧 选择重传协议中的滑动窗口 发送方和接收方的窗口 发送方 此时下界移动到2号, 同时发送5号帧 接收方 来者不拒的接收方 运行中的SR流程 模拟SR的运行 滑动窗口长度 发送窗口一般 = 接收窗口, 大小为 : WTmax=WRmax=2n−1 W_\\text{Tmax} = W_\\text{Rmax} = 2^{n-1} W​Tmax​​=W​Rmax​​=2​n−1​​ 总结与例题 对数据帧逐一确认, 收一个确认你一个 只重传出错帧 接收方有缓存 窗口长度最大为2n−12^{n-1}2​n−1​​ 例题 : 例题 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/","title":"2.6 介质访问控制","keywords":"","body":"介质访问控制传输数据使用的两种链路介质访问控制静态划分信道---信道划分介质访问控制动态分配信道介质访问控制 传输数据使用的两种链路 点对点链路 : 两个相邻结点通过一个链路相连, 没有第三者 应用 : PPP协议, 常用于广域网 广播式链路 : 所有主机共享通信介质 应用 : 早期的总线以太网和无线局域网, 常用于局域网 典型拓扑结构 : 总线型, 星型 介质访问控制 介质访问控制的内容就是, 采取一定的措施, 使得两对节点之间的通信不会发生相互干扰的情况 静态划分信道---信道划分介质访问控制 频分多路复用FDM ( Frequency-division multiplexing ) 时分多路复用TDM ( Time-division multiplexing ) 码分多路复用CDM ( Code-division multiplexing) 波分多路复用WDM ( Wavelength-division multiplexing ) 动态分配信道 轮询访问介质访问控制 轮询协议 令牌传递协议 随机访问介质访问控制 ALOHA协议 CSMA协议 CSMA/CD协议 CSMA/CA协议 三种方式的对比总结 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.1 信道划分介质访问控制.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.1 信道划分介质访问控制.html","title":"2.6.1 信道划分介质访问控制","keywords":"","body":"2.6.1 信道划分介质访问控制多路复用技术频分多路复用FDM时分多路复用TDM波分多路复用WDM码分多路复用CDM2.6.1 信道划分介质访问控制 信道划分介质访问控制的概念 : 将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开, 把时域和频域资源合理地分配给网络上的设备 多路复用技术 把多个信号组合在一条物理信道上进行传输, 使得多个计算机或终端设备共享信道资源, 提高信道利用率 多路复用技术和共享信道 频分多路复用FDM 用户在分配到一定的频带后, 在通信过程中自始至终都占用这个频带 频分复用的所有用户在同样的时间占用不同的带宽 ( 频率带宽 ) 资源 FDM 频分多路复用充分利用传输介质带宽, 系统效率较高, 实现也比较容易 时分多路复用TDM 将时间划分为一段段等长的时分复用帧, 每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙, 所有用户轮流占用信道 TDM FDM可以类比为\"并行\" TDM可以类比为\"并发\" 波分多路复用WDM 波分多路复用就是\"光的频分多路复用\", 在一根光纤中传输多种不同波长 (频率) 的光信号, 由于波长 ( 频率 )不同, 所以各路光信号互不干扰, 最后再用波长分解复用器将各路波长分解出来 WDM 码分多路复用CDM 码分多址(CDMA)是码分复用的一种方式 ( 注意不要和CSMA搞混了 ) 码分多路复用的过程 : 一个比特分为多个码片(chip), 每一个站点被指定一个唯一的m位的码片序列 当发送比特'1'时发送码片序列, 发送'0'时发送码片序列的反码 如何在同一信道中不相互冲突 : 多个站点同时发送数据时, 要求各个站点的码片序列相互正交 合并过程 : 各路数据在信道中线性相加 分离过程 :合并的数据与源站码片进行规格化内积 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.2 ALOHA协议.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.2 ALOHA协议.html","title":"2.6.2 ALOHA协议","keywords":"","body":"2.6.2 ALOHA协议纯ALOHA协议时隙ALOHA协议2.6.2 ALOHA协议 纯ALOHA协议 思想 : 不监听信道, 不按时间槽发送, 随机重发, 想发就发 冲突检测 : 如果发生冲突, 接收方就会检测出差错, 然后不予确认, 发送方在一定时间内收不到就会判断发生了冲突 冲突解决 : 超时后等待一段随机时间再重传 时隙ALOHA协议 思想 : 把时间分成若干个相同的时间片, 所有用户在时间片开始时刻同步接入网络信道, 若发生冲突, 则必须等到下一个时间片开始时刻再发送 纯ALOHA协议比时隙ALOHA吞吐量更低, 效率也更低 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.3 CSMA协议.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.3 CSMA协议.html","title":"2.6.3 CSMA协议","keywords":"","body":"2.6.3 CSMA协议1-坚持CSMA非坚持CSMAp-坚持CSMA2.6.3 CSMA协议 CSMA : 载波监听多路访问协议 ( carrier sense multiple access) CS : 当几个站同时在发送数据时, 总线上的「电压摆动值」将会增大, 当一个站检测到电压摆动值超过一定的门限值时, 就认为总线上有几个站同时在发送数据, 表明产生了冲突 MA : 多点接入, 表示许多计算机以多点接入的方式连接在一根总线上 协议思想 : 发送帧之前, 监听信道 3种CSMA协议 1-坚持CSMA 思想 : 如果一个主机要发送消息, 那么它先监听信道, 如果信道空闲则直接传输, 不必等待, 如果信道忙则一直监听, 直到空闲马上传输. 如果有冲突, 则等待一个随机长的时间再监听, 重复上述过程 优点 : 信道空闲则可以马上发送数据, 避免了信道利用率的损失 缺点 : 如果有两个或两个以上的站点有数据要发送, 冲突则不可避免 非坚持CSMA 思想 : 如果一个主机要发送消息, 那么它先监听信道, 如果信道空闲则直接传输, 不必等待, 如果信道忙则等待一个随机时间之后再监听 优点 : 采用随机重发延迟时间可以减少冲突发生的可能性 缺点 : 大家可能都在延迟等待的过程中, 使得信道空闲时无数据传输, 信道使用率降低 p-坚持CSMA 思想 : 如果一个主机要发送消息, 那么它先监听信道, 如果信道空闲则以p概率直接传输, 以1-p概率等待到下一个时间槽再传输 1-坚持CSMA就是p=1的p-坚持CSMA 优点 : 综合了1-坚持CSMA和非坚持CSMA的特点 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.4 CSMACD协议.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.4 CSMACD协议.html","title":"2.6.4 CSMACD协议","keywords":"","body":"2.6.4 CSMA/CD协议传播时延对载波监听的影响如何确定碰撞后的重传时机截断二进制指数规避算法最小帧长问题2.6.4 CSMA/CD协议 CSMA/CD : 载波监听多路访问/碰撞检测 ( carrier sense multiple access with collision detection ) CS : 当几个站同时在发送数据时, 总线上的「电压摆动值」将会增大, 当一个站检测到电压摆动值超过一定的门限值时, 就认为总线上有几个站同时在发送数据, 表明产生了冲突 MA : 多点接入, 表示许多计算机以多点接入的方式连接在一根总线上 --- \"总线型网络\" 总线网络 CD : 碰撞检测, 即「边发送边监听」, 适配器边发送数据边检测信道上信号电压的变化情况, 以便判断自己在发送数据时其他站是否也在发送数据 --- \"半双工网络\" 传播时延对载波监听的影响 由于在总线型网络中, 每一台工作站都会收到整个总线的网络流量, 所以碰撞检测的原理就是当自己在发出数据帧后的 (2*传播时延t ) 内收到了来自别的主机的数据帧, 则说明发生了碰撞 如何确定碰撞后的重传时机 截断二进制指数规避算法 截断二进制指数规避算法 流程 最小帧长问题 由于CSMA/CD存在的意义就是在冲突检测到后及时停止帧的发送, 如果存在检测到冲突时帧已发送完毕的情况则CSMA/CD无意义 所以帧的传输时延至少要两倍于信号在总线中的传播时延 即 : 帧长数据传输速率⩾2τ \\frac{\\text{帧长}}{\\text{数据传输速率}}\\geqslant 2\\tau ​数据传输速率​​帧长​​⩾2τ 最小帧长 : 最小帧长=2τ×数据传输速率 \\text{最小帧长}=2\\tau \\times \\text{数据传输速率} 最小帧长=2τ×数据传输速率 ( 以太网规定最短帧长为64B, 小于64B均为无效帧 ) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.5 CSMACA协议.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.5 CSMACA协议.html","title":"2.6.5 CSMACA协议","keywords":"","body":"2.6.5 CSMA/CA协议适用场景工作原理CSMA/CD 和 CSMA/CA的对比2.6.5 CSMA/CA协议 CSMA/CA : 载波监听多路访问/碰撞避免 ( carrier sense multiple access with collision avoidance ) 适用场景 名称 适用场景 CSMA/CD 总线式以太网 CSMA/CA 无线局域网 工作原理 在发送数据前, 先检测信道是否空闲 如果信道空闲则发出RTS ( request to send ), RTS包括发送端的地址 接收端的地址 下一份数据将持续发送的时间 等信息 信道忙则等待 接受收到RTS后, 将响应CTS ( clear to send ). 发送端收到CTS后, 开始发送数据 ( 同时预约信道 : 告诉其他站点自己要传输多久的数据 ) 接收端收到数据帧后, 将用CRC来检验数据是否正确, 如果正确则响应ACK帧 发送端如果收到了ACK帧就进行下一个数据帧的发送, 如果没有就一直重传数据帧 CSMA/CD 和 CSMA/CA的对比 CSMA/CD 和 CSMA/CA的对比 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.6 轮询访问介质访问控制.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.6 介质访问控制/2.6.6 轮询访问介质访问控制.html","title":"2.6.6 轮询访问介质访问控制","keywords":"","body":"2.6.6 轮询访问介质访问控制轮询协议令牌传递协议2.6.6 轮询访问介质访问控制 轮询协议 主结点轮流「邀请」从属结点发送数据 主结点与从属结点 问题 : 轮询开销 等待延迟 单点故障 ( 主结点出故障, 则系统故障 ) 令牌传递协议 令牌 : 一个特殊格式的mac控制帧, 不包含任何信息, 控制信道的使用, 确保同一时刻只有一个结点独占信道 令牌环网 每个结点都可以在一定的时间内 ( 令牌持有时间 ) 获得发送数据的权利, 并不是无限制地持有令牌 问题 : 令牌开销 等待延迟 单点故障 采用令牌传递方式的网络常用于负载较重且通信量较大的网路中 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.1 数据链路层基本概念和功能.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.1 数据链路层基本概念和功能.html","title":"2.1 数据链路层基本概念和功能","keywords":"","body":"2.1 数据链路层基本概念和功能数据链路层的基本概念数据链路层的功能概述2.1 数据链路层基本概念和功能 数据链路层的基本概念 名词 解释 结点 主机, 路由器 链路 网络中两结点间的物理通道 数据链路 网络中两结点间的逻辑通道 帧 链路层的协议数据单元, 封装网络层数据报 数据链路层的功能概述 为网络层提供服务 ( 无确认无连接服务 有确认无连接服务 有确认有连接服务 ) 链路管理 ( 链接的建立, 维持, 释放 ) 组帧 流量控制 差错控制 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.2 封装成帧的几种方法.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.2 封装成帧的几种方法.html","title":"2.2 封装成帧的几种方法","keywords":"","body":"2.2 封装成帧的几种方法一. 字符计数法二. 字符填充法三. 零比特填充法四. 违规编码法2.2 封装成帧的几种方法 组帧的几个方案 : 一. 字符计数法 二. 字符填充法 上述方法法的劣势 : 解决方法 : 三. 零比特填充法 四. 违规编码法 目前普遍使用的方法是比特填充法和违规编码法 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.3 检错编码--CRC 奇偶校验码.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.3 检错编码--CRC 奇偶校验码.html","title":"2.3 检错编码--CRC 奇偶校验码","keywords":"","body":"2.3 检错编码: CRC冗余循环校验码 奇偶校验码差错的种类检错编码循环冗余校验码CRC奇偶校验码2.3 检错编码: CRC冗余循环校验码 奇偶校验码 差错的种类 检错编码 循环冗余校验码CRC 核心公式 : 发送端数据÷生成多项式=X⋯⋯CRC校验码 \\text{发送端数据} \\div \\text{生成多项式} = X \\cdots \\cdots \\text{CRC校验码} 发送端数据÷生成多项式=X⋯⋯CRC校验码 生成多项式 : 生成多项式G(x)=X4+X2+1等价于10101 \\text{生成多项式} G(x) = \\text{X}^4+\\text{X}^2+1 \\text{等价于10101} 生成多项式G(x)=X​4​​+X​2​​+1等价于10101 CRC的工作过程 : CRC的校验 : 把余数加到发送端数据上组成要发送的信息M, 校验时M应当被G(x)严格整除, 如果除不尽, 余数指明出错位所在的位置 CRC 例 例题 : 生成多项式的阶数r = 4 , 在发送的数据后添4个0, 使之成为11010110110000 计算模2除法 ( 异或 ) 取余数为CRC校验码 奇偶校验码 奇校验码 : 在编码的最后一位添1或0使得整个编码中1的出现个数为奇数 偶校验码 : 在编码的最后一位添1或0使得整个编码中1的出现个数为偶数 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.4 纠错编码--海明码.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.4 纠错编码--海明码.html","title":"2.4 纠错编码--海明码","keywords":"","body":"2.4 纠错编码: 海明码海明距离最小海明距离使用海明码的步骤海明不等式----确定校验码的位数r确定校验码的位置求出校验码的值检错与纠错2.4 纠错编码: 海明码 海明码的功能 : 发现双比特错, 纠正单比特错 海明距离 海明距离 最小海明距离 检测k位错 : 海明距离 ≥ k + 1 纠正k位错 : 海明距离 ＞2k + 1 使用海明码的步骤 海明不等式----确定校验码的位数r 2r⩾k+r+1(k为数据位数,r为冗余位数) 2^{\\text{r}}\\geqslant \\text{k}+\\text{r}+1 \\left( \\text{k为数据位数}, \\text{r为冗余位数} \\right) 2​r​​⩾k+r+1(k为数据位数,r为冗余位数) 确定校验码的位置 将第x位校验码填入2的x-1次方的位置, 举例如下 : 求出校验码的值 注意 : 二进制从0001也就是1开始 检错与纠错 方法 : 将各个位按上述规则异或处理后组成一个二进制数, 如果有差错, 则组成的二进制数表示差错所在的数据位. 注意 : 上述规则的海明码只能发现并纠正一位错, 如果要实现发现二位错的功能, 还需要在最后一位加上奇偶校验位. 如下 : Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.7 局域网.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.7 局域网.html","title":"2.7 局域网","keywords":"","body":"2.7 局域网局域网局域网拓扑结构局域网介质访问控制方法局域网的分类IEEE802标准MAC子层和LLC子层以太网以太网标准10BASE-T以太网适配器与mac地址以太网mac帧高速以太网无线局域网IEEE 802.112.7 局域网 局域网 局域网 ( Local Area Network) : 简称LAN, 是指在某一区域内由多台计算机互联组成的计算机组, 使用广播信道 局域网的几个特点 : 覆盖的地理范围较小, 只在一个相对独立的局部范围内联, 如集中的建筑内 使用专门铺设的传输介质 ( 双绞线, 同轴电缆 ) 进行联网, 数据传输速率高 ( 10Mb/s - 10Gb/s ) 通信延迟时间短, 误码率低, 可靠性较高 各站为平等关系, 共享传输信道 多采用分布式控制和广播式通信, 能进行广播和组播 要素 : 网络拓扑 传输介质 介质访问控制方法 局域网拓扑结构 局域网拓扑结构 局域网介质访问控制方法 CSMA/CD -- 总线型局域网 令牌总线 -- 总线型局域网 令牌环 -- 环形局域网 局域网的分类 以太网 --- 应用最为广泛的局域网, 包括标准以太网, 快速以太网, 千兆以太网和10G以太网, 他们都符合IEEE802.3系列标准规范. 逻辑拓扑总线型, 物理拓扑是星型或是拓展星形. 使用CSMA/CD 令牌环网 --- 物理上采用星型拓扑, 逻辑上是环形拓扑, 造价高, (已被淘汰) FDDI网 --- 物理上采用了双环拓扑结构, 逻辑上是环形拓扑结构 ATM网 --- 较新型的单元交换技术, 使用53字节固定长度的单元进行交换 无线局域网 --- WLAN, 采用IEEE802.11标准 IEEE802标准 IEEE802 MAC子层和LLC子层 IEEE802标准所描述的局域网参考模型只对应OSI参考模型的数据链路层与物理层, 它将数据链路层划分为逻辑链路层LLC子层和介质访问控制层MAC子层 MAC子层和LLC子层 以太网 以太网 --- 应用最为广泛的局域网, 包括标准以太网, 快速以太网, 千兆以太网和10G以太网, 他们都符合IEEE802.3系列标准规范. 逻辑拓扑总线型, 物理拓扑是星型或是拓展星形. 使用CSMA/CD 以太网的优势 : 造价低廉 ( 以太网网卡不到100元 ) 是应用最广泛的局域网技术 比令牌环网, ATM网便宜与简单 满足网络速率要求 : 10Mb/s - 10Gb/s 以太网标准 DIX Ethernet V2 : 第一个局域网产品规约 IEEE802.3 : IEEE 802委员会802.3工作组指定的第一个IEEE的以太网标准 10BASE-T以太网 10BASE-T以太网是传送基带信号的双绞线以太网, T表示采用双绞线, 现10BASE-T采用的是无屏蔽双绞线, 传输速率是10Mb/s 物理上星型拓扑, 逻辑上总线型, 每段双绞线最长为100m 采用曼彻斯特编码 采用CSMA/CD介质访问控制 适配器与mac地址 适配器与mac地址 以太网mac帧 最常用的mac帧是以太网v2的格式 以太网v2 mac帧 FCS : CRC校验码 高速以太网 高速以太网 无线局域网 IEEE 802.11 IEEE 802.11 是无线局域网通用的标准, 它是由IEEE所定义的无线网络的通用标准, mac子层采用CSMA/CA 802.11的帧头格式 802.11的帧头格式 发送端和接收端--无线接入点 ( 基站 ) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.8 广域网PPP协议HDLC协议.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.8 广域网PPP协议HDLC协议.html","title":"2.8 广域网PPP协议HDLC协议","keywords":"","body":"2.8 广域网PPP协议和HDLC协议广域网PPP协议ppp协议的三个组成部分HDLC协议HDLC的「站」HDLC的帧格式总结2.8 广域网PPP协议和HDLC协议 广域网 广域网通常跨接很大的物理范围, 所覆盖的范围从几十公里到上千公里, 它能连接多个城市和国家, 或横跨几个洲并能提供远距离通信, 形成国际性的远程网络 广域网的通信子网通常采用「分组交换」技术, 广域网的通信子网可以利用公用分组交换网, 卫星通信网和无线分组交换网, 它将分布在不同地区的局域网或计算机系统互连起来, 达到资源共享的目的, 如因特网是世界范围内最大的广域网 广域网 PPP协议 点对点协议（Point to Point Protocol，PPP）为在点对点连接上传输多协议数据包提供了一个标准方法。 PPP 最初设计是为两个对等节点之间的IP 流量传输提供一种封装协议。 PPP协议的「特点」 : 简单 : 对于链路层的帧, 无需纠错, 无需编号, 无需流量控制 封装成帧 : 帧定界符 透明传输 : 与帧定界符一样的比特组合的数据应该如何处理, 异步线路用字节填充, 同步线路用比特填充 多种网络层协议 多种类型链路 : 同步/异步 串行/并行 差错检测 : 错就丢弃 检测连接状态 最大传送单元MTU 网络层地址协商 : 知道通信双方的网络层地址 数据压缩协商 ppp协议的三个组成部分 一个将ip数据报封装到串行链路的方法 「链路控制协议LCP」: 建立并维护数据连接 ( 身份验证 ) 「网络控制协议NCP」: 为网络层协议建立和配置逻辑连接 PPP协议的帧格式 HDLC协议 高级数据链路控制（HDLC，High-level Data Link Control）是一组用于在网络结点间传送数据的协议，是由国际标准化组织（ISO）颁布的一种高可靠性、高效率的数据链路控制规程，其特点是各项数据和控制信息都以比特为单位，采用“帧”的格式传输 。 HDLC的数据报文可透明传输, 用「零比特插入法」实现透明传输 采用全双工通信 所有帧采用CRC校验, 对信息帧进行顺序编号, 传输可靠性高 HDLC的「站」 主站, 从站和复合站 HDLC的帧格式 HDLC帧 总结 PPP HDLC 通信链路 全双工 全双工 透明传输 字节填充, 比特填充 比特填充 差错检测 检测但不纠正 检测但不纠正 可靠性 不可靠 可靠 编号和确认机制 无编号有确认机制 有编号有确认机制 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.9 链路层设备--网桥交换机.html":{"url":"roccoshi_note/01-计算机网络笔记/2. 数据链路层/2.9 链路层设备--网桥交换机.html","title":"2.9 链路层设备--网桥交换机","keywords":"","body":"2.9 链路层设备--网桥交换机冲突域冲突域和广播域网桥网桥分类交换机---多接口网桥2.9 链路层设备--网桥交换机 冲突域 在以太网中，如果某个CSMA/CD网络上的两台计算机在同时通信时会发生冲突，那么这个CSMA/CD网络就是一个冲突域（collision domain)。 如果以太网中各个网段以集线器连接，因为不能避免冲突，所以它们仍然是一个冲突域。 冲突域就是同一时间链路上只能有一个主机传送信息, 一个集线器下是一个冲突域, 冲突域之前通过主干集线器相连, 组成了一个更大的冲突域 冲突域和广播域 冲突域和广播域的对比 考点 : 冲突域和广播域的数量判断问题 如果一个路由器都没有, 就是一个广播域, 然后看网桥和交换机隔离出来的冲突域, 有几条线连上网桥/交换机就有几个冲突域 e.g. 例题 : 冲突域广播域数量判断 网桥 网桥根据mac帧的目的地址对帧进行转发和过滤, 当网桥收到一个帧时, 它并不向所有接口转发此帧, 而是先检查此帧的目的mac地址, 然后再确定将该帧转发到哪一个接口, 或者是把它丢弃 ( 过滤 ) 网桥 网段 网桥优点 : 过滤通信量, 增大吞吐量 扩大了物理范围 提高了可靠性 可以互联不同物理层, 不同mac子层和不同速率的以太网 网桥分类 1. 透明网桥 「透明」指以太网上的站点并不知道所发送的帧将经过哪几个网桥, 是一种即插即用的设备 通过建立「转发表」---自学习转发数据帧 ( 转发表相当于缓存 ) 网桥在转发数据帧时, 首先查找转发表, 如果转发表不存在对应的记录, 则记录当前地址+接口到转发表, 下次转发时直接从转发表调取记录, 会大大加快速度 转发表会在几分钟内更新, 不是一直不变的, 保证了动态性 透明网桥 转发表 2. 源路由网桥 源路由网桥 : 在发送帧时, 把详细的「最佳路由信息」( 路由最少/时间最短 ) 放在帧的首部 方法 : 源站以广播方式向欲通信的目的站发送一个「发现帧」, 返回的一条最短的路由就是\"最佳路由信息\" ( 类似bfs, dfs ) 交换机---多接口网桥 直通式交换机 : 查完目的地址就立刻转发 延迟小, 可靠性低, 无法支持具有不同速率的端口的交换 存储转发式交换机 : 将帧放入高速缓存, 并检查是否正确, 正确则转发, 错误则丢弃 延迟大, 可靠性高, 可以支持具有不同速率的端口的交换 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/","title":"3. 网络层","keywords":"","body":"网络层网络层的功能网络层 网络层的主要任务是把分组从源端传到目的端, 为分组交换网上的不同主机提供通信服务, 网络层的传输单位是数据报 网络层的功能 路由选择与分组转发 异构网络互连 拥塞控制 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.12 路由算法和路由协议/":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.12 路由算法和路由协议/","title":"3.12 路由算法和路由协议","keywords":"","body":"3.12 路由算法和路由协议路由表路由算法的分类路由协议的分类3.12 路由算法和路由协议 路由表 路由表 路由算法的分类 路由算法分类 路由协议的分类 路由选择协议 不同的自治系统内部协议可以不同, 自治系统之间使用外部网关协议 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.12 路由算法和路由协议/3.12.1 RIP协议和距离向量算法.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.12 路由算法和路由协议/3.12.1 RIP协议和距离向量算法.html","title":"3.12.1 RIP协议和距离向量算法","keywords":"","body":"3.12.1 RIP协议和距离向量算法RIP协议RIP的过程RIP的报文格式RIP中路由表的更新例题RIP的特点---好消息传的快 坏消息传得慢3.12.1 RIP协议和距离向量算法 RIP(Routing Information Protocol,路由信息协议）是一种内部网关协议（IGP），是一种动态路由选择协议，用于自治系统（AS）内的路由信息的传递。 RIP协议基于距离矢量算法（DistanceVectorAlgorithms），使用“跳数”(即metric)来衡量到达目标地址的路由距离。 RIP协议 RIP RIP的过程 仅和相邻路由器交换信息 路由器交换的信息是自己的路由表 每30秒交换一次路由信息, 然后路由器根据新信息更新路由表. 如果超过180s没有收到邻居路由器的通告, 则判定邻居没了, 并更新自己的路由表 经过若干次更新后, 所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址, 即「收敛」 RIP的报文格式 RIP采用UDP RIP中路由表的更新 路由表的更新过程 例题 例题1 例题2 RIP的特点---好消息传的快 坏消息传得慢 当网络出现故障时, RIP需要经过比较长的时间才能将信息传达到所有的路由器 --- \"慢收敛\" 坏消息传得慢 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.12 路由算法和路由协议/3.12.2 OSPF协议和链路状态算法.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.12 路由算法和路由协议/3.12.2 OSPF协议和链路状态算法.html","title":"3.12.2 OSPF协议和链路状态算法","keywords":"","body":"3.12.2 OSPF协议和链路状态算法OSPF的流程OSPF的区域OSPF分组OSPF的特点3.12.2 OSPF协议和链路状态算法 开放式最短路径优先（英语：Open Shortest Path First，缩写为 OSPF）是一种基于IP协议的路由协议。它是大中型网络上使用较为广泛的IGP协议。OSPF是对链路状态路由协议的一种实现，运作于自治系统内部。 OSPF 特点 : 洪泛法---广播 建立全网拓扑图 OSPF的流程 OSPF过程 OSPF的区域 OSPF的区域 OSPF分组 OSPF直接采用IP数据报 OSPF的特点 每隔30min刷新一次数据库的链路状态 当互联网规模很大时, OSPF协议要比距离向量协议好得多 OSPF不存在坏消息传得慢的问题, 它的收敛速度很快 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.12 路由算法和路由协议/3.12.3 BGP协议.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.12 路由算法和路由协议/3.12.3 BGP协议.html","title":"3.12.3 BGP协议","keywords":"","body":"3.12.3 BGP协议BGP的过程BGP报文BGP协议的特点4种BGP-4报文3.12.3 BGP协议 BGP BGP的过程 BGP交换信息的过程 BGP报文 BGP协议采用TCP传送 BGP协议的特点 BGP支持CIDR 在BGP刚运行时, BGP的邻站是交换整个的BGP路由表, 但是之后只需要在发生变化时更新即可. 节省了网络带宽和路由器处理开销 4种BGP-4报文 BGP的4种报文类型 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.12 路由算法和路由协议/3.12.4 三种路由协议的对比.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.12 路由算法和路由协议/3.12.4 三种路由协议的对比.html","title":"3.12.4 三种路由协议的对比","keywords":"","body":"3.12.4 三种路由协议的对比3.12.4 三种路由协议的对比 使用的传输协议 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.01 数据交换方式.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.01 数据交换方式.html","title":"3.01 数据交换方式","keywords":"","body":"3.1 数据交换方式3.1.1 电路交换电路交换的阶段电路交换的优/缺点3.1.2 报文交换3.1.3 分组交换比较总结3.1 数据交换方式 3.1.1 电路交换 电路交换举例: 电话网络 电路交换的阶段 建立连接 ( 电路建立 ) 通信 释放连接 ( 电路拆除 ) 特点 :「独占资源」 电路交换的优/缺点 优点 : 通信时延小 有序传输 没有冲突 实时性强 缺点 : 建立连接时间长 线路独占, 使用效率低 灵活性差 无差错控制能力 ( 没有检错和纠错 ) 3.1.2 报文交换 报文交换 报文 : 源应用发送的「信息整体」 优点 : 无需建立连接 存储转发, 动态分配线路 线路可靠性较高 线路利用率较高 多目标服务 缺点 : 有存储转发时延 报文大小不定, 需要网络节点有较大缓存空间 3.1.3 分组交换 分组交换 分组 : 把大的数据块分割成小的数据块 优点 : 无需建立连接 存储转发, 动态分配线路 线路可靠性较高 线路利用率较高 相对于报文交换, 「存储管理」更容易 缺点 : 有存储转发时延 需要传输额外的信息量 ( 报文需要拆分和重组, 需要附加编号等信息 ) 乱序到目的主机时, 需要对分组排序重组 分组交换和报文交换比起来, 有点像利用了「流水线」的思想, 从而减少了传送数据的时间 比较总结 三种交换方式的比较 报文交换和分组交换都采用存储转发 电路交换传输时间最小, 如果有传送时间远大于呼叫时间且数据量大的情况, 选择电路交换 从信道利用率看, 报文交换和分组交换优于电路交换, 其中分组交换时延更小 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.02 数据报和虚电路.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.02 数据报和虚电路.html","title":"3.02 数据报和虚电路","keywords":"","body":"3.2 数据报和虚电路几种传输单元名词数据报虚电路对比3.2 数据报和虚电路 数据报 虚电路 几种传输单元名词 层次 传输单元 应用层 报文 传输层 报文段 网络层 IP数据报 分组 数据链路层 帧 物理层 比特流 数据报 无连接 每个分组携带源和目的地址 路由器根据分组的目的地址转发分组 : 基于「路由协议」构建「转发表」, 检索转发表, 为每个分组独立选路 虚电路 虚电路是一条源主机到目的主机类似于电路的路径, 路径上所有结点都要维持这条虚电路的建立, 都维持一张虚电路表, 每一项记录了一个打开的虚电路的信息 对比 虚电路&数据报 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.03 IP数据报.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.03 IP数据报.html","title":"3.03 IP数据报","keywords":"","body":"3.3 IP数据报TCP/IP协议栈IP数据报格式最大传送单元MTUIP数据报分片3.3 IP数据报 TCP/IP协议栈 TCP/IP协议栈 IP数据报格式 一个ip数据报 IP数据报格式 名称 解释 版本 IPv4/IPv6 首部长度 单位是4B, 最小为5 区分服务 期望获得哪种类型的服务 总长度 首部+数据, 单位是1B 生存时间(TTL) IP分组的「保质期」每经过一个路由器-1, 变成0则丢弃 协议 数据部分的协议 首部检验和 只检验首部 可选字段 0~40B, 可以用来支持排错, 测量以及安全等措施 填充 全0, 把首部补充成4B的整数倍 标识 同一数据报的分片使用同一标识 标志 三位只有两位有意义 x 中间位DF=1, 禁止分片; DF=0, 允许分片最低位MF=1, 表示之后还有分片; MF=0, 代表为最后一片/没有分片 片偏移 指出较长分组分片后, 某片在原分组中的相对位置, 以8B为单位 注意单位 : 总长度的单位是 1B 片偏移的单位是 8B 首部长度的单位是 4B 记忆大师 : 一种八片的首饰 ( 1总8片の首4 ) 协议 最大传送单元MTU MTU : 链路层数据帧可封装数据的上限 以太网的MTU是1500字节 如果一个IP数据包过长, 则需要对其进行分片 IP数据报分片 IP数据报分片例题 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.04 IP地址.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.04 IP地址.html","title":"3.04 IP地址","keywords":"","body":"3.4 IP地址分类的IP地址特殊的IP地址私有ip地址3.4 IP地址 IP地址 : 全世界唯一的32位/4字节标识符, 标识路由器主机的接口 ip地址的发展 分类的IP地址 分类的ip地址 类型 范围 每个网络最大主机数 A类 (0) 1-126 224−22^{24}-22​24​​−2 Ｂ类 (10) 128-191 216−22^{16}-22​16​​−2 Ｃ类 (110) 192-223 28−22^{8}-22​8​​−2 Ｄ类 (1110) 224-239 Ｅ类 (1111) 240-255 特殊的IP地址 特殊的ip地址 私有ip地址 私有ip地址, 局域网内部使用 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.05 网络地址转换NAT.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.05 网络地址转换NAT.html","title":"3.05 网络地址转换NAT","keywords":"","body":"3.5 网络地址转换NAT3.5 网络地址转换NAT 路由器对目的地址是私有IP地址的数据报一律不进行转发 网络地址转换NAT ( Network Address Translation ) : 在专用网连接到因特网的路由器上安装NAT软件, 安装了NAT软件的路由器叫NAT路由器, 它至少有一个有效的外部全球IP地址 NAT通过NAT转换表进行地址转换 NAT转换表 本质就是LAN和WAN的互相映射 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.06 子网.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.06 子网.html","title":"3.06 子网","keywords":"","body":"3.6 子网子网掩码使用子网时的分组转发3.6 子网 子网划分 子网划分就是在两级IP地址( 网络号 + 主机号 ) 的基础上在某个网络内部再将主机号的字段分为 ( 子网号 + 主机号 ), 从而实现对主机的进一步划分 子网 子网掩码 就是将网络号+子网号的各个位全部设置为1组成的一串比特串, 用于提取IP地址中的网络号 ( 相与 ) 子网掩码 使用子网时的分组转发 使用子网时的分组转发 检测路由表中有无路径 --- 目的地址与路由表中的每一行子网掩码依次相与, 判断目的网络是否存在下一跳地址 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.07 无分类编址CIDR.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.07 无分类编址CIDR.html","title":"3.07 无分类编址CIDR","keywords":"","body":"3.7 无分类编制CIDRCIDR的特点构成超网最长前缀匹配3.7 无分类编制CIDR CIDR的特点 消除了传统的A类, B类和C类地址以及划分子网的概念, 采用「网络前缀」代替 CIDR和网络前缀 融合子网地址与子网掩码, 方便子网划分, CIDR把网络前缀都相同的连续IP地址组成一个「CIDR地址块」 CIDR地址块 构成超网 将多个子网聚合成一个大子网, 叫做构成超网, 或者路由聚合 构成超网的方式 ：缩短网络前缀即可 最长前缀匹配 在采用CIDR时, 查找路由表有可能会得到几个匹配结果, 这时候应该选择具有最长网络前缀的路由, 前缀越长表示地址块越小, 也就是路由越具体 例题 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.08 ARP协议.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.08 ARP协议.html","title":"3.08 ARP协议","keywords":"","body":"3.8 ARP协议3.8 ARP协议 地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。 核心 : 完成IP地址到mac地址的映射 arp协议的使用过程 例题 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.09 DHCP协议.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.09 DHCP协议.html","title":"3.09 DHCP协议","keywords":"","body":"3.9 DHCP协议3.9 DHCP协议 DHCP（动态主机配置协议 Dynamic Host Configuration Protocol）是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。 特点 : 应用层协议 基于UDP 工作过程 : 主机广播DHCP发现报文 --- 发现网络中的DHCP服务器 DHCP服务器广播DHCP提供报文 --- 服务器拟分配给主机一个IP地址 主机广播DHCP请求报文 --- 主机向服务器请求提供IP地址 DHCP服务器广播DHCP确认报文 --- 正式将IP地址分配给主机 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.10 ICMP协议.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.10 ICMP协议.html","title":"3.10 ICMP协议","keywords":"","body":"3.10 ICMP协议ICMP差错报告报文不发送ICMP差错报告报文的情况ICMP询问报文ICMP的应用3.10 ICMP协议 ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。 ICMP报文 ICMP差错报告报文 终点不可达 源点抑制 时间超过 ( TTL=0 / 终点在规定时间内没收到所有的数据报片 ) 参数问题 ( 首部字段有问题 ) 改变路由 ( 重定向 ) 不发送ICMP差错报告报文的情况 对ICMP差错报告报文不再发送ICMP差错报告报文 对一个分片数据报的后续数据报片不发送ICMP差错报告报文 对具有组播地址的数据报都不发送ICMP差错报告报文 对具有特殊地址 ( 127.0.0.0, 0.0.0.0等) 的数据报不发送ICMP差错报告报文 ICMP询问报文 ICMP询问报文 应用 : ping ICMP的应用 应用 : ping, traceroute Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.11 IPv6.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.11 IPv6.html","title":"3.11 IPv6","keywords":"","body":"3.11 IPv6数据报格式与Ipv4的对比地址表示形式 ( 一般形式, 压缩形式 )3.11 IPv6 数据报格式 IPv6数据报格式 与Ipv4的对比 地址表示形式 ( 一般形式, 压缩形式 ) 地址表示形式 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.13 IP组播.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.13 IP组播.html","title":"3.13 IP组播","keywords":"","body":"3.13 IP组播单播, 广播和组播IP组播地址硬件组播IGMP协议和组播路由选择协议IGMP工作的两个阶段组播路由选择协议3.13 IP组播 单播, 广播和组播 单播 广播 组播 单播 组播(多播) IP组播地址 IP组播地址让原设备能够将分组发送给一组设备. 属于多播组的设备将被分配一个组播组IP地址 组播地址的范围是224.0.0.0 - 239.255.255.255 ( D类 ), 一个D类地址表示一个组播组. 只能用作分组的目标地址, 源地址总是为单播地址 组播数据报 \" 尽最大努力交付 \" , 应用于UDP 对组播数据报不会产生ICMP差错报文 并非所有的D类地址都可以作为组播地址 硬件组播 硬件组播 IGMP协议和组播路由选择协议 IGMP(Internet Group Management Protocol)互联网组管理协议是TCP/IP 协议族中负责IP组播成员管理的协议，用来在IP主机和与其直接相邻的组播路由器之间建立、维护组播组成员关系。 IGMP协议让路由器知道本局域网上是否有主机 ( 的进程 )参加或退出了某个组播组 IGMP协议 IGMP和ICMP都使用IP数据报传递报文 IGMP工作的两个阶段 IGMP工作的两个阶段 组播路由选择协议 组播路由选择协议的目的是找出以源主机为根节点的组播转发树 构造树可以避免在路由器之间兜圈子 对不同的多播组对应于不同的多播转发树, 同一个多播组, 对不同的源点也会有不同的多播转发树 组播路由选择协议常使用的三种算法: 基于链路状态的路由选择 基于距离-向量的路由选择 协议无关的组播 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/3. 网络层/3.14 网络层设备.html":{"url":"roccoshi_note/01-计算机网络笔记/3. 网络层/3.14 网络层设备.html","title":"3.14 网络层设备","keywords":"","body":"3.14 网络层设备1. 路由器3.14 网络层设备 1. 路由器 三个设备的区别 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/4. 传输层/":{"url":"roccoshi_note/01-计算机网络笔记/4. 传输层/","title":"4. 传输层","keywords":"","body":"4. 传输层传输层的功能传输层的两种协议端口套接字4. 传输层 传输层的功能 传输层提供进程与进程之间的逻辑通信 复用与分用 传输层对收到的报文进行差错检测 传输层的两种协议 UDP , TCP 端口 端口用于标识主机中的应用进程, 长度为16bit, 可以表示65536个不同的端口号, 端口号只有本地意义, 因特网不同计算机的相同端口之间没有联系 端口号的分类 : 熟知端口号 : 0-1023, 给一些重要的应用程序使用, 让所有用户都知道 登记端口号 : 1024-49151 客户端使用 : 29152-65535 ( 动态选择 ) 套接字 在网络中采用发送方和接收方的套接字组合来识别端点, 套接字唯一标识了网络中的一个主机和它上面的一个进程. socket = ( 主机IP地址, 端口号 ) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/":{"url":"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/","title":"4.2 TCP协议","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/4.2.1 TCP特点和报文段格式.html":{"url":"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/4.2.1 TCP特点和报文段格式.html","title":"4.2.1 TCP特点和报文段格式","keywords":"","body":"4.2.1 TCP特点和报文段格式1. TCP协议的特点2. TCP的报文段首部格式4.2.1 TCP特点和报文段格式 1. TCP协议的特点 面向连接 点对点 可靠交付 全双工 面向字节流 2. TCP的报文段首部格式 TCP报文段首部 解释 : 序号 : 在一个TCP连接中传送的字节流中的每一个字节都按顺序编号, 本字段表示本报文段所发送数据的第一个字节的序号 确认号 : 期望收到对望下一个报文段的第一个数据字节的序号, 若确认号为N, 则证明到序号N-1为止的所有数据都已经正确收到 数据偏移 ( 首部长度 ) : TCP报文段的数据起始处距离TCP报文段的起始处有多远, 以4B位为单位, 即一个数值是4B 六个控制位 : 紧急位URG : URG = 1时, 标明此报文段中有紧急数据, 是高优先级的数据, 应尽快传送, 不用在缓存里排队, 配合紧急指针字段使用 确认位ACK : ACK = 1时确认号有效, 在连接建立后所有传送的报文段都必须把ACK置为1 推送位PSH : PSH = 1时, 接收方尽快交付接受应用进程, 不用等到缓存填满再向上交付 复位RST : RST = 1时, 表明TCP连接中出现严重差错, 必须释放连接, 然后再重新建立传输连接 同步位SYN : SYN = 1时, 表明是一个连接请求 / 连接接受报文 终止位FIN : FIN = 1时, 表明此报文段发送方数据已发完, 要求释放连接 窗口 : 指的是发送本报文段的一方的接收窗口, 即现在允许对方发送的数据量 校验和 : 检验首部 + 数据, 检验时要加上12B伪首部, 第四个字段为6 紧急指针 : URG = 1时才有意义, 指出本报文段中紧急数据的字节数 选项 : ... 填充 : 使得首部为4B的整数倍 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/4.2.2 TCP连接管理.html":{"url":"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/4.2.2 TCP连接管理.html","title":"4.2.2 TCP连接管理","keywords":"","body":"4.2.2 TCP连接管理TCP连接的建立---三次握手SYN洪泛攻击TCP连接的释放---四次挥手4.2.2 TCP连接管理 TCP连接的建立---三次握手 三次握手过程 SYN洪泛攻击 攻击者发送SYN，也就是TCP三次握手的第一次握手的数据包，当服务器返回ACK后，该攻击者不再对其进行确认，那么这个TCP连接将处于挂起状态，也就是半连接状态，服务器收不到再确认的话将重复发送ACK给攻击者，这样更加浪费服务器的资源，攻击者就对服务器发送非常大量的TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务。 TCP连接的释放---四次挥手 四次挥手过程 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/4.2.3 TCP可靠传输.html":{"url":"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/4.2.3 TCP可靠传输.html","title":"4.2.3 TCP可靠传输","keywords":"","body":"4.2.3 TCP可靠传输4.2.3 TCP可靠传输 可靠传输 : 保证接收方进程从缓冲区读出的字节流和发送方发出的字节流是完全一样的 TCP实现可靠传输的机制 : 校验 : 与udp校验一样, 增加伪首部 序号 确认 重传 协议见链路层 --- 停等, GBN, SR协议 快速重传 : 快速重传 冗余ACK Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/4.2.4 TCP流量控制.html":{"url":"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/4.2.4 TCP流量控制.html","title":"4.2.4 TCP流量控制","keywords":"","body":"4.2.4 TCP流量控制4.2.4 TCP流量控制 流量控制就是让发送方控制发送的速度, 使接收方有时间接收数据 TCP利用滑动窗口机制实现流量控制 发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值 流量控制滑动窗口的过程 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/4.2.5 TCP拥塞控制.html":{"url":"roccoshi_note/01-计算机网络笔记/4. 传输层/4.2 TCP协议/4.2.5 TCP拥塞控制.html","title":"4.2.5 TCP拥塞控制","keywords":"","body":"4.2.5 TCP拥塞控制拥塞控制的四种算法慢开始和拥塞避免快重传和快恢复4.2.5 TCP拥塞控制 拥塞控制的四种算法 慢开始 拥塞避免 快重传 快恢复 慢开始和拥塞避免 慢开始和拥塞避免 快重传和快恢复 快重传和快恢复 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/4. 传输层/4.1 UDP协议.html":{"url":"roccoshi_note/01-计算机网络笔记/4. 传输层/4.1 UDP协议.html","title":"4.1 UDP协议","keywords":"","body":"4.1 UDP协议1. UDP协议的主要特点2. UDP的首部格式3. UDP的校验4.1 UDP协议 UDP只在IP数据报的服务之上增加了很少的功能, 即复用分用和差错检测功能 1. UDP协议的主要特点 UDP是无连接的, 减少开销和发送数据之前的时延 UDP使用「最大努力交付」, 不保证可靠交付 UDP是「面向报文」的, 适合一次性传输少量数据的网络应用 UDP无拥塞控制, 适合很多「实时应用」 UDP首部开销小, 为8B ( TCP首部20B ) 2. UDP的首部格式 UDP的首部格式 3. UDP的校验 udp的校验 伪首部 : 伪首部只在计算校验和时才出现, 既不向下传送也不向上提交 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/5. 应用层/":{"url":"roccoshi_note/01-计算机网络笔记/5. 应用层/","title":"5. 应用层","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/5. 应用层/5.1 网络应用模型.html":{"url":"roccoshi_note/01-计算机网络笔记/5. 应用层/5.1 网络应用模型.html","title":"5.1 网络应用模型","keywords":"","body":"5.1 网络应用模型1. 客户/服务器模型2. p2p模型 ( peer to peer )5.1 网络应用模型 1. 客户/服务器模型 客户-服务器模型 2. p2p模型 ( peer to peer ) p2p模型 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/5. 应用层/5.2 DNS系统.html":{"url":"roccoshi_note/01-计算机网络笔记/5. 应用层/5.2 DNS系统.html","title":"5.2 DNS系统","keywords":"","body":"5.2 DNS系统5.2 DNS系统 域名 域名解析过程 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/5. 应用层/5.3 FTP.html":{"url":"roccoshi_note/01-计算机网络笔记/5. 应用层/5.3 FTP.html","title":"5.3 FTP","keywords":"","body":"5.3 FTP5.3 FTP FTP Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/5. 应用层/5.4 电子邮件.html":{"url":"roccoshi_note/01-计算机网络笔记/5. 应用层/5.4 电子邮件.html","title":"5.4 电子邮件","keywords":"","body":"5.4 电子邮件5.4 电子邮件 电子邮件 发送 : SMTP 接收 : POP3 ; IMAP 通用因特网邮件扩充 : MIME ( 提供了一种可以在邮件中附加多种不同编码文件的方法) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/5. 应用层/5.5 HTTP.html":{"url":"roccoshi_note/01-计算机网络笔记/5. 应用层/5.5 HTTP.html","title":"5.5 HTTP","keywords":"","body":"5.5 HTTP5.5 HTTP 超文本传输协议HTTP HTTP报文结构 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/01-计算机网络笔记/6. 考纲.html":{"url":"roccoshi_note/01-计算机网络笔记/6. 考纲.html","title":"6. 考纲","keywords":"","body":"计网计网 题型 : 选择题 应用题 60% 期末 25% 实验 15% 作业 2/5 - 同轴电缆 T - 双绞线 F - 光纤 信道利用率的计算分析 ( 信贷滑窗协议是啥 ?? ) 24章不做要求 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/":{"url":"roccoshi_note/02-计算机组成原理/","title":"02-计算机组成原理","keywords":"","body":"复习要点和考纲复习要点和考纲 1 2章 3 4章 5-9章 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/2. 数据表示--编码/":{"url":"roccoshi_note/02-计算机组成原理/2. 数据表示--编码/","title":"2. 数据表示--编码","keywords":"","body":"2. 数据表示--编码2. 数据表示--编码 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/2. 数据表示--编码/2.1 原码 补码 反码.html":{"url":"roccoshi_note/02-计算机组成原理/2. 数据表示--编码/2.1 原码 补码 反码.html","title":"2.1 原码 补码 反码","keywords":"","body":"2.1 原码, 补码, 反码2.1.1 原码原码的优缺点2.1.2 补码 变形补码无模运算和有模运算补码的定义补码的表示补码的性质变形补码2.1.3 反码2.1 原码, 补码, 反码 2.1.1 原码 表示方法 : 符号 + 数值, 即一位符号位 + 绝对值真值 原码的定义 例如 : 35 = (100011)2{(100011)}_2(100011)​2​​ 如果用8位原码表示 +35 = (00100011)2{(00100011)}_2(00100011)​2​​ -35 = (10100011)2{(10100011)}_2(10100011)​2​​ +0.8125 = (0.1101000)2{(0.1101000)}_2(0.1101000)​2​​ -0.8125 = 1 - ( - 0.8125 ) = (1.0000000)2{(1.0000000)}_2(1.0000000)​2​​ + (0.1101000)2{(0.1101000)}_2(0.1101000)​2​​= (1.1101000)2{(1.1101000)}_2(1.1101000)​2​​ 原码的优缺点 优点 : 简单, 直观, 转换容易 实现乘除法规则简单 缺点 : 实现加减法规则复杂 2.1.2 补码 变形补码 无模运算和有模运算 无模运算 : 实数范围内的运算 有模运算 : 一定数值范围内的运算, 类似「时钟」 有模运算 「补码」就是利用了「有模运算」的原理 补码的定义 补码的定义 补码的表示 符号位 : 1为负, 0为正 0的表示 = 0, 是唯一的 ( 原码不是唯一的 ) 补码的表示范围 补码的表示范围 补码转换成原码 : 符号位为0 : 原码=补码 符号位为1 : 符号位不变, 数值位按位取反末位加一 原码转换成补码 : 符号位为0, 补码=原码 符号位为1, 补码=原码符号位不变, 数值位按位取反末位加一 补码的性质 将n位纯小数的补码变成2n位, 在末尾添加n个0 将整数补码扩大2n2^n2​n​​倍, 只需将X的符号位向左复制n位即可 符号位扩展 算数右移 : 符号位不变, 按位右移 算术左移 : 按位左移, 末尾补0 变形补码 变形补码采用双符号位, 左边是真正符号位, 右边用于判断是否溢出 : 两个符号位相同, 则不发生溢出 两个符号位相异, 则发生溢出 ( 此时最高位为符号; 次高位为溢出的数值而不是符号 ) 2.1.3 反码 反码与原码和真值之间的转换 : 反码与原码和真值之间的转换 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/2. 数据表示--编码/2.2 移码 浮点数 IEEE754.html":{"url":"roccoshi_note/02-计算机组成原理/2. 数据表示--编码/2.2 移码 浮点数 IEEE754.html","title":"2.2 移码 浮点数 IEEE754","keywords":"","body":"2.2 移码 浮点数 IEEE754移码浮点数的表示方法规格化的浮点数浮点数的精度问题浮点数的溢出浮点数的表示范围例题IEEE754标准规定单精度IEEE754 ( 32位 )2.2 移码 浮点数 IEEE754 移码 计算机常用移码来表示浮点数的阶码 0的移码 : 1000....0 ( n-1个0 ) 移码的表示范围 : −2n−1=X2n−1-2^{n-1} −2​n−1​​=X2​n−1​​ 移码与补码的关系 : 移码和补码关系为符号位取反 例题 浮点数的表示方法 浮点数的表示方法 规格化的浮点数 定义 : 如果阶码的底为2, 则规格化的尾数应满足条件1/2=∣M∣11/2 1/2=∣M∣1 当尾数用「补码」表示时, 若位尾数大于等于0, 则尾数格式应为 : M=0.1xxxxx , 即 若位尾数小于0, 则尾数格式应为 : M=1.0xxxxx , 即 ------「异或逻辑」 左规和右规 左规 : 若采用变形补码表示尾数, 则当结果的尾数出现11.1xxxx或者00.0xxxx形式时, 需要将尾数左移1位, 阶码减一, 知道尾数为规格化形式为止 右规 : 当浮点运算的结果出现01.xxxx或者10.xxxx时, 并不一定溢出, 应该先将尾数右移1位, 阶码 + 1, 然后判断阶码是否溢出 浮点数的精度问题 由于尾数长度固定, 所以当阶码不断增大的时候, 精度会变小 阶码数轴的分布 浮点数的溢出 溢出的原因 : 指数部分太大, 无法用有限的指数字段表示 下溢 : 阶码小于机器能表示的最小阶码, 一般当作机器0处理, 机器继续运行 上溢 : 阶码大于机器能表示的最大阶码, 机器必须转入溢出故障的中断处理程序进行相应的处理 解决溢出的办法 : 使用双精度格式 单精度和双精度 浮点数的表示范围 浮点数的表示范围 例题 注意将指数转化成阶码得方式 : 十进制--二进制--补码--阶码 例题1 例题2 注意尾数位数有一位在数符上, 所以真正的尾数位数应当-1 IEEE754标准 IEEE754标准是关于浮点数的一种表示标准 规定 尾数用原码表示, 小数点前隐含一个1 基值隐含为2 阶码用移码表示, n位移码的偏移值为2n−1−12^{n-1}-12​n−1​​−1 ( 比如8位阶码, 0 = (01111111)2(01111111)_2(01111111)​2​​ = 27−1=1272^7-1=1272​7​​−1=127) 指数 ( 阶码 )的最大值, 最小值作为特殊标记预留, 用来标记异常事件和机器零 分类 : 单精度, 双精度, 单精度扩展, 双精度扩展 单精度IEEE754 ( 32位 ) 组成 : S符号位 (1b) + E阶码 ( 8b ) + f尾数 (23b) 注意尾数小数点前隐含的0 单精度 例题1 二进制->十进制 单精度 例题2 十进制->二进制 关于十进制小数转二进制小数的问题 : 采用乘2取整，顺序排列的方法 做法 : 用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止 比如上面一题的0.78125 -> 0.11001 : 十进制0.78125 -> 二进制0.11001 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/2. 数据表示--编码/2.3 检错和纠错码.html":{"url":"roccoshi_note/02-计算机组成原理/2. 数据表示--编码/2.3 检错和纠错码.html","title":"2.3 检错和纠错码","keywords":"","body":"2.3 检错和纠错码奇偶校验码循环冗余校验码CRC海明码2.3 检错和纠错码 奇偶校验码 循环冗余校验码CRC 海明码 奇偶校验码 奇校验 : 加上校验位保证比特串具有奇数个1 偶校验 : 加上校验位保证比特串具有偶数个1 奇偶校验 例题 循环冗余校验码CRC 与计网相同 略 海明码 与计网相同 略 海明码及其用途 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/":{"url":"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/","title":"3. 运算方法与运算器","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.1 定点数运算/":{"url":"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.1 定点数运算/","title":"3.1 定点数运算","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.1 定点数运算/3.1.1 加减运算.html":{"url":"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.1 定点数运算/3.1.1 加减运算.html","title":"3.1.1 加减运算","keywords":"","body":"3.1.1 加减运算补码加减法1. 规则 :2. 溢出判断加法器和全加器1.一位全加器2. 行波进位加法器3. 先行进位加法器3.1.1 加减运算 补码加减法 1. 规则 : 参加运算的操作数用补码表示 补码的符号位和数值位同时进行加运算 加 : 两数补码直接相加 减 : 减数补码连同符号位一起取反, 末位+1, 再与被减数的补码相加 运算结果即为和/差的补码 2. 溢出判断 当两个同符号的数相加, 运算结果可能发生溢出 判断溢出的办法 : 双符号位判决法 进位判决法 根据运算结果的符号位和进位标志判别 根据运算前后的符号位进行判别 2.1 双符号位判决法 双符号位判决法 2.2 进位判决法 进位判决法 加法器和全加器 1.一位全加器 一位全加器 2. 行波进位加法器 行波进位加法器 特点 : 结构较简单, 且可以很方便的扩展 运算速度慢 3. 先行进位加法器 行波进位加法器的主要问题是进位信号的传递太慢 先行进位加法器通过逻辑表达式的推导, 将进位表达式都转换成最底层的输入相关, 通过加大逻辑电路的复杂度减少时间消耗 逻辑表达式推导 先行进位加法器 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.1 定点数运算/3.1.2 乘法运算.html":{"url":"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.1 定点数运算/3.1.2 乘法运算.html","title":"3.1.2 乘法运算","keywords":"","body":"3.1.2 乘法运算1. 原码一位乘法2. 补码一位乘法 (Booth法) (必考)运算规律过程3.1.2 乘法运算 1. 原码一位乘法 原码一位乘的运算过程 总结 : 先计算符号位 第一行左边写全0 ( D部分 ), 右边写乘数 ( A部分 ), 被乘数写在全0的下面 ( D左边的一位是进位部分 ) 判断乘数的最后一位, 如果是0, D部分不加向下移, 如果是1, D部分加上被乘数 右移一位 重复上述步骤直到A部分全部移走 将得到的值和符号位拼接得到最后结果 2. 补码一位乘法 (Booth法) (必考) 运算规律 booth法运算规律 过程 booth法过程 booth法步骤 : 写出[X]补 [-X]补 [Y]补 A部分写上Y补, 带1位符号位, 且A−1A_{-1}A​−1​​部分填上一个0 D部分和符号位全0 按上表规则判断A的最后一位与A−1A_{-1}A​−1​​的关系, 并执行相应算法, 不断右移 到符号位移至A的最后一位时退出, 记得最后还要执行一次加/减 前2n位即为所求 : [X×Y]补 [{X \\times Y}]_\\text{补} [X×Y]​补​​ Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.1 定点数运算/3.1.3 除法运算.html":{"url":"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.1 定点数运算/3.1.3 除法运算.html","title":"3.1.3 除法运算","keywords":"","body":"3.1.3 除法运算原码加减交替法「例」3.1.3 除法运算 原码加减交替法 加减交替法的运算法则 : 若余数R≥0, 则商上1, 余数左移一次, 减除数 若余数R＜0, 则商上0, 余数左移一次, 加除数 「例」 X=−0.10001011 \\text{X}=-0.10001011 X=−0.10001011 Y=0.1110 \\text{Y}=0.1110 Y=0.1110 利用原码加减交替法求商及余数 : 1 过程 结果--(注意余数要乘2的-4次方) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.2 浮点数运算/":{"url":"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.2 浮点数运算/","title":"3.2 浮点数运算","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.2 浮点数运算/3.1.1 浮点数加减法.html":{"url":"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.2 浮点数运算/3.1.1 浮点数加减法.html","title":"3.1.1 浮点数加减法","keywords":"","body":"3.1.1 浮点数加减法步骤总结 :「例」解题步骤3.1.1 浮点数加减法 浮点数运算法则 步骤总结 : 对阶 小阶对大阶 : 小阶码+1, 尾数右移1位, 直到增大到与大阶码相同 尾数加减运算 加法直接加, 减法减数符号取反 ( 求补 )再与被减数相加 规格化 左规 11.1xxxx或者00.0xxxx时需要左规 尾数每左移一位, 阶码减一, 直到使尾数成为规格化数为止 阶码减1的同时判断是否发生下溢, 如果发生下溢, 可以认为结果为0 右规 若结果发生溢出, 即10.xxxx或01.xxxx时需要右规 尾数右移一位, 阶码加一, 右规最多有一次 阶码加一的同时判断是否发生上溢, 如果发生上溢, 可以认为结果是∞ 舍入处理 对阶, 规格化时, 在右移操作后需要进行舍入处理 截断法 --- 丢弃尾数低位 末位置1法 --- 使要保留的尾数的最低位永远为1 0舍1入法 --- 当尾数右移丢弃的是1时, 要保留的尾数最末位加1, 当尾数右移丢弃的是0时, 要保留的尾数最末位不变 「例」 例题 解题步骤 对阶 对阶 尾数求和/差 规格化 舍入处理 注意阶码的加减直接采用补码相加的方式比较简便 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.2 浮点数运算/3.1.2 浮点数乘除法.html":{"url":"roccoshi_note/02-计算机组成原理/3. 运算方法与运算器/3.2 浮点数运算/3.1.2 浮点数乘除法.html","title":"3.1.2 浮点数乘除法","keywords":"","body":"3.1.2 浮点数乘除法关于左规和右规的次数原码表示补码表示3.1.2 浮点数乘除法 考点好像没有...懒得看了 关于左规和右规的次数 原码表示 关于左规和右规的次数 解答 : 浮点数求和/差, 右规次数最多一次, 左规次数无法确定, 最多不会超过n-1次 浮点数相乘, 14⩽∣积的尾数∣⩽1\\frac{1}{4}\\leqslant |\\text{积的尾数}|\\leqslant 1​4​​1​​⩽∣积的尾数∣⩽1, 不需右规, 若需左规, 只需要一次 浮点数相除, 12∣商的尾数∣2\\frac{1}{2}​2​​1​​∣商的尾数∣2, 不需左规, 若需右规, 只需要一次 补码表示 当尾数用补码表示时, 乘除法均为 左规右规最多一次 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/4. 存储系统/":{"url":"roccoshi_note/02-计算机组成原理/4. 存储系统/","title":"4. 存储系统","keywords":"","body":"4. 存储系统存储系统的层次结构4. 存储系统 存储系统的层次结构 存储系统的层次结构 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/4. 存储系统/4.1 存储系统概述.html":{"url":"roccoshi_note/02-计算机组成原理/4. 存储系统/4.1 存储系统概述.html","title":"4.1 存储系统概述","keywords":"","body":"4.1 主存储器容量计算字扩展和位扩展4.1 主存储器 容量计算 例题1 字扩展和位扩展 字扩展 : 扩展存储单元的个数 比如原来有一个8k x 8bit的存储器, 用4片, 构成一个32k x 8bit的存储器, 这就是字扩展, 每个存储单元的大小没有变化, 只是存储单元的个数变多了 位扩展 : 扩展存储单元的大小 比如原来有一个8k x 8bit的存储器, 用4片, 构成一个8k x 32bit的存储器, 这就是位扩展, 存储单元的个数没有变化, 只是存储单元的大小变大了 「例题」 按字节编址, 说明4000H--5FFFH一共2132^{13}2​13​​个地址, 每个地址是8bit的空间 ( 一个字节 ), 则RAM区还剩余64-8 = 56KB的空间, 需要56/4 = 14个8K x 4位的SRAM芯片 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/4. 存储系统/4.2 Cache全相联组相联.html":{"url":"roccoshi_note/02-计算机组成原理/4. 存储系统/4.2 Cache全相联组相联.html","title":"4.2 Cache全相联组相联","keywords":"","body":"4.2 Cache 全相联 组相联 (重点必考)1. Cache的作用和工作原理2. Cache的地址映射和地址变换2.1 全相联2.2 直接映射2.3 组相联3. 例题4.2 Cache 全相联 组相联 (重点必考) 1. Cache的作用和工作原理 局部性原理 : 时间的局部性 : 内存某个单元的内容可能会在一段时间内反复使用 ( 循环变量 ) 空间的局部性 : 一个数组类的空间这次访问一个元素, 下一次可能会访问到下一个元素 ( 遍历数组 ) Cache : Cache 2. Cache的地址映射和地址变换 2.1 全相联 随便存 : 主存的任意一块可以映射到Cache中的任意一块 特点 : 优点 : 块冲突概率低, Cache空间利用率高 缺点 : 相联目录表容量大 -- 成本高, 查找速度慢 全相联 2.2 直接映射 规则 : 主存的每一块只能映射到Cache的一个特定的块中 整个Cache地址与主存地址的低位部分完全相同 优点 : 硬件简单, 不需要相联存储器, 只要 容量较小的按地址访问的区号标志表存储器 少量外比较电路 访问速度快 ( 无需地址变换 ) 缺点 : Cache块冲突概率高 Cache空间利用率很低 直接映射 2.3 组相联 将主存分区再分组,组间直接映射, 组内全相联 优点 : 块的冲突概率较低 块的利用率大幅度提高 块的失效率明显降低 缺点 : 实现难度和造价比直接映射的方式高 组相联 3. 例题 例题1 例题2 例题二中注意 : 组号和Cache组内块号可能不会给出, 因为就是目录表的序号 例题3 Cache中需要存储的其他信息 : 有效位 修改位 计数器 ( 替换策略 ) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/4. 存储系统/4.3 Cache替换算法 性能计算.html":{"url":"roccoshi_note/02-计算机组成原理/4. 存储系统/4.3 Cache替换算法 性能计算.html","title":"4.3 Cache替换算法 性能计算","keywords":"","body":"4.3 Cache替换算法 性能计算1. 几种Cache替换算法2. Cache一致性问题3. Cache性能分析加速比4.3 Cache替换算法 性能计算 1. 几种Cache替换算法 随机替换算法 RAND 先进先出替换算法 FIFO 最不经常使用替换算法 LFU 近期最少使用 ( 最久未用 )替换算法 LRU 最佳替换算法 OPT 2. Cache一致性问题 当从Cache读取并修改了数据后要想办法更新主存 写回法 全写法 两种写回方法 3. Cache性能分析 加速比 Cache-主存系统的平均访问周期 Cache-主存系统的加速比 : Sp = TM / TA ( 主存访问周期 / Cache-主存系统的平均访问周期 ) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/4. 存储系统/4.4 虚拟存储器.html":{"url":"roccoshi_note/02-计算机组成原理/4. 存储系统/4.4 虚拟存储器.html","title":"4.4 虚拟存储器","keywords":"","body":"4.4 虚拟存储器1. 段式虚拟存储器2. 页式虚拟存储器3. 段页式虚拟存储器虚拟存储器地址变换带来的速度问题例题4.4 虚拟存储器 虚拟存储器的组成 : 主存储器 + 联机工作的外部存储器 + 辅助硬件 + 系统软件 三种虚拟存储器 : 段式虚拟存储器 页式虚拟存储器 段页式虚拟存储器 1. 段式虚拟存储器 管理方式 : 将程序按逻辑意义分成段, 按段进行调入, 调出和管理 地址映像方法 : 每个程序段都从0地址开始编址, 长度可长可短, 可以在程序执行过程中动态改变程序段的长度 段式存储器的地址映像方法 地址变换方式 : 段式存储器的地址变换方式 段式存储器的特点 : 优点 : 程序的模块化性能好 便于共享主存中的某些段 程序的动态链接和调度容易 便于按逻辑意义实现存储器的访问方式保护 缺点 : 地址变换所花费的时间长 ( 两次加法 ) 段映像表大, 地址, 段长字段太长 主存储器的利用率往往比较低, 存在段间零头 ( 外部碎片 ) 对辅存的管理比较困难 2. 页式虚拟存储器 管理方式 : 将主存空间和程序空间都机械地分成相同大小的页面, 按照页顺序编号, 让程序的起点必须处在主存中某一个页面位置的起点上 任一主存单元的地址由页号和页内偏移两个字段组成 地址映像方法 : 页式存储的地址映像方法 地址变换方式 : 地址变换方式 页式存储器的特点 : 优点 : 主存储器的利用率比较高 页表相对简单, 使用硬件少 地址变换速度比较快 对磁盘管理较简单 缺点 : 程序的模块化性能不好 页表很长, 需要占用很大的存储空间 --- 采用多级页表的方式解决 3. 段页式虚拟存储器 管理方式 : 将程序按逻辑意义先分成段, 再让各段和实主存都机械等分成相同大小的页面, 每道程序通过一个段表和相应的一组页表来进行程序在主存空间中的定位 地址映像方法 : 每个程序段在段表中占一行, 在段表中给出页表长度和页表的起始地址, 页表中给出每一页在主存储器中的实页号 段页式存储器的地址映像 地址变换方法 : 先查段表, 得到页表起始地址和页表长度 再查页表找到要访问的主存实页号 把实页号p与页内偏移d拼接得到主存实地址 段页式地址变换 虚拟存储器地址变换带来的速度问题 虚拟存储器地址变换带来的速度问题 例题 关于主存和磁盘间交换信息的单位 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/4. 存储系统/4.5 磁盘.html":{"url":"roccoshi_note/02-计算机组成原理/4. 存储系统/4.5 磁盘.html","title":"4.5 磁盘","keywords":"","body":"4.5 磁盘1. 磁盘记录原理2. 磁记录方式3. 磁盘的主要技术指标4. 磁盘性能指标的计算5. 磁盘阵列RAID4.5 磁盘 1. 磁盘记录原理 「巨磁电阻效应」 水平记录 水平记录 垂直记录 垂直记录 2. 磁记录方式 几种垂直记录方式 编码效率 = 位密度 / 最大磁化反转次数 上述有自同步能力且编码效率为100%的是改进调频制MFM 3. 磁盘的主要技术指标 道密度 : 道/mm, 道/英寸 位密度 : bit/mm, bit/英寸, ( ☞最里圈磁道 ) 存储容量 : 非格式化容量 = 位密度 X 内圈磁道周长 X 每个记录面的磁道数 X 记录面数 格式化容量 = 每个扇区的字节数 X 每道的扇区数 X 每个记录面的磁道数 X 记录面数 平均访问时间 = = 寻道时间 : 磁头移动到目标此磁道 ( 或柱面 )所需要的时间 等待事件 : 待读写的扇区旋转到磁头下方所用的时间, 一般用磁头旋转一周所用时间的一半作为平均等待时间 转速 : RPM ( 转/分钟)] 数据传输率 : 磁头找到数据的地址后, 单位时间内写入或读出的字节数 = 每个扇区的字节数 X 每道扇区数 X 磁盘的转速 磁盘的平均寻道时间, 平均等待时间通常为毫秒级 4. 磁盘性能指标的计算 例题 这里要注意内径与外径的带入, 很容易出错 内径, 外径 5. 磁盘阵列RAID RAID : 独立冗余磁盘阵列---由独立的硬盘组成的具有冗余特性的阵列 RAID0 : 无冗余, 把数据打散了存在多个磁盘里 RAID0 RAID1 : 把数据复制一份, 磁盘数量翻倍 raid1和raid0混合 : RAID1 RAID2 : 采用海明码校验数据, 校验盘数量太多, 实现起来很难 RAID3 : 采用奇偶校验码 RAID4 : 块级奇偶校验, 支持并发IO, 存在校验盘争用问题 RAID5 : ( 目前最多, 最流行的方式 ) 块分布式奇偶校验, 把校验盘的数据也分散在各个盘里了 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/5. 指令系统/":{"url":"roccoshi_note/02-计算机组成原理/5. 指令系统/","title":"5. 指令系统","keywords":"","body":"pc永远指向正在执行的指令的下一条指令的地址 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/5. 指令系统/5.1 存储模式与指令的分类.html":{"url":"roccoshi_note/02-计算机组成原理/5. 指令系统/5.1 存储模式与指令的分类.html","title":"5.1 存储模式与指令的分类","keywords":"","body":"5.1 存储模式1. 大端存储和小端存储2. 边界对齐3. 冯诺依曼结构和哈佛结构5.1 存储模式 1. 大端存储和小端存储 大端存储和小端存储 例子 2. 边界对齐 比如64位机器, 也就是8字节, 最好数据的开头都存在8的整数倍的位置上, 这就是边界对齐 边界对齐与边界未对齐 例题 : 例题 short类型是16bit也就是2字节, 也就是说要边界对齐应该存放在2的整数倍位置上 3. 冯诺依曼结构和哈佛结构 冯诺依曼结构 : 只有一个主存, 程序区和数据区在一起 哈佛结构 : 有两个主存, 程序区和数据区不在一起 冯诺依曼结构和哈佛结构 哈佛结构的优点 : 指令存储器只读, 设计和控制简单 避免了数据对程序可能造成的破坏 利用n位地址可以获得2×2n2 \\times 2^n2×2​n​​大小的地址空间 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/5. 指令系统/5.2 指令设计.html":{"url":"roccoshi_note/02-计算机组成原理/5. 指令系统/5.2 指令设计.html","title":"5.2 指令设计","keywords":"","body":"5.2 指令设计1. 指令的基本格式2. 操作码的设计3. 根据地址码数量设计扩展操作码5.2 指令设计 1. 指令的基本格式 指令的基本格式 2. 操作码的设计 举例 : 操作码的设计例题 定长编码 : 两种码长的扩展操作码 : huffman编码(最优) : 3. 根据地址码数量设计扩展操作码 可变长操作码的设计原则 : 短码不能是长码的前缀 例题1 例题2 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/6. CPU/":{"url":"roccoshi_note/02-计算机组成原理/6. CPU/","title":"6. CPU","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/6. CPU/6.1 CPU的功能与结构.html":{"url":"roccoshi_note/02-计算机组成原理/6. CPU/6.1 CPU的功能与结构.html","title":"6.1 CPU的功能与结构","keywords":"","body":"6.1 CPU的功能与结构1. 单总线CPU结构图6.1 CPU的功能与结构 1. 单总线CPU结构图 单总线CPU结构图 PSW : 程序状态字 ( 标志寄存器 ) R0 - Rn-1 : 通用寄存器 SP : 堆栈指针寄存器 DR : 数据寄存器 AR : 地址寄存器 ( 单向 ) PC : 程序计数器 ( 指向下一条指令地址 ) IR : 指令寄存器 ( 存正在执行的指令 ) Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/6. CPU/6.2 微操作与微命令.html":{"url":"roccoshi_note/02-计算机组成原理/6. CPU/6.2 微操作与微命令.html","title":"6.2 微操作与微命令","keywords":"","body":"6.2 微操作与微命令1. 指令周期2. 时序信号的产生6.2 微操作与微命令 微操作 : CPU的基本/原子操作 每一个微操作是通过控制器将控制信号发送到相关部件上引起部件动作而完成的, 这些控制微操作完成的控制信号称为微命令, 微命令是由控制器产生的 微操作与微命令 1. 指令周期 在处理一条指令的过程中, 由CPU完成的操作序列构成一个指令周期 一个指令周期分为若干个CPU周期 指令周期 程序执行示意图 2. 时序信号的产生 微操作的流程 : 时序信号产生 取指周期 中断周期 执行周期 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/6. CPU/6.3 硬布线控制器设计.html":{"url":"roccoshi_note/02-计算机组成原理/6. CPU/6.3 硬布线控制器设计.html","title":"6.3 硬布线控制器设计","keywords":"","body":"6.3 硬布线控制器设计1. 控制器的输出信号2. 微操作序列和微命令序列的设计3. 写出信号的逻辑表达式6.3 硬布线控制器设计 1. 控制器的输出信号 控制器的输出信号 2. 微操作序列和微命令序列的设计 组合微操作的规则 : 遵守操作发生的顺序 避免冲突 ( 总线竞争, 资源冲突 ) 例子: 注意, 节拍T2时候, 为读主存命令, 先传入地址, 主存读入地址后输出数据到系统总线, 再由DR读入 ( Mread就是输出主存对应地址的数据, 主存不需要额外的读入地址的命令 ) MOV R0,X MOV R1,X ADD R1, R0 SUB R0,(X) IN R0,P OUT P,R0 JUMP JZ PUSH POP CALL RET 3. 写出信号的逻辑表达式 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/6. CPU/6.4 微程序控制器设计.html":{"url":"roccoshi_note/02-计算机组成原理/6. CPU/6.4 微程序控制器设计.html","title":"6.4 微程序控制器设计","keywords":"","body":"6.4 微程序控制器设计1. 微指令, 微程序微指令周期和一般格式2. 微程序控制原理3. 微程序与硬布线的比较6.4 微程序控制器设计 思想 : 用软件方法组织和控制数据处理系统的信息传送, 并最终用硬件实现 依据微程序顺序产生一条指令执行时所需的全部控制信号 1. 微指令, 微程序 一个微指令包括几个微操作及其所包含的微命令, 通过一组微指令产生的控制信号, 使一条指令中的所有微操作得以实现, 从而实现一条指令的功能 一个微指令序列称为微程序 微指令周期和一般格式 2. 微程序控制原理 微程序控制器的组成 : 微程序控制器在一个时钟周期的工作流 : 微指令地址的生成 : 微指令的分类 : 水平型微指令 : 控制域的编码 : 水平编码 垂直编码 字段编码 3. 微程序与硬布线的比较 微程序与硬布线的比较 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/6. CPU/6.5 CPU性能测量.html":{"url":"roccoshi_note/02-计算机组成原理/6. CPU/6.5 CPU性能测量.html","title":"6.5 CPU性能测量","keywords":"","body":"6.5 CPU性能测量1. CPU时间2. CPI3. MIPS4. FLOPS6.5 CPU性能测量 1. CPU时间 CPU时间 : CPU在运行某程序上所花费的时间 例题 : 例题 2. CPI CPI : ( Clock cycles per Instruction ) 每条指令执行所用的时钟数 有三个方面的因素使得程序的CPI可能会不同于CPU执行的CPI : Cache行为发生变化 指令混合发生变化 分支预测发生变化 影响CPU性能的三个关键因素 : CPI 时钟频率 指令数 例题 : 3. MIPS MIPS : ( million instructions per second ) --- CPU每秒钟执行的百万指令数 MIPS参数的局限 : 不能对指令集不同的计算机使用MIPS进行比较, MIPS只说明了指令执行速率, 而没有考虑指令的能力 计算对所有程序没有单一的MIPS值, 对于同一个计算机上的不同程序, MIPS是变化的 MIPS会与性能反向变化 4. FLOPS FLOPS : ( Floating point operations per second ) FLOPS = 浮点运算次数M / 执行时间T Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/7. 流水线/":{"url":"roccoshi_note/02-计算机组成原理/7. 流水线/","title":"7. 流水线","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/7. 流水线/7.1 流水线时空图和吞吐率.html":{"url":"roccoshi_note/02-计算机组成原理/7. 流水线/7.1 流水线时空图和吞吐率.html","title":"7.1 流水线时空图和吞吐率","keywords":"","body":"7.1 流水线时空图和吞吐率吞吐率7.1 流水线时空图和吞吐率 吞吐率 吞吐率 : 单位时间内流水线所完成的任务数或输出结果的数量 最大吞吐率TPmax : 流水线在达到稳定状态后所得到的吞吐率 最大吞吐率 瓶颈段 : 含有瓶颈段的流水线结构 细分瓶颈段 : 细分瓶颈段 重复设置瓶颈段 : 重复设置瓶颈段 实际吞吐率 : 实际吞吐率 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/7. 流水线/7.2 加速比和效率.html":{"url":"roccoshi_note/02-计算机组成原理/7. 流水线/7.2 加速比和效率.html","title":"7.2 加速比和效率","keywords":"","body":"7.2 加速比和效率加速比效率吞吐率, 加速比和效率的关系例题流水线的相关7.2 加速比和效率 加速比 定义 : 若流水线为m段, 加速比S定义为等功能的非流水线执行时间T(1)和流水线执行时间T(m)之比 加速比 当n->∞时 S = m, 当m->∞时 S = n, 由此可见增大指令流水线的级数和送入流水线的指令数均可以加速流水线的运行速度 效率 效率 吞吐率, 加速比和效率的关系 吞吐率, 加速比和效率的关系 例题 流水线的相关 实际流水中会出现三种相关也就是使流水线很难充分实现的三个冲突：资源相关、数据相关、控制相关 资源相关：指当指令在重叠执行过程中，不同指令争用同一功能部件产生资源冲突时产生的 数据相关：指令在流水线中重叠执行时，当后继指令需要用到前面的指令产生的结果时发生的 控制相关：当流水线遇到转移指令引起的。统计表明，转移指令约占总指令的四分之一左右，比起数据相关，它会使流水线丧失更多的功能 数据相关 : 写后读相关，读后写相关，写后写相关 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/1. 绪论--冯诺依曼和Amdahl.html":{"url":"roccoshi_note/02-计算机组成原理/1. 绪论--冯诺依曼和Amdahl.html","title":"1. 绪论--冯诺依曼和Amdahl","keywords":"","body":"1. 绪论--冯诺依曼和Amdahl冯诺依曼计算机1. 冯诺依曼计算机的硬件组成2. 冯诺依曼机的特点参考例题和习题Amdahl定律加速比Amdahl定律参考例题和习题1. 绪论--冯诺依曼和Amdahl 要点 : 冯诺依曼计算机结构, 工作原理及特点 Amdahl定律的应用 ( 应能从题目中找到加速比和可加速部分比例关系等, 并应用定律求解) 冯诺依曼计算机 1. 冯诺依曼计算机的硬件组成 运算器 控制器 存储器 输入设备 输出设备 硬件组成 2. 冯诺依曼机的特点 将计算机要处理的问题用指令编成程序 指令和数据以同等地位存放在存储器中, 并可按地址访问 以二进制形式表示指令和数据 在控制器的控制下, 指令被逐条从存储器中取出来执行, 产生控制流, 在控制流的驱动下完成指令的功能 早期的冯诺依曼机以运算器为中心, 输入/输出设备通过运算器与存储器传送数据 参考例题和习题 1.2 1.3 Amdahl定律 加速比 加速比 计算机系统的加速比取决于下面两个因素 : 可改进部分在原系统总执行时间中所占的比例, 称为「可改进比例」, 用fef_ef​e​​表示 例如，程序的总执行时间为100s，可改进的部分是其中的20s，则fe＝0.2。可见， fe总是小于或等1的。 可改进部分改进后性能提高的程度, 称为「部件加速比」, 用rer_er​e​​表示 例如，某部件改进后，(该部件)执行时间由原来的20s减少到5s，则部件加速比re＝20/5＝4。可见， re一般是大于1的。 Amdahl定律 Amdahl定律 参考例题和习题 例题1 例题2 -- 多部件情况 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/8. 总线-IO-DMA.html":{"url":"roccoshi_note/02-计算机组成原理/8. 总线-IO-DMA.html","title":"8. 总线-IO-DMA","keywords":"","body":"8. 总线-IO-DMA1. 总线的概念和性能指标2. 总线仲裁3. 典型的总线4. IO接口5. 总线输入输出技术6. 直接存储器存取方式---DMADMAC与CPU总线控制权的交换方式 :8. 总线-IO-DMA 1. 总线的概念和性能指标 总线 : 是计算机系统的互连结构 是连接两个或多个总线设备的公共通信线路 是一组有定义的, 可共享的, 可传递0, 1逻辑信号的连接线 通常分为地址总线, 数据总线, 控制总线 总线的性能指标 : 总线带宽 总线宽度 总线负载 几个题 : 1 2 2. 总线仲裁 总线仲裁 : 用来决定哪个主设备可以使用总线的选择机制 按照总线仲裁电路位置不同, 仲裁方式可分为 : 集中式仲裁 链式查询方式 --- ( 使用总线的优先次序完全由「总线可用」线所连接部件的物理位置来决定, 离总线控制器越近的部件其优先级越高 ) 计数器定时查询方式 --- ( 轮询计数 ) 独立请求方式 --- ( 独立请求 ) 分布式仲裁 例题 答案是B 3. 典型的总线 PCI总线 ( 内总线, 并行总线 ) USB总线 ( 外总线, 串行总线 ) ( PCIE, SATA总线都是串行总线 ) 4. IO接口 I/O接口的作用 : I/O接口的作用 IO接口的编址方式 : ( 是否与主存使用同一个地址空间 ) 统一编址方式 独立编址方式 5. 总线输入输出技术 分类 : 程序查询方式 中断方式 直接存储器存取 ( DMA ) 方式 I/O通道方式 操作系统 的支持 例题1 例题2 中断屏蔽的屏蔽字设计 例题 6. 直接存储器存取方式---DMA DMA断点在CPU周期间, 中断断点在指令周期间 DMA与中断的比较 : DMA与中断的比较 DMAC与CPU总线控制权的交换方式 : 周期挪用 ( 窃取 )方式 存储器分时方式 停止CPU方式 扩展时钟周期方式 例题 : 题目 第一题 第二题 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/9. 通道 并行性.html":{"url":"roccoshi_note/02-计算机组成原理/9. 通道 并行性.html","title":"9. 通道 并行性","keywords":"","body":"9. 通道 并行性1. 三种通道类型2. 通道的最大流量3. 并行体系结构3.1 计算机体系结构的并行性3.2 计算机体系结构的分类 --- Flynn分类法9. 通道 并行性 1. 三种通道类型 三种通道类型 2. 通道的最大流量 字节多路通道的最大流量是求和关系, 选择通道和数组多路通道的最大流量是求最大值关系 例题 3. 并行体系结构 3.1 计算机体系结构的并行性 并行性 并行机制的层次 3.2 计算机体系结构的分类 --- Flynn分类法 Flynn分类法 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/02-计算机组成原理/车老师雨课堂习题.html":{"url":"roccoshi_note/02-计算机组成原理/车老师雨课堂习题.html","title":"车老师雨课堂习题","keywords":"","body":"雨课堂习题chapter 1Amdahl定律chapter 2定点小数的范围IEEE754标准CRC海明码chapter 3BCD码booth法计算乘法原码加减交替法浮点数加减法chapter 4字扩展和位扩展 芯片容量Cache 4-2LRU替换算法 4-3磁盘chapter 5寻址方式chapter 6微程序和微指令总时间 CPI MIPS雨课堂习题 chapter 1 Amdahl定律 chapter 2 定点小数的范围 IEEE754标准 CRC 海明码 从右向左, 从1开始 ( 和计网笔记上的不同 ) 偶校验 chapter 3 BCD码 运算中某位BCD数(四位二进制数)相加的结果 大于9或有向更高位的进位，则结果加6； booth法计算乘法 原码加减交替法 浮点数加减法 对阶 -- 求和差 --- 规格化 --- 舍入处理 chapter 4 字扩展和位扩展 芯片容量 Cache 4-2 目录表的前面表示的是cache内的组内块号, 内容是主存的「区号 + 组内块号」, 因为组间全相联, 没有必要显示 LRU替换算法 4-3 磁盘 chapter 5 寻址方式 chapter 6 微程序和微指令 总时间 CPI MIPS Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/03-Java学习/":{"url":"roccoshi_note/03-Java学习/","title":"03-Java学习","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/03-Java学习/01. JAVA的基本程序设计结构.html":{"url":"roccoshi_note/03-Java学习/01. JAVA的基本程序设计结构.html","title":"01. JAVA的基本程序设计结构","keywords":"","body":"1. JAVA的基本程序设计结构1. JAVA的基本程序设计结构 由于主要是一些基本的概念如分支, 循环, 数据类型这些, 这里只记录一些点而不做系统的笔记 main方法必须声明为public int 4字节; short 2字节; long 8字节; byte 1字节 ( 注意, java这些数据类型的字节数都是确定的, 而C/C++并不是, 比如C++的int类型可能是2或4字节, 和操作系统甚至编译器都有关, 给跨平台带来了很大的难度, 这也就是Java的\" 可移植性 \"好的原因之一) Java没有任何无符号形式 ( unnsigned) 的int, long, short 或者 byte类型 Java中的boolean类型不能由数值代替, 否则无法通过编译 ( C++中数值甚至指针类型都可以表示bool值 ) 不要使用 '==' 判断两个字符串是否相等, 应该用equals方法 String为不可变字符串, 不能修改单个字符 Java不允许嵌套的快中重定义一个变量 public class coreFormat { public static void main(String[] args) { int x = 3; if( x == 3) { int x = 4; x++; } System.out.println(x); } } /* Error:(10, 17) java: 已在方法 main(java.lang.String[])中定义了变量 x */ Java提供带标签的break语句, 用于跳出多重嵌套循环, 注意标签必须放在希望跳出的最外层循环之前并带上一个冒号 public class coreFormat { public static void main(String[] args) { int n; Imtab: while (true) { while (true) { while (true) { while (true) { break Imtab; } } } } System.out.println(\"I'm out\"); } } /* I'm out */ java.math包中两个大数的类 : BigInteger 和 BigDecimal, 前者实现任意精度的整数运算, 后者实现任意精度的浮点数运算 ( 不能用$+$ 或者 $\\times$ , $\\div$ ...来处理大数, 而需要使用大数类中的add和multiply, divide ...方法 public class coreFormat { public static void main(String[] args) { BigInteger a = BigInteger.valueOf(100); BigInteger reallyBig = new BigInteger(\"1209830129839012830918294798127398123123912848\"); BigInteger reallyBig1 = new BigInteger(\"1290831208309218309128309218038102341\"); BigInteger ans = reallyBig.multiply(reallyBig1); System.out.println(ans); ans = reallyBig.add(reallyBig1); System.out.println(ans); /* 1561686488348991405143064571291343054195716538900929041411407291357060176588777168 1209830131129844039227513107255707341162015189 */ } } 与C++不同, java不提供运算符重载的功能 java提供foreach循环, 格式如 for ( int x : a) public class coreFormat { public static void main(String[] args) { int[] a = {1,2,3,4,5,6,7,}; for(int i:a) System.out.print(i); } } // 1234567 可以用Arrays.toString快速输出一整个数组 public static void main(String[] args) { int[] a = {1,2,3,4,5,6,7,}; System.out.println(Arrays.toString(a)); } // [1, 2, 3, 4, 5, 6, 7] Arrays.copyOf拷贝数组 Arrays.sort数组排序 二维数组的声明 int[][] a = new int[8][8]; for (int i = 0; i Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/03-Java学习/02. JAVA的类与对象.html":{"url":"roccoshi_note/03-Java学习/02. JAVA的类与对象.html","title":"02. JAVA的类与对象","keywords":"","body":"2. JAVA的类与对象2. JAVA的类与对象 同样还是采用记录点的方式做一些简单的笔记 UML ( Unified Modeling Language , 统一建模语言) : 绘制类图, 表述类间关系 所有java对象都存储在堆中 Date deadline定义了一个对象变量deadline, 它可以引用Date类型的对象. 但是变量deadline本身不是一个对象, 可以初始化这个变量让他引用一个新构造的对象deadline = new Date() 或者引用一个已有的对象deadline = birthday 实例字段最好用private修饰, 如果用public修饰, 任何类的任何方法都可以修改这个字段 不能对一个已经存在的对象调用构造器来达到重新设置实例字段的目的 不要编写返回可变对象引用的访问器方法, 如果需要返回一个可变对象的引用, 首先应该对它进行clone 方法可以访问所属类的任何对象的私有特性 final实例字段必须在构造对象时初始化 static字段 : 属于类, 不属于任何一个单个的对象 静态方法 : 静态方法是不在对象上执行的方法, 比如Math类的pow方法, 建议使用类名而不是对象名来调用静态方法 java的参数传递机制是按值调用, 方法不能修改传递给它的任何基本数据类型参数变量的内容, 但是可以改变对象参数的状态 重载( overloading ) : 多个方法有相同的名字和不同的参数, 便出现了重载 Java允许重载任何方法, 而不只是构造器方法 如果类中没有编写构造器, 就会为你提供一个无参数的构造器. 如果类中至少有一个构造器, 那么构造对象时如果不提供参数就是不合法的 构造器必须与类同名, 且不能有返回值( void 也不可 ), 普通方法也可以和类名相同但是必须要有返回值或者void, 构造函数可以重载 构造器的两种写法举例 参数前加前缀 public constructorTest(String aname, int ayear) { this.name = aname; this.year = ayear; } 利用关键词this ( this指示隐式参数, 也就是所构造的对象 public constructorTest(String name, int year) { this.name = name; this.year = year; } 初始化块---一般放在字段定义以后, 一个类的对象被构造时, 这些块就会执行 比如 class xx{ private static int nextId; private int id; private String name; { //初始化块 id = nextId; nextId ++; } } 可以用静态的初始化块来初始化静态字段 e.g. static { var generator = new Random(); nextId = generator.nextInt(1000); } 包 : Java允许使用包将类组织在一个集合中, 借助包可以方便地组织自己的代码, 并将自己的代码与别人提供的代码库分开管理 使用包名的主要原因是确保类名的唯一性, 不同包中相同的类名不会产生冲突 用因特网域名以逆序的方式作为包名 要将类放入包中, 就必须将包的名字放在源文件的开头, 即放在定义这个包的各个类的代码之前 e.g. package com.horseman.corejava public class Employee { ... } 如果没有在源文件中放置package语句, 那么这个源文件的类就属于无名包 , 标记public的部分可以由任意类使用; 标记为private的部分只能由定义它们的类使用; 如果没有标记public或者private, 则这个部分可以被同一个包中的所有方法访问 JAR文件 : Java归档文件, 可以包含类文件, 也可以包含其他类型的文件, JAR文件是压缩的, 它使用ZIP压缩格式. Javadoc : Javadoc是Sun公司提供的一个技术，它从程序源代码中抽取类、方法、成员等注释形成一个和源代码配套的API帮助文档。也就是说，只要在编写程序时以一套特定的标签作注释，在程序编写完成后，通过Javadoc就可以同时形成程序的开发文档, 比如JDK API. 可以参考这里 文档注释 : 类注释 : 放在import 语句之后, 类定义之前 /** *注释 * */ public class xx { ... } 方法注释 字段注释 通用注释 包注释 具体不再赘述 类设计技巧 : 一定要保证数据私有 ( 不破坏封装性 ) 一定要对数据进行初始化 不要再类中用过多的基本类型 不是所有的字段都需要单独的字段访问器和字段修改器 分解有过多职责的类 类名和方法名要能够体现它们的职责 优先使用不可变的类 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/03-Java学习/03. JAVA的继承---多态_抽象.html":{"url":"roccoshi_note/03-Java学习/03. JAVA的继承---多态_抽象.html","title":"03. JAVA的继承---多态_抽象","keywords":"","body":"3. JAVA的继承---多态_抽象多态关于多态中的成员变量关于多态中的成员方法使用多态的好处super关键字抽象类3. JAVA的继承---多态_抽象 关键字 : extends extends表明正在构造的新类派生于一个已经存在的类, 这个已经存在的类称为 超类 基类 或 父类 ; 新类称为子类 或孩子类 从某个特定的类到其祖先的路径称为该类的继承链 在java中, 继承有三个特征 : JAVA是单继承的, 一个类的直接父类只能有一个 class A extends B{} // 正确 class A extends B,C{} // 错误 JAVA语言可以多级继承 ( java.lang.Object类是继承链的顶端 ) class A extends B{} // 正确 class B extends C{} // 正确 一个子类的直接父类是唯一的, 但是一个父类可以拥有很多个子类 多态 在java中, 对象变量是多态的, 子类的每个对象也是超类的对象 e.g. 一个Employee类型的变量既可以引用一个Employee类型的对象, 也可以引用Employee类的任何一个子类的对象 ( 例如, Manager, Executive, Secretary等 ) 关于多态中的成员变量 直接访问成员变量 : 看等号左边是谁, 则优先用谁, 如果没有就向上查找, 不会向下查找 : e.g. public class Father { // 父类 int x = 10; } public class Son extends Father { // 子类 int x = 20; } public class MainFunc { public static void main(String[] args) { Father obj = new Son(); // 多态 System.out.println(obj.x); } } 输出为10, 也就是父类的x属性 \" 编译看左边, 运行也看左边 \" 如果用成员方法间接访问成员变量, 则方法属于谁就优先用谁, 如果没有就向上查找. 关于多态中的成员方法 成员方法的访问原则 : 看new的是谁, 就优先用谁, 如果没有就向上查找 Father obj = new Son(); obj.method; // 父类子类都有, 优先使用子类的 obj.method_of_father; // 子类没有, 向上查找使用父类 obj.method_of_son; // 父类没有, 报错 ! (编译不通过) \" 编译看左边, 运行看右边 \" 使用多态的好处 比如一个学校里有很多不同的工种 教授, 副教授, 导员, 讲师, 助教.... 他们都是为学校工作 他们在学校都是工作, 那么不使用多态的写法为 : teacher a = new teacher(); assistant b = new assistant(); professor c = new professor(); a.work(); b.work(); c.work(); .... 使用多态则为 : Employee a = new teacher(); Employee b = new assistant(); Employee c = new professor(); ... 无论右边是什么, 左边对于学校来说都是Employee的身份... 关于强制类型转换 ( 向下转型 ) : 只能在继承层次内进行强制类型转换 在将超类强制转换成子类之前, 应该用instanceof进行检查 if ( a instanceof b) { c = (b) a; } super关键字 在子类的成员方法中, 访问父类的成员变量 在子类的成员方法中, 访问父类的成员方法 在子类的构造方法中, 访问父类的构造方法 public son extends father{ int num = 20; public son() { super(); // 父类的构造方法 } public void methodson() { sout(super.num); // 父类的num } public void method() { super.method(); // 父类的method } } 抽象类 如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类 抽象类和抽象方法用abstract关键字表示 public abstract class Animal { // 抽象方法 public abstract void eat(); // 普通的成员方法 public void normalMethod() { } } 子类必须覆盖重写抽象类的所有抽象方法 : ( idea中在子类 alt + enter -- implement -- @Override) 一个继承的案例 : 发红包 User父类 : package Red_Beg; public class USer { private String name; private int money; // alt + insert自动生成 public USer() { } public USer(String name, int money) { this.name = name; this.money = money; } public void show() { System.out.println(\"我叫, \" + name + \", 我有多少钱? : \" + money); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getMoney() { return money; } public void setMoney(int money) { this.money = money; } } Manager发红包 : package Red_Beg; import java.util.ArrayList; public class Manager extends USer { public Manager() { } public Manager(String name, int money) { super(name, money); } public ArrayList send(int totalMoney, int count) { // 集合, 存储若干个红包的金额 ArrayList redList = new ArrayList<>(); int leftMoney = super.getMoney(); if (totalMoney > leftMoney) { System.out.println(\"余额不足\"); return redList; } else // 扣钱 { super.setMoney(leftMoney - totalMoney); // 发红包平均拆分成count段 int avg = totalMoney / count; int mod = totalMoney % count; // 放进集合 for (int i = 0; i Member收红包 : package Red_Beg; import java.util.ArrayList; import java.util.Random; public class Member extends USer { public Member() { } public Member(String name, int money) { super(name, money); } public void receive(ArrayList list) { // 随机抽取一个红包 int index = new Random().nextInt(list.size()); // 以上为生成一个0-list.size()的随机int // 根据索引从集合中删除 int delta = list.remove(index); int money = super.getMoney(); super.setMoney(money + delta); } } Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/03-Java学习/04. ArrayList.html":{"url":"roccoshi_note/03-Java学习/04. ArrayList.html","title":"04. ArrayList","keywords":"","body":"4. ArrayListArrayList常用方法向ArrayList中存储基本类型的数据4. ArrayList 数组有一个缺点, 一旦创建, 程序运行期间长度是不可以改变的 Java中的可变数组 --- ArrayList ArrayList ArrayList , 代表泛型 只能是引用类型, 不能是基本类型 用几个例子好理解 : ArrayList list = new ArrayList<>(); list.add(\"rock\"); list.add(\"rock you\"); System.out.println(list); ------------------- // 输出 : [rock, rock you] 常用方法 add 向集合当中添加元素 get get(int index); 从集合中获取元素, 返回值是对应位置元素 remove remove(int index); 删除对应位置元素 size 返回集合大小 向ArrayList中存储基本类型的数据 如果希望向集合ArrayList当中存储基本类型的数据, 必须使用基本类型对应的 \" 包装类 \" ; 由于JDK1.5+开始支持自动装箱和自动拆箱, 可以直接用基本类型进行存取操作. e.g. ArrayList list = new ArrayList<>(); list.add(100); int x = 30; list.add(x); int y = list.get(0); System.out.println(y); ---------- 输出 : 100 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/03-Java学习/05. String.html":{"url":"roccoshi_note/03-Java学习/05. String.html","title":"05. String","keywords":"","body":"5. String创建字符串的常见方式字符串常量池常用方法内容比较获取截取转换分割5. String java.lang.String类 程序当中所有的双引号字符串, 都是String类的对象 字符串是常量 , 内容是永不可变的 由于字符串不可改变, 所以字符串是可以共享使用的 创建字符串的常见方式 public String(); 创建一个空白字符串, 不含有任何内容 public String(char[] array) ; 根据字符数组的内容来创建对应的字符串 public String(byte[] array) ; 根据字节数组的呢欸容来创建对应的字符串 e.g. 字符串常量池 常用方法 内容比较 equal方法 : 根据内容进行比较 ( ==是根据地址 ) equalsIgnoreCase : 忽略大小写进行内容比较 获取 public int length() public String concat(String str) public char charAt(int index) : 获取指定索引位置的单个字符 public int indexOf(String str) : 查找参数字符串在本字符串当中首次出现的索引位置, 如果没有则返回-1值 截取 public String substring (int index) : 截取从index处一直到字符串末尾的字符串 public String substring (int begin, int end) : 左闭右开截取新字符串 转换 public char[] toCharArray() : 将当前字符串拆分为字符串数组作为返回值 public byte[] getBytes() : 获得当前字符串底层的字节数组 public String replace (CharSequence oldString, CharSequence newString) : 将所有出现的老字符串替换成为新字符串 分割 public String[] split (String regex) : 按照参数的规则( 正则表达式 ), 将字符串切分为若干部分; Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/03-Java学习/06. 接口.html":{"url":"roccoshi_note/03-Java学习/06. 接口.html","title":"06. 接口","keywords":"","body":"6. Interface接口的定义和介绍接口的实现与使用默认方法静态方法私有方法常量几个注意事项6. Interface 接口的定义和介绍 接口 (interface) 就是多个类的公共规范 接口是一种引用数据类型, 最重要的内容就是其中的 : 抽象方法 定义一个接口的格式 : public interface 接口名称 { } 接口中可以包含的内容有 : 常量 抽象方法 Java8后可以额外包含 : 默认方法 静态方法 Java9后可以包含 : 私有方法 接口中的抽象方法的修饰符必须是 : public abstarct public interface MyInterface01 { public abstract void method01(); public abstract void method02(); } 也可以省略不写 ( 默认就是public abstract ) : public interface MyInterface01 { void method01(); void method02(); } 接口的实现与使用 接口不能直接使用, 必须有一个\"实现类\"来实现该接口 格式 : public class 类名 implements 接口名 { } 接口的实现类必须覆盖重写 ( 实现 ) 接口中所有的抽象方法, 除非实现类就是抽象类 接口 : public interface MyInterface01 { void method01(); void method02(); int method03(); } 实现类 : public class demo01 implements MyInterface01 { @Override public void method01() { System.out.println(\"method01\"); } @Override public void method02() { System.out.println(\"method02\"); } @Override public int method03() { return 0; } } 使用 : public static void main(String[] args) { demo01 demo = new demo01(); demo.method01(); demo.method02(); demo.method03(); } 默认方法 可以直接在接口中定义, 实现类不需要覆盖重写 ( 也可以覆盖重写, 在使用时如果没有重写, 就会向上查找 ) public interface MyInterface01 { void method01(); void method02(); public default void methodDefault() { // 默认方法 ... } } 静态方法 public interface MyInterface01 { void method01(); void method02(); public static void methodStatic() { // 默认方法 ... } } 注意 : 静态方法不可以通过接口实现类的对象来调用, 而应该通过接口名称, 直接调用其中的静态方法 正确的调用 : MyInterface01.methodStatic() 私有方法 普通私有方法 静态私有方法 解决接口内部重复代码的问题 常量 接口当中的常量, 定义必须使用 public static final 进行修饰( 可省略 ), 必须赋值 常量的推荐命名方式 : 使用完全大写, 并且使用下划线进行分隔 几个注意事项 接口是没有静态代码块或者构造方法的 一个类的直接父类是唯一的, 但是一个类可以同时实现多个接口 public class XX implements interfaceA, interfaceB { } 如果实现类所实现的多个接口当中, 存在重复的抽象方法, 那么只需要覆盖重写一次 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/03-Java学习/07. Date,_DateFormat,_Calendar类.html":{"url":"roccoshi_note/03-Java学习/07. Date,_DateFormat,_Calendar类.html","title":"07. Date,_DateFormat,_Calendar类","keywords":"","body":"7. Date类构造方法成员方法DateFormat类构造和成员方法Calendar类Calendar类的常用成员方法7. Date类 java.util.Date Date表示特定的时间, 精确到毫秒 时间原点 ( 0m ) : 1970年1月1日 00:00 构造方法 空参构造方法 : 获取当前系统的日期和时间 Date date = new Date(); 带参数构造方法 : Date ( long date ) : 传递毫秒值, 把毫秒值转换为日期 Date date = new Date(0); System.out.println(date); // 输出Thu Jan 01 08:00:00 CST 1970 成员方法 getTime() 把日期转换为毫秒 DateFormat类 java.text.DateFormat类是日期/时间格式化子类的抽象类 可以完成日期和文本之间的转换 构造和成员方法 String format(Date date) : 按照指定的模式把Date日期格式化为符合模式的字符串 Date parse(String source) : 把符合模式的字符串解析为Date日期 DateFormat类是一个抽象类, 无法直接创建对象使用, 可以使用DateFormat的子类 : java.text.SimpleDateFormat SimpleDateFormat的构造方法 : SimpleDateFormat(String pattern) : 用指定的模式和默认语言环境的日期格式符号构造SimpleDateFormat 常用的格式规则 : 字母 含义 y 年 M 月 d 日 H 时 m 分 s 秒 SimpleDateFormat的format和parse方法 format : 创建SimpleDateFormat对象并在构造方法中传递指定的模式 使用format方法把Date转换为符合模式的字符串 e.g. Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String format = sdf.format(date); System.out.println(format); // 输出 : 2020-06-25 08:34:48 parse : 创建SimpleDateFormat对象并在构造方法中传递指定的模式 使用parse方法把符合模式的字符串解析为Date日期 注意 : parse方法声明了一ParseException解析异常, 如果字符串和构造方法中的模式不一样程序就会抛出此异常 e.g. String text = \"2020-06-25 08:34:48\"; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); Date date = sdf.parse(text); System.out.println(date); System.out.println(date.getTime()); /* 输出 : Thu Jun 25 08:34:48 CST 2020 1593045288000 */ Calendar类 Java.util.Calendar Calendar类是一个抽象类, 里面提供了很多操作日历字段的方法 ( YEAR, MONTH, DAY_OF_MONTH. HOUR ...) Calendar类无法直接创建对象使用, 里面有一个静态方法getInstance(), 该方法返回了Calendar类的子类对象 Calendar类的常用成员方法 public int get(int field) : 返回给定日历字段的值 public void set(int field, int value) : 将给定日历字段设置为给定值 public abstract void add(int field, int amount) : 根据日历的规则, 为给定的日历字段添加或减去指定的时间量 public Date getTime() : 返回一个表示此Calendar时间值的Date对象 其中的int field 是日历字段如YEAR, MONTH...可直接用Calendar.YEAR....获取 get的使用 : e.g. Calendar c = Calendar.getInstance(); System.out.println(c.get(Calendar.YEAR)); // 2020 System.out.println(c.get(Calendar.DATE)); // 25 set和getTime的使用 : e.g. Calendar c = Calendar.getInstance(); c.set(2000,8,7); Date date = c.getTime(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); System.out.println(sdf.format(date)); // 2000-09-07 add的使用 : e.g. Calendar c = Calendar.getInstance(); c.set(2000,8,7); c.add(Calendar.YEAR,-1); //2000 -- 1999 Date date = c.getTime(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); System.out.println(sdf.format(date)); // 1999-09-07 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/03-Java学习/08. System类_StringBuilder.html":{"url":"roccoshi_note/03-Java学习/08. System类_StringBuilder.html","title":"08. System类_StringBuilder","keywords":"","body":"8. System类几个常用方法 :StringBuilder类两种构造方法 :几个常用方法 :8. System类 几个常用方法 : arraycopy方法 int[] src = {1,2,3,4,5}; int[] dest = {6,7,8,9,10}; System.out.println(Arrays.toString(dest)); System.arraycopy(src, 0, dest, 0, 3); System.out.println(Arrays.toString((dest))); /* out : [6, 7, 8, 9, 10] [1, 2, 3, 9, 10] */ System.currentTimeMillis() 获取当前的毫秒值 ( = new Date().getTime() ) System.getProperty 获取路径 System.out.println(System.getProperty(\"user.dir\")); System.out.println(System.getProperty(\"user.home\")); System.out.println(System.getProperty(\"java.home\")); /* out : E:\\projects\\JavaSE C:\\Users\\roccoshi C:\\Program Files\\Java\\jdk-11.0.2 */ StringBuilder类 StringBuilder类 : 字符串缓冲区, 可以提高字符串的操作效率 底层也是一个数组, 但是没有被final修饰, 可以改变长度 两种构造方法 : StringBuilder bu1 = new StringBuilder(); StringBuilder bu2 = new StringBuilder(\"abc\"); 几个常用方法 : append 可以添加许多基本类型, 返回值为调用方法的对象本身 e.g. StringBuilder bu1 = new StringBuilder(); bu1.append(\"abc\"); bu1.append(123123); bu1.append(11.123); System.out.println(\"bu1 : \" + bu1); // out : bu1 : abc12312311.123 toString 可以把一个StringBuilder类变成一个字符串 e.g. String s1 = bu1.toString(); Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/03-Java学习/09. 包装类.html":{"url":"roccoshi_note/03-Java学习/09. 包装类.html","title":"09. 包装类","keywords":"","body":"9. 包装类装箱与拆箱装箱拆箱自动装箱和自动拆箱基本类型与字符串之间的转换9. 包装类 包装类的作用 : 将基本引用类型像对象一样操作 基本类型 对应的包装类 byte Byte short Short int Integer long Long double Double char Character boolean Boolean 装箱与拆箱 装箱 : 从基本类型转换为对应的包装类对象 拆箱 : 从包装类对象转换为对应的基本类型 装箱 构造方法 : Integer(int value) 构造一个新分配的Integer对象, 它表示指定的int值 Integer (String s) 构造一个新分配的Integer对象, 它表示String参数所指示的int值 有横线, 说明方法过时了 静态方法 : static Integer valueOf(int i) static Integer valueOf(String s) 拆箱 成员方法 : int intValue() 以 int 类型返回该Integer值 Integer n1 = Integer.valueOf(\"111\"); int m = n1.intValue(); // 拆箱 ( Integer -> int ) 自动装箱和自动拆箱 JDK1.5之后基本类型数据和包装类之间可以自动的相互转换 e.g. Integer n = 123; // 自动装箱 等价于 Integer n = Integer.valueOf(123) 注意 : 包装类无法直接参与运算 , 可以自动转换为基本类型的数据再参与计算 --- 自动拆箱 e.g. Integer n = 123; int x = n + 1; sout(x); // 124 基本类型与字符串之间的转换 基本类型 --> 字符串 直接基本类型 + \"\" , 比如 34 + \"\" --- 最简单方式 static String toString(int i ) static String valueOf(int i) 字符串-->基本类型 使用包装类的静态方法parseXXX e.g. String s1 = \"100000\"; int s2 = Integer.parseInt(s1); System.out.println(s2); // s2 = 100000 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/03-Java学习/10. Collection集合框架_iterator迭代器_增强for循环foreach.html":{"url":"roccoshi_note/03-Java学习/10. Collection集合框架_iterator迭代器_增强for循环foreach.html","title":"10. Collection集合框架iterator迭代器增强for循环foreach","keywords":"","body":"10. 集合Collection iterator迭代器 foreachCollection(单列集合)的框架Collection下的方法Iterator迭代器增强for循环 --- for each10. 集合Collection iterator迭代器 foreach 集合和数组的区别 : 数组的长度固定, 集合的长度可变 数组中存储的是同一类型的元素, 集合存储的都是对象 Collection(单列集合)的框架 Collection下的方法 最顶层, 所有实现类都可以使用 : 方法 作用 boolean add(E e) 向集合中添加元素 boolean remove(E e) 删除集合中某个元素 void clear() 清空集合中所有元素 boolean isEmpty() 判断集合是否为空 int size() 获取集合的长度 Object[] toArray() 将集合转换成一个数组 Iterator迭代器 Iterator迭代器是一个接口, 无法直接使用, 需要获取实现类, 获取实现类的方式 : Collectioni.iterator()返回在collection的元素上进行迭代的迭代器 使用步骤 : 获取迭代器的实现类对象 使用iterator接口中的方法hasNext判断有没有下一个元素 使用iterator接口中的放啊next取出下一个元素 e.g. Collection col = new ArrayList<>(); col.add(\"jack\"); col.add(\"mike\"); col.add(\"amy\"); Iterator it = col.iterator(); while (it.hasNext()) { System.out.println(it.next()); } //out : jack mike amy ( 迭代器的实现就像一个指针, 初始指在下标为-1的位置, 然后通过不断地next移动到集合末尾 ) 增强for循环 --- for each 格式 : for (集合/数组的数据类型 变量名 : 集合名/数组名) {} e.g. public static void main(String[] args) { // 遍历数组 int[] arr = {1,2,3,4,5}; for (int i : arr) { System.out.println(i); } // 遍历集合 Collection col = new ArrayList<>(); col.add(\"jack\"); col.add(\"mike\"); col.add(\"amy\"); for (String a: col) { System.out.println(a); } } Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/03-Java学习/11. 泛型.html":{"url":"roccoshi_note/03-Java学习/11. 泛型.html","title":"11. 泛型","keywords":"","body":"11. 泛型定义含有泛型的类定义含有泛型的方法定义含有泛型的接口泛型通配符泛型的上下限限定11. 泛型 泛型是一种未知的数据类型, 当我们不知道使用什么类型的时候, 可以使用泛型 泛型也可以看成一个变量, 用来接收数据类型 在创建集合对象的时候, 就会确定泛型的数据类型 使用泛型的好处 : 避免了类型转换的麻烦, 存储的是什么类型, 取出的就是什么类型 缺点 : 泛型是什么类型, 只能存储什么类型的数据 定义含有泛型的类 类定义如下, 所有类型均用E代替 : public class genericDemo { private E name; public E getName() { return name; } public void setName(E name) { this.name = name; } } 实例化 : public class demo02 { public static void main(String[] args) { // 不写泛型默认为object类型 genericDemo gc = new genericDemo(); gc.setName(\"string\"); Object name = gc.getName(); System.out.println(name); // 泛型使用Integer类型 genericDemo gc2 = new genericDemo<>(); gc2.setName(1); // 泛型使用String类型 genericDemo gc3 = new genericDemo<>(); gc3.setName(\"hello world\"); } } 定义含有泛型的方法 普通方法 : // 泛型方法定义在方法的修饰符和返回类型之间 public class genericMethodDemo { public void method01(M m) { System.out.println(m); } } 测试 : public class dmeo03 { public static void main(String[] args) { genericMethodDemo gm = new genericMethodDemo(); gm.method01(123); gm.method01(\"hello world\"); gm.method01(1231.123); } } /* out : 123 hello world 1231.123 */ 静态方法 : public static void method02(S s) { System.out.println(s); } 定义含有泛型的接口 定义 : public interface genericInterface { public abstract void method(I i); } 实现类 : 方式1 : ( 实现类指定类型 ) public class genericInterfaceImpl implements genericInterface{ @Override public void method(String s) { System.out.println(s); } } 方式2 : ( 创建对象时指定类型 ) public class genericInterfaceImpl implements genericInterface{ @Override public void method(E e) { System.out.println(e); } } 泛型通配符 ? --- 代表任意的数据类型 使用方式 : 不能创建对象使用 只能作为方法的参数使用 e.g. 定义一个方法遍历一个ArrayList, 由于不知道ArrayList存的是什么数据类型, 就在参数中使用 ? 由于泛型没有继承概念, 参数不可以使用Object public class demo05 { public static void main(String[] args) { ArrayList l1 = new ArrayList<>(); l1.add(1); l1.add(2); ArrayList l2 = new ArrayList<>(); l2.add(\"hahaha\"); l2.add(\"hehehe\"); printArray(l1); printArray(l2); } public static void printArray(ArrayList list) { // 不能用object Iterator it = list.iterator(); while(it.hasNext()) { Object o = it.next(); System.out.println(o); } } } /* out : 1 2 hahaha hehehe */ 泛型的上下限限定 ? extends x : 限定上限, 必须是x类型或者是x类型的子类 ? super x : 限定下限, 必须是x类型或者是x类型的父类 栗子 : public static void getElement1(Collection coll) {} // 必须是Number类型或者其子类 public static void getElement2(Collection coll) {} // 必须是Number类型或者其父类 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/04-linux学习/":{"url":"roccoshi_note/04-linux学习/","title":"04-linux学习","keywords":"","body":"Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/04-linux学习/常用的linux命令/":{"url":"roccoshi_note/04-linux学习/常用的linux命令/","title":"常用的linux命令","keywords":"","body":"1. cd2. ls3. grep4. find5. cp6. mv7. rm8. ps (process) 查看进程9. kill10. killall11. file12. tar 压缩13. cat14. chgrp 改变用户组15. chmod 改变文件权限16. time 参考 1. cd cd /root/Docements # 切换到目录/root/Docements cd ./path # 切换到当前目录下的path目录中，“.”表示当前目录 cd ../path # 切换到上层目录中的path目录中，“..”表示上一层目录 2. ls -l ：列出长数据串，包含文件的属性与权限数据等 -a ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用） -d ：仅列出目录本身，而不是列出目录的文件数据 -h ：将文件容量以较易读的方式（GB，kB等）列出来 -R ：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来 ls -l列出的含义 : 3. grep grep [-acinv] [--color=auto] '查找字符串' filename -a ：将binary文件以text文件的方式查找数据 -c ：计算找到‘查找字符串’的次数 -i ：忽略大小写的区别，即把大小写视为相同 -v ：反向选择，即显示出没有‘查找字符串’内容的那一行 grep命令常与管道结合使用, 如 : ls -l | grep -i file 4. find find [PATH] [option] [action] # 与时间有关的参数： -mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件； -mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名； -mtime -n : 列出在n天之内（含n天本身）被更改过的文件名； -newer file : 列出比file还要新的文件名 # 例如： find /root -mtime 0 # 在当前目录下查找今天之内有改动的文件 # 与用户或用户组名有关的参数： -user name : 列出文件所有者为name的文件 -group name : 列出文件所属用户组为name的文件 -uid n : 列出文件所有者为用户ID为n的文件 -gid n : 列出文件所属用户组为用户组ID为n的文件 # 例如： find /home/ljianhui -user ljianhui # 在目录/home/ljianhui中找出所有者为ljianhui的文件 # 与文件权限及名称有关的参数： -name filename ：找出文件名为filename的文件 -size [+-]SIZE ：找出比SIZE还要大（+）或小（-）的文件 -tpye TYPE ：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f)、设备文件（b、c）、 目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）； -perm mode ：查找文件权限刚好等于mode的文件，mode用数字表示，如0755； -perm -mode ：查找文件权限必须要全部包括mode权限的文件，mode用数字表示 -perm +mode ：查找文件权限包含任一mode的权限的文件，mode用数字表示 # 例如： find / -name passwd # 查找文件名为passwd的文件 find . -perm 0755 # 查找当前目录中文件权限的0755的文件 find . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte 5. cp -a ：将文件的特性一起复制 -p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份 -i ：若目标文件已经存在时，在覆盖时会先询问操作的进行 -r ：递归持续复制，用于目录的复制行为 -u ：目标文件与源文件有差异时才会复制 e.g. cp -a file1 file2 #连同文件的所有特性把文件file1复制成文件file2 cp file1 file2 file3 dir #把文件file1、file2、file3复制到目录dir中 6. mv -f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖 -i ：若目标文件已经存在，就会询问是否覆盖 -u ：若目标文件已经存在，且比目标文件新，才会更新 7. rm -f ：就是force的意思，忽略不存在的文件，不会出现警告消息 -i ：互动模式，在删除前会询问用户是否操作 -r ：递归删除，最常用于目录删除，它是一个非常危险的参数 8. ps (process) 查看进程 -A ：所有的进程均显示出来 -a ：不与terminal有关的所有进程 -u ：有效用户的相关进程 -x ：一般与a参数一起使用，可列出较完整的信息 -l ：较长，较详细地将PID的信息列出 常用搭配 : ps aux # 查看系统所有的进程数据 ps ax # 查看不与terminal有关的所有进程 ps -lA # 查看系统所有的进程数据 ps axjf # 查看连同一部分进程树状态 9. kill 向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用 kill -signal PID #常用参数 (代号) 1：SIGHUP，启动被终止的进程 2：SIGINT，相当于输入ctrl+c，中断一个程序的进行 9：SIGKILL，强制中断一个进程的进行 15：SIGTERM，以正常的结束进程方式来终止进程 17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行 10. killall 向一个命令启动的进程发送一个信号 killall [-iIe] [command name] -i ：交互式的意思，若需要删除时，会询问用户 -e ：表示后面接的command name要一致，但command name不能超过15个字符 -I ：命令名称忽略大小写 # 例如： killall -SIGHUP syslogd # 重新启动syslogd 11. file file filename # 查看文件属性 用法如下 : 12. tar 压缩 -c ：新建打包文件 -t ：查看打包文件的内容含有哪些文件名 -x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中 -j ：通过bzip2的支持进行压缩/解压缩 -z ：通过gzip的支持进行压缩/解压缩 -v ：在压缩/解压缩过程中，将正在处理的文件名显示出来 -f filename ：filename为要处理的文件 -C dir ：指定压缩/解压缩的目录dir 压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称 查询：tar -jtv -f filename.tar.bz2 解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录 13. cat 查看文件 查看文件的其他命令 : tac : 从最后一行开始 nl : 显示行号 more : 一页一页显示 less : 与more类似, 可以往前翻页 head : 只看头几行 ( -n控制行号 ) tail : 只看尾几行 ( -n控制行号 ) 14. chgrp 改变用户组 chgrp [-R] dirname/filename -R ：进行递归的持续对所有文件和子目录更改 # 例如： chgrp users -R ./dir # 递归地把dir目录下中的所有文件和子目录下所有文件的用户组修改为users 15. chmod 改变文件权限 参考 : https://www.runoob.com/linux/linux-comm-chmod.html 例子 : 将文件 file1.txt 设为所有人皆可读取 : chmod ugo+r file1.txt 将文件 file1.txt 设为所有人皆可读取 : chmod a+r file1.txt 将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 : chmod ug+w,o-w file1.txt file2.txt 将 ex1.py 设定为只有该文件拥有者可以执行 : chmod u+x ex1.py 将目前目录下的所有文件与子目录皆设为任何人可读取 : chmod -R a+r * 此外chmod也可以用数字来表示权限如 : chmod 777 file 语法为： chmod abc file ---------------------- chmod a=rwx file 和 chmod 777 file 效果相同 chmod ug=rwx,o=x file 和 chmod 771 file 效果相同 16. time 测算一个命令（即程序）的执行时间 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/05-github操作/":{"url":"roccoshi_note/05-github操作/","title":"05-github操作","keywords":"","body":"GITHUB高级搜索常用git命令1 | 增删文件2 | 代码提交3 | 分支4 | 标签5 | 查看信息6 | 远程同步7 | 撤销解决每次提交都要输入用户密码GITHUB 高级搜索 descirption code 在仓库名中搜索 in:name projectx 在描述中搜索 in:descripton peojectx 寻找star>100的projectx stars:>100 projectx 寻找fork>100的projecty forks:>100 projecty 寻找仓库大小>5MB的projectx size:>5000 projectx 寻找某日期之后更新的项目 pushed:>2020-01-03 projectx 明确仓库语言 language:java projectx 明确作者 user:rocco projectx 明确组织 org:webgroup projectx 「综合使用」 空格分隔即可 常用git命令 # 名词 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 1 | 增删文件 # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] # 生成一个可供发布的压缩包 $ git archive 2 | 代码提交 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 3 | 分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 4 | 标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 5 | 查看信息 # 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat \"@{0 day ago}\" # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog 6 | 远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 7 | 撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop ref : 阮一峰 解决每次提交都要输入用户密码 git remote -v查看是否使用的https 修改成ssh方式 git remote rm origin git remote add origin [ssh地址] git push -u origin master 如果没添加 ssh-key : 生成rsa ssh-key : ssh-keygen -t rsa -C \"your_email@example.com\" # -t 指定密钥类型，默认是 rsa ，可以省略。 # -C 设置注释文字，比如邮箱。 # -f 指定密钥文件存储文件名。 进入~/.ssh目录 复制id_rsa.pub文件 ( 公钥 ) 登录github账号，进入Account Settings，然后点击菜单栏的 SSH key 进入页面添加 SSH key。 测试一下是否成功, git bash输入$ ssh -T git@github.com如果出现Hi xxx! You've successfully authenticated, but GitHub does not provide shell access.说明配置成功 重复之前操作, 修改remote address为ssh方式即可 Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "},"roccoshi_note/06-模电/":{"url":"roccoshi_note/06-模电/","title":"06-模电","keywords":"","body":"模电复习要点第一章 PN结 二极管 三极管第二章 放大电路分析基础第三章 频率特性第四章 场效应管放大电路第五章 负反馈放大电路第六章 集成运算放大器第七章 集成运放第九章 低频功率放大电路第十章 直流稳压电路--- layout: post title: analogue slug: analogue date: 2020-08-07 9:08 status: publish author: roccoshi categories: - Study tags: - Study - Course --- 模电复习要点 课件pdf地址 : https://cutt.ly/1dFyUaq 题型 : 填空 : 30空 30分 简答 : A卷 5个25分 B卷 4个24分 计算 : 4个计算题 —— 15分, 10分, 10分, 10分 第一章 PN结 二极管 三极管 1.1 | 什么是杂质半导体, 分了哪2类, 本征半导体...掺杂几价元素, 多数载流子, 少数载流子 本征半导体 ( 纯净 ) : 本征掺杂+5价元素 —— N型半导体 —— 多数载流子是自由电子 本征掺杂+3价元素 —— P型半导体 —— 多数载流子是空穴 1.2 | PN结单向导电性如何体现, 加正向电压外电场和内电场方向, 耗尽层变宽还是变窄 PN结加正向电压 —— 削弱自建场作用，扩散运动 > 漂流运动，耗尽层变窄 PN结加反向电压 —— 漂移＞扩散，耗尽层变宽 1.3 | PN结的击穿 : 雪崩击穿，齐纳击穿如何区分 1.4 | PN结的电容效应 : 势垒电容, 扩散电容 正偏：扩散电容 反偏：势垒电容 1.5 | 二极管的应用 : 双向限幅电路 每一个二极管什么情况下导通 什么情况下截止, 输入一个正弦波, 画出输出波形 「第一章课后习题16题」 答案 : 1.6 | 特殊的二极管 : 正常工作的工作状态 ( PN结正向导通or反向导通or截止or击穿 ) 如稳压二极管, 光敏二极管是咋样的 稳压二极管 : 原理 : PN结的反向击穿特性 发光二极管LED : 工作条件 : 正偏 光敏二极管 : 工作条件 : 反偏 ( 反向电流强度与光照度成正比 ) 1.7 | 三极管 : PNP, NPN的类型, 特性曲线 ( 输入特性曲线, 输出特性曲线 ) | 放大区, 饱和区, 截止区 | 三极管实现放大的内部条件 | 各个区的发射结和集电结的工作状态 ( 正偏反偏 ) 给出三极管上三个级的电压, 判断NPN or PNP , 硅 or 锗 , CBE级判定 | 三极管实现放大的内部条件 : ( 发射区重参杂, 基区非常薄, 集电区面积大 ) 三极管的输入特性曲线 : Uce不变时Ube和Ib之间的关系就是输入曲线 三极管的输出特性曲线 : Ib不变时Ic和Uce之间的关系 温度升高, 输入特性曲线左移, 输出特性曲线上移 判断问题 : 2入1出NPN, 2出1入PNP, 放大区Ie永远最大 第二章 放大电路分析基础 2.1 | 放大电路的直流通路和交流通路 直流通路 : 断路Ui交流电源, 电容开路 交流通路 : Ucc接地, 短路电容 2.2 | 放大电路的直流工作状态 ( 静态工作点 ) 静态工作点 : IBQICQUBEQUCEQ \\text{I}_{\\text{BQ}}\\,\\, \\text{I}_{\\text{CQ}}\\,\\, \\text{U}_{\\text{BEQ}}\\,\\, \\text{U}_{\\text{CEQ}} I​BQ​​I​CQ​​U​BEQ​​U​CEQ​​ 首先Ube可以直接由硅/锗管确定 ( 0.7 0.2) 然后由电压关系计算Ibq -- Icq 最后计算Uceq 2.3 | 微变等效电路的画法 ( 交流通路---三个级---等效电路---用微变模型替换 ) 注意rbe的计算 : rbe=rbb+(1+β)26IEQ(Ω)(IEQ 取 mA)r_{b e}=r_{b b}+(1+\\beta) \\frac{26}{I_{E Q}}(\\Omega) \\quad\\left(I_{E Q} \\text { 取 } m A\\right)r​be​​=r​bb​​+(1+β)​I​EQ​​​​26​​(Ω)(I​EQ​​ 取 mA) 2.4 | 表2-2 三种基本组态放大电路的分析 共基 共射 共集 以及各自的特点 表2-2 共集电极 : 没有电压放大能力 ( Au≈1 ), 输入输出同相, 「电压跟随器」 共射极 : Au较大, 输入输出反相, 应用广泛 共基极 : Au = 共射极, 但是输入输出同相, 通频带宽 没有放大能力的是哪个 ( 共集 ), 输入电流和输出电流反向的是什么 ( 共射 )等等 2.5 | 工作点稳定电路 当温度升高时, 除了Ube减小, 其他的 ( β, Icbo, Iceo )均增大 偏置电路, 此时Ub被认为恒定不变 2.6| 多级放大电路 耦合方式---直接耦合,变压器耦合,阻容耦合, 每一类耦合方式的特点和缺点 ( 了解 ) 多级放大电路的放大倍数是每一级放大倍数的乘积 ( 分贝如何表示 ) 输入电阻是第一级的输入电阻 输出电阻是最后一级的输出电阻 放大倍数 = 各级放大倍数之积 增益 = 分贝之和 ( 电压放大倍数的分贝 = 20lg(Au) ) 会出这个种题(说漏嘴啦) : 前面是一个三极管基本放大 + 第二级是集成运放 问 : 组态, 输入输出关系, 再问输入电压和输出电压的关系 第三章 频率特性 3.1 | 本章作了解 课后习题了解1,2题 注意3分贝和0.707 0.707Um对应的两个频率分别为上限频率和下限频率 课后习题1, 2 第四章 场效应管放大电路 要求 : 夹断电压, 漏极饱和电流 对应在转移特性和输入特性图上是什么 场效应管的符号和特性分析 每一类场效应管的符号 —— 是结型or绝缘栅型 增强型or耗尽型 是N沟道orP沟道 ... Ugs怎么求... 如何根据图确定类型 根据转移特性和输出特性确定类型 4.1 | 结构, 类型, 输入输出关系 ( 了解, 不要求计算 ) 漏极D ( 对应C ) 栅极G ( 对应B ) 源极S ( 对应E ) 分类 : 结型 绝缘栅型 增强型 耗尽型 结型 : ( N沟道为例, P沟道完全相反即可 ) 特点 : $V{GS}$反向增加到夹断电压$V_P$时产生夹断, 当$V{GD} = V{GS}-V{DS} = V_P$时产生预夹断 结型场效应管 | 类型 | 符号 | 转移特性 | 输出特性 绝缘栅型 : 结型 绝缘栅型 转移特性 输出特性 第五章 负反馈放大电路 5.1 | 反馈的基本概念 电压反馈, 电流反馈 | 直流反馈, 交流反馈 | 串联反馈, 并联反馈 | 局部反馈, 级间反馈 5.2 | 负反馈对放大电路性能的影响 降低放大倍数， 提高放大倍数的稳定性 改变输入电阻和输出电阻 稳定输出信号 ( 输出电压, 输出电流 ) 展宽通频带 减小非线性失真 5.3 | 1 + AF倍——增大就是乘( 1+AF ), 减小就是除( 1+AF ) ( 一个填空/简答 电压or电流or串联or并联负 反馈增大还是减小了输入还是输出电阻啊? ) 并联负反馈使输入电阻减小，串联负反馈使输入电阻增大 电压负反馈使输出电阻减小，电流负反馈使输出电阻增大 5.4 | 指标计算不要求 第六章 集成运算放大器 6.1 | 什么是零点漂移 当输入为0时，输出信号不为零。一般由温度引起 6.2 | 差模放大倍数$Ad$ 共模放大倍数$A_c$ 共模抑制比$K{CMR}$ KCMR=∣AdAc∣ K_{CMR} = \\left| \\frac{A_{d}}{A_{c}}\\right| K​CMR​​=​∣​∣​∣​∣​​​A​c​​​​A​d​​​​​∣​∣​∣​∣​​ 在参数理想对称的情况下$K_{CMR}$ = ∞ 长尾抑制共模信号 放大差模信号 6.3| 题目 : 给出差动放大电路和两端输入信号u1和u2 ( 一般输入情况 ), 利用差动放大电路, 由u1和u2求最后的输出电压 | 6.2.6 「一般输入情况」例题, PPT差动放大电路的4种解法 一般输入信号情况 注意差模输入电压 ( 分量 )为两者之差没有除以二, 共模输入电压除以二 6.2.6题目 6.2.6 一般输入信号情况 | 例题 差模放大倍数为负 差模输入为u1 - u2 ( 而不是u2 - u1, 不一样 ) 要把dB化为比例的值 之后内容不要求 第七章 集成运放 比例, 求和电路和电路设计都是重点 7.1 | 理解理想集成运放的具体参数, 开环差模放大倍数, 共模抑制比啥啥啥什么是无穷大什么是0 | 什么是虚短和什么是虚断 | 根据电路的结构列出输入和输出的关系 关于理想化参数指标 : 开环差模电压放大倍数 : $A_{od}=∞$ 输入电阻ri : ∞ 输出电阻ro : 0 输入偏置电阻 : 0 共模抑制比$K_{CMR}$ : ∞ 关于虚短和虚断, 虚地 : 虚短 : $U+\\approx U-$ 虚断 : $I+\\approx I-\\approx 0$ 虚地 : 运放在反相输入状态下 ( 同相接地, 此时$U+\\approx U-\\approx 0$ 同相输入和反相输入 同相输入和反相输入 加减运算电路 同相求和和反相求和 加减运算电路 7.2 | 题 : 给U = xxU1 + xxU2, 首推「两级运放」构成的求和电路 例题 : 设计一个加减运算电路, $R{F}=240 \\mathrm{k} \\Omega$ , 使得满足 : $\\boldsymbol{u}{o}=\\mathbf{1 0} \\boldsymbol{u}{i 1}+\\boldsymbol{8} \\boldsymbol{u}{i 2}-\\mathbf{2 0} \\boldsymbol{u}_{i 3}$ 方法一 | 单级运放电路 单级运放答案 问题 : 计算并联关系不方便 方法二 | 两级运放电路 常用形式 Uo1=−Rf(1R3Ui3+1R4Ui4)Uo=−Rf(1RfUo1+1R1Ui1+1R2Ui2)=Rf(1R3Ui3+1R4Ui4−1R1Ui1−1R2Ui2) \\begin{aligned} \tU_{o_1}&=-R_f\\left( \\frac{1}{R_3}U_{i_3}+\\frac{1}{R_4}U_{i_4} \\right)\\\\ \tU_o&=-R_f\\left( \\frac{1}{R_f}U_{o_1}+\\frac{1}{R_1}U_{i_1}+\\frac{1}{R_2}U_{i_2} \\right)\\\\ \t&=R_f\\left( \\frac{1}{R_3}U_{i_3}+\\frac{1}{R_4}U_{i_4}-\\frac{1}{R_1}U_{i_1}-\\frac{1}{R_2}U_{i_2} \\right)\\\\ \\end{aligned} ​U​o​1​​​​​U​o​​​​​​​=−R​f​​(​R​3​​​​1​​U​i​3​​​​+​R​4​​​​1​​U​i​4​​​​)​=−R​f​​(​R​f​​​​1​​U​o​1​​​​+​R​1​​​​1​​U​i​1​​​​+​R​2​​​​1​​U​i​2​​​​)​=R​f​​(​R​3​​​​1​​U​i​3​​​​+​R​4​​​​1​​U​i​4​​​​−​R​1​​​​1​​U​i​1​​​​−​R​2​​​​1​​U​i​2​​​​)​​ 7.3 | 滤波电路不要求 7.4 | 电压比较器清楚7.4.1 会根据比较器电路画出传输特性图, 给你一个比较器电路和输入波形画出输出波形 双向限幅比较器 9, 10章不要看书了, 就看ppt 第九章 低频功率放大电路 了解 : 三类放大电路, 甲类乙类甲乙类 清楚三类电路的特点, 哪一类电路的转化效率最高啊, 哪种电路的失真最小啊 交越失真是什么, 如何消除呢? 甲类, 乙类, 甲乙类的特点 : 功率放大器分类 : 甲类 乙类 甲乙类 甲类工作状态失真小, 静态电流大, 管耗大, 效率低 乙类工作状态失真大, 静态电流为0, 管耗小, 效率高 甲乙类工作状态失真大, 静态电流小, 管耗小, 效率较高 交越失真 : 交越失真的解释 为解决交越失真，可给三极管稍稍加一点偏置，使之工作在甲乙类。 第十章 直流稳压电路 直流稳压电源包括哪些部分, 每一个部分的功能是什么 集成稳压电路的命名规则, 输出的值, 最大输出电压, 最大输出电流是多少 CW79M05输出电压是多少呢, 输出电流是多少呢 5V还是-5V 1.5A还是... 78系列, 79系列构成放大电路, 推输出和输入的关系, 求解输出电压的表达式 10.1 | 直流稳压电源包括哪些部分, 每一个部分的功能是什么 组成部分 交流电网 --- 变压器 --- 整流电路 --- 滤波电路 --- 稳压电路 --- 直流 --- 负载 整流电路 : 利用二极管的单向导电性, 将正负交替的交流电压变换成单方向的直流脉动电压 滤波电路 : 消除电压的脉动成分 滤波电路 稳压电路 : 使得输出电压基本上不随交流电网的电压波动或负载而变化 10.2 | 集成稳压电路的命名规则, 78, 79系列 命名规则 : 78 79系列型号命名 如CW78L05CW78 : 正 --- L : 输出电流100mA --- 05 : 输出电压5V Copyright © note.roccoshi.top 2020 all right reserved，powered by Gitbookupdate time： 2020-08-12 19:16:27 "}}